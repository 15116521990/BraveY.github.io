{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/robots.txt","path":"robots.txt","modified":0,"renderable":0},{"_id":"themes/next-reloaded/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/favicon.png","path":"images/favicon.png","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/favicon16x16.png","path":"images/favicon16x16.png","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/lib/anime.min.js","path":"lib/anime.min.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/js/bookmark.js","path":"js/bookmark.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/js/algolia-search.js","path":"js/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/js/motion.js","path":"js/motion.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/js/next-boot.js","path":"js/next-boot.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/lib/canvas-nest/README.md","path":"lib/canvas-nest/README.md","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/lib/canvas-nest/canvas-nest-nomobile.min.js","path":"lib/canvas-nest/canvas-nest-nomobile.min.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/lib/canvas-nest/LICENSE","path":"lib/canvas-nest/LICENSE","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/js/schemes/pisces.js","path":"js/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/lib/canvas-nest - 副本/LICENSE","path":"lib/canvas-nest - 副本/LICENSE","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/lib/canvas-nest - 副本/README.md","path":"lib/canvas-nest - 副本/README.md","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/lib/canvas-nest - 副本/canvas-nest-nomobile.min.js","path":"lib/canvas-nest - 副本/canvas-nest-nomobile.min.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/lib/canvas-nest - 副本/canvas-nest.min.js","path":"lib/canvas-nest - 副本/canvas-nest.min.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/robots.txt","hash":"bbfef6d0a1bee35d06457106003c6c0e399ea6e0","modified":1573221035771},{"_id":"themes/next-reloaded/.eslintrc.json","hash":"d3c11de434171d55d70daadd3914bc33544b74b8","modified":1573650247500},{"_id":"themes/next-reloaded/.gitignore","hash":"a1b7ccf59a9732e644b1b4d65b024c7e9dfe4a05","modified":1573719785640},{"_id":"themes/next-reloaded/.gitattributes","hash":"3e00e1fb043438cd820d94ee3dc9ffb6718996f3","modified":1573650247501},{"_id":"themes/next-reloaded/.editorconfig","hash":"731c650ddad6eb0fc7c3d4a91cad1698fe7ad311","modified":1573650247499},{"_id":"themes/next-reloaded/LICENSE.md","hash":"0a9c7399f102b4eb0a6950dd31264be421557c7d","modified":1573650247513},{"_id":"themes/next-reloaded/_config.yml","hash":"19d5ccce6523e8d24175bcb7895493b1fceddccb","modified":1573716282004},{"_id":"themes/next-reloaded/README.md","hash":"cea1e65e6e0309c2f7793b1889ecec05ef05725c","modified":1573650247513},{"_id":"themes/next-reloaded/gulpfile.js","hash":"c4cffe4df4ba406d9ab347bc52a0c8059c5050b1","modified":1573650247530},{"_id":"themes/next-reloaded/edited_config.yml","hash":"3fd31325ec4f940a4ebaa8144d0bab7d797c5a97","modified":1573654662648},{"_id":"themes/next-reloaded/package.json","hash":"c4b5e96ccfa6956348c57e15dfa6047935af807c","modified":1573650247585},{"_id":"themes/next-reloaded/.travis.yml","hash":"379f31a140ce41e441442add6f673bf397d863ea","modified":1573650247512},{"_id":"themes/next-reloaded/.stylintrc","hash":"6259e2a0b65d46865ab89564b88fc67638668295","modified":1573650247511},{"_id":"themes/next-reloaded/crowdin.yml","hash":"4a53f5985e545c635cb56b2a57ed290cb8cf8942","modified":1573650247515},{"_id":"source/_posts/2019-03-26-使用Travis-CI自动部署博客.md","hash":"35695761fee3f772393fd4a0b35146e832178cae","modified":1573218929554},{"_id":"source/_posts/2019-03-20-Redis设计与实现读书笔记.md","hash":"030a1f43ab91e616acac87d1c1cc37068d543a8c","modified":1573218920055},{"_id":"source/_posts/2019-03-27-Redis-设计与实现读书笔记——第四章-字典.md","hash":"c15917eccc04cf255bc968dbfca555ae59b0dbde","modified":1573218822256},{"_id":"source/_posts/2019-03-27-剑指offer-读书笔记——第2章.md","hash":"c705a14819ec2d4cce47ff4a9118c7a347bfa89b","modified":1573218874631},{"_id":"source/_posts/2019-03-31-计算Linux系统的CPU利用率.md","hash":"5e87e9ec6249bb911aadcd57fd5b725b5c6d9d88","modified":1573218893661},{"_id":"source/_posts/2019-03-29-Redis设计与实现读书笔记——第8章-对象.md","hash":"af253a9fe4ecf840e7674653afe6427950943e18","modified":1573218910743},{"_id":"source/_posts/2019-04-03-gdb-调试.md","hash":"3fe85dc48474413e45425655ad619d48dfc2dd38","modified":1573218883959},{"_id":"source/_posts/2019-04-01-Docker-学习.md","hash":"2dc81661f9316e0c79873fd1b35757a41d1b4c6d","modified":1573218832912},{"_id":"source/_posts/2019-04-10-Linux-shell脚本计算运行时间.md","hash":"92302d59156c6824dff74e39d1fe84dc9143b999","modified":1573218842619},{"_id":"source/_posts/2019-04-26-Redis-Makefile注解.md","hash":"475fd84b6efcb717d65c1a30be747b79c0f0d8d4","modified":1573218803742},{"_id":"source/_posts/2019-04-17-青蛙跳台阶问题.md","hash":"8a1008c068fd17554277025275b43c308cdddab0","modified":1573444255312},{"_id":"source/_posts/2019-04-25-GCC的编译选项.md","hash":"fae7e7b1a9f53f6615859a5e18e8d5b6118f8268","modified":1573218811703},{"_id":"source/_posts/2019-09-08-OJ输入输出.md","hash":"59ca713f69ea57e46a2b8962f349817ed8508256","modified":1573443285463},{"_id":"source/_posts/2019-08-24-shadowsocks的部署.md","hash":"57e5e073ed7a37a4159cb81f972e98ebe4ab0954","modified":1573218678313},{"_id":"source/_posts/2019-09-08-实模式寻址方式.md","hash":"f70903c082da1b25be563a714054ee2023db616d","modified":1573218738272},{"_id":"source/_posts/2019-10-07-逆序对的计数.md","hash":"f8569a7762a20d3b253f918458ed5bc6aa0c6c21","modified":1573663673243},{"_id":"source/_posts/2019-09-19-数组中的第K大的数.md","hash":"e62393ac2d78a97ba21e63864b0ec611903abbfb","modified":1573444193617},{"_id":"source/_posts/2019-10-14-数组中的主要元素.md","hash":"3fffdd8d0b374586f8679cacae859534dd8c14bb","modified":1573663577188},{"_id":"themes/next-reloaded/reload_bak_config.yml","hash":"a952a57b271963b4f579f993d678e155b6de6f48","modified":1573650247514},{"_id":"source/_posts/2019-10-31-内嵌汇编.md","hash":"e5458ffdf67f46a4f67f48cf9e2d51a6346f1b9a","modified":1573269005388},{"_id":"source/_posts/2019-11-07-Clementine教程.md","hash":"f68987ae6408e17a3872fbac00bc5dc77f32aef2","modified":1573473074326},{"_id":"source/_posts/BigdataBench-deploy.md","hash":"3f0bee3ca87f917c4de9d6e722c45c6defc2f49e","modified":1573218712787},{"_id":"source/_posts/Linux 命令 学习.md","hash":"45a03144efd0f17a9c9fe3c041d4c41fdbcb3547","modified":1573218993020},{"_id":"source/_posts/apt-get install 失败.md","hash":"44e05ee8ec75520a53daae8c667b16d6963314db","modified":1573219014015},{"_id":"source/_posts/make学习.md","hash":"c6ffd8a913be89c042411ef126baa2e5a11250a3","modified":1573218793283},{"_id":"source/_posts/ceph部署文档.md","hash":"e9e153c84949498e0f335e8e96dc20ee086c5d14","modified":1573218703727},{"_id":"source/_posts/使用YCSB 评测redis性能.md","hash":"2706432c2446e6ce6bc87acb5cb3ba558bc87a44","modified":1573218964265},{"_id":"source/_posts/ping 问题.md","hash":"448ffea3ba1108ac8c9397e4a1d7c27113fddfc4","modified":1573218982252},{"_id":"source/_posts/tee命令解析.md","hash":"01039140d54bbd67b43b4b48679c42b019e4e271","modified":1573701341475},{"_id":"source/_posts/图计算常用算法.md","hash":"0eac96edbcd9abc27b21f2fd7b05ad3bfb6b3b45","modified":1573218948042},{"_id":"source/_posts/使用shell脚本遍历redis数据库中的所有kv对.md","hash":"2ca613aa393cd64b563ef5de291a61d7fb3c195d","modified":1573218939540},{"_id":"source/categories/index.md","hash":"a9e619f11903bc0331f052475b269335d9a2a019","modified":1553578252809},{"_id":"source/tags/index.md","hash":"079964de51a26ff63e1fadd50b5387b60c62633a","modified":1553578252810},{"_id":"themes/next-reloaded/.github/CODE_OF_CONDUCT.md","hash":"778b7e052993ed59f21ed266ba7119ee2e5253fb","modified":1573650247501},{"_id":"themes/next-reloaded/.github/PULL_REQUEST_TEMPLATE.md","hash":"15b0ac46f260743c925ab2eba3f081640a21cd3a","modified":1573650247506},{"_id":"themes/next-reloaded/.github/CONTRIBUTING.md","hash":"06b62d1b37ed1b48210fe27158e83b4dbc5ed23d","modified":1573650247502},{"_id":"themes/next-reloaded/.github/eslint-disable-bot.yml","hash":"e06053d417579ed967a94166deb6bda5ce41d805","modified":1573650247507},{"_id":"themes/next-reloaded/.github/issue_label_bot.yaml","hash":"18eddb3ba5e94cac0642134581f86e26f568d388","modified":1573650247508},{"_id":"themes/next-reloaded/.github/config.yml","hash":"cbd06d0c40afa9fdf056765120e9085826b00d20","modified":1573650247507},{"_id":"themes/next-reloaded/.github/auto_assign.yml","hash":"9fe0dbe3f6edc59bf10ea25b14eba0e92e2c8f42","modified":1573650247506},{"_id":"themes/next-reloaded/.github/mergeable.yml","hash":"1c1cb77a62df1e3654b151c2da34b4a10d351170","modified":1573650247509},{"_id":"themes/next-reloaded/.github/lock.yml","hash":"3ce3d0a26030a1cd52b273cc6a6d444d7c8d85c2","modified":1573650247508},{"_id":"themes/next-reloaded/.github/stale.yml","hash":"b2b762645d3c3e373e0b2c861bf2ddf7f303c577","modified":1573650247510},{"_id":"themes/next-reloaded/docs/ALGOLIA-SEARCH.md","hash":"5ace79ff1859d985339fdf6d74b779f60c91a27a","modified":1573650247516},{"_id":"themes/next-reloaded/docs/AGPL3.md","hash":"f463f95b169d64983f59fa6f3e4b6760290a0e6b","modified":1573650247515},{"_id":"themes/next-reloaded/docs/DATA-FILES.md","hash":"062b36699c78676a25e3da95bb197841adb600ba","modified":1573650247517},{"_id":"themes/next-reloaded/docs/INSTALLATION.md","hash":"07ea00bee149a1bdc9073e903ee6b411e9f2f818","modified":1573650247518},{"_id":"themes/next-reloaded/docs/AUTHORS.md","hash":"cde7cc095ac31b421a573042cf61060f90d9ad0d","modified":1573650247517},{"_id":"themes/next-reloaded/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"356ada9837300bcdd1711321dabc309887e23730","modified":1573650247518},{"_id":"themes/next-reloaded/docs/UPDATE-FROM-5.1.X.md","hash":"20e2223836233c812f268b4a7050762dd56cf2be","modified":1573650247520},{"_id":"themes/next-reloaded/docs/LICENSE.txt","hash":"ae5ad07e4f4106bad55535dba042221539e6c7f9","modified":1573650247519},{"_id":"themes/next-reloaded/docs/MATH.md","hash":"6f6faf58f86b03b9344ef857ae34de97fc336590","modified":1573650247520},{"_id":"themes/next-reloaded/.github/release-drafter.yml","hash":"09c3352b2d643acdc6839601ceb38abc38ab97c5","modified":1573650247509},{"_id":"themes/next-reloaded/.github/support.yml","hash":"7ce2722d6904c31a086444c422dc49b6aa310651","modified":1573650247510},{"_id":"themes/next-reloaded/languages/de.yml","hash":"c94ff69db40c22de61ce6446cdc9108177379074","modified":1573650247531},{"_id":"themes/next-reloaded/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1573650247531},{"_id":"themes/next-reloaded/languages/id.yml","hash":"1c321f62378dc029f7b795ad2fcb0f80277de52f","modified":1573650247535},{"_id":"themes/next-reloaded/languages/es.yml","hash":"203084eace039610ac097e0e6ce6b5f4f8356217","modified":1573650247532},{"_id":"themes/next-reloaded/languages/fa.yml","hash":"856e19aec28767e1f91a8e805011f82c7601ec60","modified":1573650247533},{"_id":"themes/next-reloaded/languages/en.yml","hash":"f6a8d95948762c978d2ed065c5f87d2061aa6fc1","modified":1573650247532},{"_id":"themes/next-reloaded/languages/fr.yml","hash":"a9ac6ce36e97a06ad6ab3431eb652b8702b7a63e","modified":1573650247534},{"_id":"themes/next-reloaded/languages/ja.yml","hash":"8341ccdd1b2fbf11e9d80c1aacd37a969c57ca9c","modified":1573650247536},{"_id":"themes/next-reloaded/languages/pt-BR.yml","hash":"075140b21edd6cb0ec1e9b3e79e1339d1e1a17e4","modified":1573650247538},{"_id":"themes/next-reloaded/languages/it.yml","hash":"08b2db3eece91edd2759ca4b26de74b2992c7dae","modified":1573650247535},{"_id":"themes/next-reloaded/languages/hu.yml","hash":"313894fd5615e37c1935a235f8f702df7852345a","modified":1573650247534},{"_id":"themes/next-reloaded/languages/ko.yml","hash":"4f3a4165ceaaada238316fe8bd2438f775abebfc","modified":1573650247537},{"_id":"themes/next-reloaded/languages/ru.yml","hash":"ca8f3c22fb10cf3e455890e0f1f2b29b8814a702","modified":1573650247539},{"_id":"themes/next-reloaded/languages/nl.yml","hash":"387ea251057164f8dcd38553bac01a909cf11f0d","modified":1573650247538},{"_id":"themes/next-reloaded/languages/uk.yml","hash":"aa90a1b6f12f5bae1ff6386ea99c63db901179a8","modified":1573650247541},{"_id":"themes/next-reloaded/languages/pt.yml","hash":"7d3f040065b0a04a23d3be42ddfcafc95f79854e","modified":1573650247539},{"_id":"themes/next-reloaded/languages/vi.yml","hash":"a5f60a2b3dc1b90b867e99dd3b108113a04f9ba5","modified":1573650247541},{"_id":"themes/next-reloaded/languages/tr.yml","hash":"c99f21a9cb86957618428e488ece24df063222f3","modified":1573650247540},{"_id":"themes/next-reloaded/languages/zh-CN.yml","hash":"8c70af9442f12aa65e8737774ea032bb6420a715","modified":1573650247542},{"_id":"themes/next-reloaded/languages/zh-HK.yml","hash":"1c8b8ad49a15ea3491555a2ae1819b1ad405fab2","modified":1573650247542},{"_id":"themes/next-reloaded/languages/zh-TW.yml","hash":"7402f4b899dbeead3641417bfaf5f46f3a3934a5","modified":1573650247543},{"_id":"themes/next-reloaded/layout/_layout.swig","hash":"6eb89a44dc5e958b41df8a673cc28f67bb56ccf3","modified":1573650247544},{"_id":"themes/next-reloaded/layout/index.swig","hash":"014202a6e316096f85f8c1489568d31212c5f1b2","modified":1573650247583},{"_id":"themes/next-reloaded/layout/category.swig","hash":"9febc49ff6f476fd0261c75aecbc67cc24c11667","modified":1573650247583},{"_id":"themes/next-reloaded/layout/archive.swig","hash":"54a96d109374536b5f2ef1bb8b6f82825dc810c9","modified":1573650247582},{"_id":"themes/next-reloaded/scripts/renderer.js","hash":"e3658eea97b1183ee2e9f676231e53f7994741f6","modified":1573650247598},{"_id":"themes/next-reloaded/layout/tag.swig","hash":"eedd3a19aa5222184ea6ee628fa46dfa0654ece8","modified":1573650247585},{"_id":"themes/next-reloaded/layout/page.swig","hash":"8322d902a8d870e6d0b0bc25750141c51749bf8b","modified":1573650247584},{"_id":"themes/next-reloaded/layout/post.swig","hash":"d75078e7acd9ead60dee9bec05b2b4f60e121177","modified":1573650247584},{"_id":"source/_posts/BigdataBench-deploy/runcc.png","hash":"92edff3c535d6744e38fd0b933a5474d768b5ecc","modified":1553578252794},{"_id":"source/_posts/Redis源码阅读——SDS/2019-03-22-Redis源码阅读——SDS.md","hash":"dd5b8de63ba9950621d9003289895f1dcc16ada3","modified":1573219044974},{"_id":"source/_posts/Redis源码阅读——SDS/memset.png","hash":"728c1559807187a4badabbfa2ed7cee503648e16","modified":1553578252798},{"_id":"source/_posts/Redis源码阅读——SDS/sds.png","hash":"8ca71f0c564d44bbe5c792a3fc5bbb53b49f22c5","modified":1553578252799},{"_id":"themes/next-reloaded/.github/ISSUE_TEMPLATE/bug-report.md","hash":"6f669d3ac018915a130d72e483666d0d63560c94","modified":1573650247503},{"_id":"themes/next-reloaded/.github/ISSUE_TEMPLATE/other.md","hash":"efe32a27eb47ff28dc2a3783a50dbde5a4627b9f","modified":1573650247504},{"_id":"themes/next-reloaded/.github/ISSUE_TEMPLATE/feature-request.md","hash":"dea66b33b57f18b3ab6d807741c7cf776366f6d2","modified":1573650247504},{"_id":"themes/next-reloaded/.github/ISSUE_TEMPLATE/question.md","hash":"5804fc485a683839b797003ce6402b907ed5791d","modified":1573650247505},{"_id":"themes/next-reloaded/docs/ru/DATA-FILES.md","hash":"6db9eb0e2393a391a5e17b62a43b264fce5ed018","modified":1573650247521},{"_id":"themes/next-reloaded/docs/ru/UPDATE-FROM-5.1.X.md","hash":"510cfd27e37e3a611649a3d1a84cc52fd4da5936","modified":1573650247524},{"_id":"themes/next-reloaded/docs/ru/INSTALLATION.md","hash":"a9cfe5ac9ef727a8650b2b6584482751a26b1460","modified":1573650247522},{"_id":"themes/next-reloaded/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"7202fd76db39f8246a0f80aab68b720d89f48af1","modified":1573650247525},{"_id":"themes/next-reloaded/docs/ru/README.md","hash":"7b5fa4461646677e4ab5cb271477795987ba1ab3","modified":1573650247523},{"_id":"themes/next-reloaded/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"fcbe8e8d7ad39028936ba341f4154e4f9234d8b2","modified":1573650247525},{"_id":"themes/next-reloaded/docs/zh-CN/DATA-FILES.md","hash":"a7de5ce2931290a67feebd149e41a9648de4bb83","modified":1573650247527},{"_id":"themes/next-reloaded/docs/zh-CN/INSTALLATION.md","hash":"716111dd36d276f463c707dfcc9937fea2a1cf7a","modified":1573650247527},{"_id":"themes/next-reloaded/docs/zh-CN/CONTRIBUTING.md","hash":"ff3a003820ccc63c06a6df2117d023959c7cf4ec","modified":1573650247526},{"_id":"themes/next-reloaded/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"9916a1a0883d5807ddc0cc2607c878d1e1f5fa0a","modified":1573650247528},{"_id":"themes/next-reloaded/docs/zh-CN/MATH.md","hash":"bfd10209878e6252467311f9544841751c465058","modified":1573650247529},{"_id":"themes/next-reloaded/docs/zh-CN/README.md","hash":"8845e67bc594a5cdbfad617374faef34230841c6","modified":1573650247529},{"_id":"themes/next-reloaded/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"e93a800008567dd48b6f388982ec72db91bb913a","modified":1573650247530},{"_id":"themes/next-reloaded/layout/_partials/footer.swig","hash":"ce3423a66ba62335a761ff213106e2b8bb906a69","modified":1573704098863},{"_id":"themes/next-reloaded/layout/_partials/widgets.swig","hash":"5392dcbb504266f0f61d5b8219914068ef9cdc25","modified":1573650247559},{"_id":"themes/next-reloaded/layout/_partials/pagination.swig","hash":"29ce76e36011da76c50d482396e2558f72525fe0","modified":1573650247553},{"_id":"themes/next-reloaded/layout/_scripts/index.swig","hash":"1822eaf55bbb4bec88871c324fc18ad95580ccb4","modified":1573650247560},{"_id":"themes/next-reloaded/layout/_scripts/noscript.swig","hash":"7b9e0f776a5be6c3f95bc7f394e1424ba02ba93b","modified":1573650247560},{"_id":"themes/next-reloaded/layout/_scripts/three.swig","hash":"6b092c6d882b2dfa5273e1b3f60b244cb7c29fcd","modified":1573650247564},{"_id":"themes/next-reloaded/layout/_scripts/vendors.swig","hash":"244ca2d74ee0d497c87572c6a26b43c62a952673","modified":1573650247565},{"_id":"themes/next-reloaded/layout/_scripts/pjax.swig","hash":"f1c4611c543eddf364dce68dd9825f3df958aab3","modified":1573650247561},{"_id":"themes/next-reloaded/layout/_macro/post-collapse.swig","hash":"db25de9ceaa1ec5650ff15cf4aee4399ed8f9c42","modified":1573650247544},{"_id":"themes/next-reloaded/layout/_partials/comments.swig","hash":"223bd7b04acb32ddbe813f21a75290e1461630fb","modified":1573650247546},{"_id":"themes/next-reloaded/layout/_third-party/index.swig","hash":"c6b63cbc80938e6e09578b8c67e01adf13a9e3bd","modified":1573650247573},{"_id":"themes/next-reloaded/layout/_macro/post.swig","hash":"cb456a03e794f04b081d03fe9e3ccc148cafaf22","modified":1573650247545},{"_id":"themes/next-reloaded/layout/_macro/sidebar.swig","hash":"be603e35bea3431b133fcd4b9626993dcfb85c06","modified":1573650247545},{"_id":"themes/next-reloaded/scripts/events/index.js","hash":"37347490d7960955e65f0a172aaae6423e7eec48","modified":1573650247587},{"_id":"themes/next-reloaded/scripts/filters/default-injects.js","hash":"ad321db012cea520066deb0639335e9bc0dcc343","modified":1573650247594},{"_id":"themes/next-reloaded/scripts/filters/front-matter.js","hash":"305d03c1e45782988809298c3e3b3c5d5ee438aa","modified":1573650247594},{"_id":"themes/next-reloaded/scripts/filters/locals.js","hash":"71afa945066c24a46b6ac172c23415dd8bdedd4a","modified":1573650247595},{"_id":"themes/next-reloaded/scripts/helpers/font.js","hash":"20317a314d2283e4f87c8c8d247422f33427ebbe","modified":1573650247597},{"_id":"themes/next-reloaded/scripts/filters/post.js","hash":"7c86c0fb9179e02e0e530c9b90483cd3db2a400d","modified":1573650247596},{"_id":"themes/next-reloaded/scripts/filters/minify.js","hash":"21196a48cb127bf476ce598f25f24e8a53ef50c2","modified":1573650247595},{"_id":"themes/next-reloaded/scripts/helpers/engine.js","hash":"a2d2f19271ad1d347c05c3195b5d3f53d2eb8af4","modified":1573650247596},{"_id":"themes/next-reloaded/scripts/helpers/next-url.js","hash":"3340964985ada2ad6beb7ec8a3321eacbdc61980","modified":1573650247597},{"_id":"themes/next-reloaded/scripts/tags/button.js","hash":"39156bf735c1d1ebd0d418c411f14ff4f0acdd75","modified":1573650247598},{"_id":"themes/next-reloaded/scripts/tags/center-quote.js","hash":"4519ab8e6898f2ee90d05cde060375462b937a7d","modified":1573650247599},{"_id":"themes/next-reloaded/scripts/tags/caniuse.js","hash":"6fbc5764dddca114667f1487120a9ed32519857b","modified":1573650247599},{"_id":"themes/next-reloaded/scripts/tags/group-pictures.js","hash":"47de27db13f25ae124c7284ccdb026b1b297f65a","modified":1573650247600},{"_id":"themes/next-reloaded/scripts/tags/label.js","hash":"fc83f4e1be2c34e81cb79938f4f99973eba1ea60","modified":1573650247600},{"_id":"themes/next-reloaded/scripts/tags/note.js","hash":"1fdf4f95810fdb983bfd5ad4c4f13fedd4ea2f8d","modified":1573650247601},{"_id":"themes/next-reloaded/layout/_third-party/rating.swig","hash":"206644ff2c769226a58a9039eda9206302460626","modified":1573650247576},{"_id":"themes/next-reloaded/scripts/tags/mermaid.js","hash":"81134494ff0134c0dae1b3815caf6606fccd4e46","modified":1573650247601},{"_id":"themes/next-reloaded/scripts/tags/pdf.js","hash":"ab995f0fc60d60f637220e2651111b775b8a06de","modified":1573650247602},{"_id":"themes/next-reloaded/layout/_third-party/quicklink.swig","hash":"fef4bfec70cb877c23c7a6b096d35b1579d0e2b2","modified":1573650247575},{"_id":"themes/next-reloaded/scripts/tags/tabs.js","hash":"72a5adbd8f300bee1d0c289367598ca06b2bed17","modified":1573650247602},{"_id":"themes/next-reloaded/scripts/tags/video.js","hash":"944293fec96e568d9b09bc1280d5dbc9ee1bbd17","modified":1573650247603},{"_id":"themes/next-reloaded/source/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1573650247660},{"_id":"themes/next-reloaded/layout/_third-party/baidu-push.swig","hash":"bd9ba0bf60cc3008ee14339fa395ee6af188e879","modified":1573650247567},{"_id":"themes/next-reloaded/source/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1573650247659},{"_id":"themes/next-reloaded/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1573650247660},{"_id":"themes/next-reloaded/source/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1573650247661},{"_id":"themes/next-reloaded/source/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1573650247661},{"_id":"themes/next-reloaded/source/css/main.styl","hash":"ee7c731c03d724827d9324d08be701c9d2f04c60","modified":1573650247659},{"_id":"themes/next-reloaded/source/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1573650247662},{"_id":"themes/next-reloaded/source/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1573650247663},{"_id":"themes/next-reloaded/source/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1573650247662},{"_id":"themes/next-reloaded/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1573650247664},{"_id":"themes/next-reloaded/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1573650247665},{"_id":"themes/next-reloaded/source/images/favicon.png","hash":"9ad0834cb90e0a8ff8ee739e51d8109aceb7cf68","modified":1573202476399},{"_id":"themes/next-reloaded/source/images/favicon16x16.png","hash":"a63a2e0b78898ee887f4cced3e2b9559dc0dcc3f","modified":1573660544398},{"_id":"themes/next-reloaded/source/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1573650247665},{"_id":"themes/next-reloaded/source/lib/anime.min.js","hash":"960be51132134acd65c2017cc8a5d69cb419a0cd","modified":1573650247673},{"_id":"themes/next-reloaded/source/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1573650247663},{"_id":"themes/next-reloaded/source/js/bookmark.js","hash":"6531c706f34c38d8b44afebfac60cc35171d36f3","modified":1573650247668},{"_id":"themes/next-reloaded/source/js/algolia-search.js","hash":"f632ff7a404ac4fb04313bc554815406ebcb2a0b","modified":1573650247667},{"_id":"themes/next-reloaded/source/js/motion.js","hash":"19a589098fd13993cb3d198a96f0ed45e1560a64","modified":1573650247669},{"_id":"themes/next-reloaded/source/js/local-search.js","hash":"7b0ac87fd6a3cc43d538fe6228429c97876173b6","modified":1573650247668},{"_id":"themes/next-reloaded/source/js/next-boot.js","hash":"81454487703958e2ce06965fd3879c1d859b6f36","modified":1573650247669},{"_id":"themes/next-reloaded/source/js/utils.js","hash":"ae7714d74d4029fbd9d9a86ae42885c20f42cae3","modified":1573650247672},{"_id":"themes/next-reloaded/source/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1573650247666},{"_id":"themes/next-reloaded/source/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1573650247664},{"_id":"themes/next-reloaded/source/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1573650247666},{"_id":"themes/next-reloaded/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1573650247644},{"_id":"themes/next-reloaded/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1573650247643},{"_id":"themes/next-reloaded/layout/_partials/header/index.swig","hash":"94edc28022325ba21b4e23bb13e1fac337223adc","modified":1573650247549},{"_id":"themes/next-reloaded/layout/_partials/head/head-unique.swig","hash":"8fc1611774b54a8afee1792c4d8ab2d9581a259b","modified":1573650247547},{"_id":"themes/next-reloaded/layout/_partials/header/brand.swig","hash":"36d64a542b709490489c8c61269216f47241793a","modified":1573650247549},{"_id":"themes/next-reloaded/layout/_partials/header/menu-item.swig","hash":"2eb7c38ce833e9c5aa7967528af123c36971af5a","modified":1573650247550},{"_id":"themes/next-reloaded/layout/_partials/head/head.swig","hash":"07db7b202ba7d7c849704e175a85a0e6db44fdcc","modified":1573650247548},{"_id":"themes/next-reloaded/layout/_partials/header/sub-menu.swig","hash":"cdae167fbf8ef9904d52a2b76579bc8ca0c5458d","modified":1573650247551},{"_id":"themes/next-reloaded/layout/_partials/post/post-copyright.swig","hash":"d3fa29e2d83f29357760e02f32fb5597db8aa780","modified":1573650247554},{"_id":"themes/next-reloaded/layout/_partials/header/menu.swig","hash":"abef4951b8f0eb5fd11067b775b0144c613e8237","modified":1573650247550},{"_id":"themes/next-reloaded/layout/_partials/page/breadcrumb.swig","hash":"91c0addb33006619faa4c32e5d66874e25f1e9b3","modified":1573650247552},{"_id":"themes/next-reloaded/layout/_partials/post/post-related.swig","hash":"bc7b047a6246df07767373644b1637d91c3a88b1","modified":1573650247555},{"_id":"themes/next-reloaded/layout/_partials/page/page-header.swig","hash":"b3b4ffcbda422d7fc21ee43fec7d2a5056b2f381","modified":1573650247552},{"_id":"themes/next-reloaded/layout/_partials/post/post-footer.swig","hash":"ce712c110b5ce8aacba7a86b0558ff89700675c9","modified":1573650247555},{"_id":"themes/next-reloaded/layout/_partials/search/algolia-search.swig","hash":"f9017a2deb2f262912476e94822081bb10ee43af","modified":1573650247557},{"_id":"themes/next-reloaded/layout/_partials/post/post-reward.swig","hash":"c6d3b1a3fae969d9c03ee48207925fc71e0a63d9","modified":1573650247556},{"_id":"themes/next-reloaded/layout/_partials/search/index.swig","hash":"f1107c28661370e10e1940bff856f22f14f08518","modified":1573650247557},{"_id":"themes/next-reloaded/layout/_partials/search/localsearch.swig","hash":"98453ac4a520b2600181fc0331f0067125d0ed4f","modified":1573650247558},{"_id":"themes/next-reloaded/layout/_scripts/schemes/mist.swig","hash":"0b44f400ec00d2b5add5ee96c11d22465c432376","modified":1573650247563},{"_id":"themes/next-reloaded/layout/_scripts/schemes/muse.swig","hash":"0b44f400ec00d2b5add5ee96c11d22465c432376","modified":1573650247563},{"_id":"themes/next-reloaded/layout/_partials/sidebar/site-overview.swig","hash":"842beaadaa2800679667e91fe946f50bded44bc6","modified":1573650247558},{"_id":"themes/next-reloaded/layout/_scripts/schemes/gemini.swig","hash":"34495d408e8467555afee489500b8aad98c52079","modified":1573650247562},{"_id":"themes/next-reloaded/layout/_scripts/schemes/pisces.swig","hash":"34495d408e8467555afee489500b8aad98c52079","modified":1573650247563},{"_id":"themes/next-reloaded/layout/_scripts/pages/schedule.swig","hash":"026087c0be7ec598eba9df2e877cfebf8850d651","modified":1573650247561},{"_id":"themes/next-reloaded/layout/_third-party/chat/chatra.swig","hash":"e8aa0ba146b658ae3b73efc4ca63325886bbaa2d","modified":1573650247568},{"_id":"themes/next-reloaded/layout/_third-party/analytics/google-analytics.swig","hash":"f2ef530c77798b19653b4fd3339cc6ae3b9f0afe","modified":1573650247566},{"_id":"themes/next-reloaded/layout/_third-party/analytics/index.swig","hash":"85b60e222712ca3b2c4dc2039de2dc36b8d82940","modified":1573650247567},{"_id":"themes/next-reloaded/layout/_third-party/chat/tidio.swig","hash":"fb94ee487d75e484e59b7fba96e989f699ff8a83","modified":1573650247569},{"_id":"themes/next-reloaded/layout/_third-party/analytics/baidu-analytics.swig","hash":"84adaadd83ce447fa9da2cff19006334c9fcbff9","modified":1573650247566},{"_id":"themes/next-reloaded/layout/_third-party/comments/disqusjs.swig","hash":"c378efaef4052dbeda0c2356b2b90f2d26eeb83a","modified":1573650247571},{"_id":"themes/next-reloaded/layout/_third-party/analytics/growingio.swig","hash":"91c2cb900c76224c5814eeb842d1d5f517f9bf05","modified":1573650247567},{"_id":"themes/next-reloaded/layout/_third-party/comments/gitalk.swig","hash":"a4402ded51db062d293a53de40dcf206a16e684e","modified":1573650247571},{"_id":"themes/next-reloaded/layout/_third-party/comments/disqus.swig","hash":"0f703d0cfca6149d4ada7af346ce4adbf257fd18","modified":1573650247570},{"_id":"themes/next-reloaded/layout/_third-party/comments/valine.swig","hash":"a748a1e25df83ab8f53e4c9bc3370139912c3877","modified":1573650247573},{"_id":"themes/next-reloaded/layout/_third-party/math/index.swig","hash":"59df21fcfe9d0ada8cee3188cb1075529c1c3eb8","modified":1573650247574},{"_id":"themes/next-reloaded/layout/_third-party/comments/livere.swig","hash":"ef38217a457749e528cf00c487b99cb963ccfbea","modified":1573650247572},{"_id":"themes/next-reloaded/layout/_third-party/math/katex.swig","hash":"276f523e414d4aa7f350a8f2fd3df8a3d8ea9656","modified":1573650247574},{"_id":"themes/next-reloaded/layout/_third-party/search/localsearch.swig","hash":"58296a5c1883f26464c2a5ccf734c19f5fbf395a","modified":1573650247577},{"_id":"themes/next-reloaded/layout/_third-party/search/algolia-search.swig","hash":"35fb1f6438111451ccfbb8ba4a6a8424259c0149","modified":1573650247576},{"_id":"themes/next-reloaded/layout/_third-party/search/swiftype.swig","hash":"aa6ab95b8b76611694613defb4bf25003d1b927f","modified":1573650247577},{"_id":"themes/next-reloaded/layout/_third-party/comments/changyan.swig","hash":"a7a26afd3118e036621f802bad42c0cbcced9676","modified":1573650247569},{"_id":"themes/next-reloaded/layout/_third-party/statistics/cnzz-analytics.swig","hash":"53a0760c75d5aaabb3ce8e8aa8e003510d59807f","modified":1573650247578},{"_id":"themes/next-reloaded/layout/_third-party/tags/pdf.swig","hash":"42e7beed8c7583e0c0612692eebfa5743cc4d006","modified":1573650247582},{"_id":"themes/next-reloaded/layout/_third-party/math/mathjax.swig","hash":"1a8bdd6fa16f609872c8f92b546e29a16031b1f5","modified":1573650247575},{"_id":"themes/next-reloaded/layout/_third-party/statistics/firestore.swig","hash":"edeb02d4d56c11536eaed5a8b4705b717f357895","modified":1573650247579},{"_id":"themes/next-reloaded/layout/_third-party/statistics/busuanzi-counter.swig","hash":"5b5618c2f6ad1d7971e6db257222fce89aa56565","modified":1573650247578},{"_id":"themes/next-reloaded/layout/_third-party/tags/mermaid.swig","hash":"db17f093ecf23e960a32af661c6b9a0651281a6b","modified":1573650247582},{"_id":"themes/next-reloaded/layout/_third-party/statistics/index.swig","hash":"ec3c1cd6ace7e6a01b490ac323a4e1ec1fa65fd1","modified":1573650247579},{"_id":"themes/next-reloaded/scripts/events/lib/config.js","hash":"2ebf60495afccfef49eb35e28bc672f531a316b1","modified":1573650247588},{"_id":"themes/next-reloaded/scripts/events/lib/injects.js","hash":"8cd0203eb137eec05b28a11c6aa57e150fc3fa68","modified":1573650247589},{"_id":"themes/next-reloaded/scripts/filters/comment/changyan.js","hash":"9a3a1ad60c51926e286d92063b19ec03b60d37b7","modified":1573650247590},{"_id":"themes/next-reloaded/scripts/events/lib/injects-point.js","hash":"08496b71c9939718e7955704d219e44d7109247b","modified":1573650247589},{"_id":"themes/next-reloaded/scripts/filters/comment/common.js","hash":"31a6c8fbdfa16112b0b099727437b9df7641d421","modified":1573650247591},{"_id":"themes/next-reloaded/scripts/filters/comment/default-config.js","hash":"0c3bea89d64bc12c1bbe6f208a83773c6fb5375a","modified":1573650247591},{"_id":"themes/next-reloaded/scripts/filters/comment/disqus.js","hash":"2f5d1cdc9e1c3498c3d59da01bd89e3e45cd95d3","modified":1573650247591},{"_id":"themes/next-reloaded/scripts/filters/comment/disqusjs.js","hash":"f53cf433714bfef152d5e5463c748216c196e460","modified":1573650247592},{"_id":"themes/next-reloaded/scripts/filters/comment/gitalk.js","hash":"323a47df6ded894944a2647db44556d6163e67c4","modified":1573650247592},{"_id":"themes/next-reloaded/scripts/filters/comment/livere.js","hash":"76b2dc98b63180c2e082727fc71c4f576b3ff43d","modified":1573650247593},{"_id":"themes/next-reloaded/scripts/filters/comment/valine.js","hash":"5b7ecbaf1ea67aed4df38ba69a7bf5e67ec843c2","modified":1573650247593},{"_id":"themes/next-reloaded/source/css/_mixins/Gemini.styl","hash":"b58ed9dabc5be0090647d9a0afc43359e1e0e14c","modified":1573650247643},{"_id":"themes/next-reloaded/layout/_third-party/statistics/tencent-mta.swig","hash":"a2bfea40acc9e18d1cd73edc52df57278b746e81","modified":1573650247581},{"_id":"themes/next-reloaded/source/css/_mixins/Pisces.styl","hash":"1619130f81e091bb9ac43f93814f594dd1739255","modified":1573650247644},{"_id":"themes/next-reloaded/source/css/_variables/Gemini.styl","hash":"f6517f04ee9c8d93d1667c5617116f03ce1942a2","modified":1573650247656},{"_id":"themes/next-reloaded/layout/_third-party/statistics/lean-analytics.swig","hash":"6c007dd76f1cb8171681d7437ec1498ca1229466","modified":1573650247580},{"_id":"themes/next-reloaded/source/css/_variables/Pisces.styl","hash":"0bccf86c88e4d27b41f75bf166e66480c7bf919c","modified":1573650247658},{"_id":"themes/next-reloaded/source/css/_variables/Mist.styl","hash":"5832f04fab4e4224bca6dc31a3d94da034a20861","modified":1573650247656},{"_id":"themes/next-reloaded/source/css/_mixins/base.styl","hash":"a0e0628fc958dfe794e2c073301f7c2ba00e20f1","modified":1573650247645},{"_id":"themes/next-reloaded/layout/_third-party/statistics/tencent-analytics.swig","hash":"c7b55198361ffd96b921b37ca90f6adfccf0d391","modified":1573650247580},{"_id":"themes/next-reloaded/source/css/_variables/Muse.styl","hash":"1ff4303ad83f96b152be571d4df07969199d5930","modified":1573650247657},{"_id":"themes/next-reloaded/source/lib/canvas-nest/README.md","hash":"6cb4993cbe75298f9b6a8738cb210f06489df840","modified":1573661660585},{"_id":"themes/next-reloaded/source/lib/canvas-nest/canvas-nest-nomobile.min.js","hash":"6b4437a9cd8aa04329cc6220a595acfe1fb9b598","modified":1573661660586},{"_id":"themes/next-reloaded/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1573661660586},{"_id":"themes/next-reloaded/source/lib/font-awesome/.bower.json","hash":"b4aefc910578d76b267e86dfffdd5121c8db9aec","modified":1573650247674},{"_id":"themes/next-reloaded/source/lib/canvas-nest/LICENSE","hash":"336611e76f0638d3d8aeca6b1b97138d2a07523f","modified":1573661660584},{"_id":"themes/next-reloaded/source/lib/font-awesome/.gitignore","hash":"03ddbf76c1dd1afb93eed0b670d2eee747472ef1","modified":1573650247674},{"_id":"themes/next-reloaded/source/lib/font-awesome/HELP-US-OUT.txt","hash":"ee33b2798b1e714b904d663436c6b3521011d1fa","modified":1573650247675},{"_id":"themes/next-reloaded/source/lib/font-awesome/bower.json","hash":"71e7183634dc1b9449f590f15ebd7201add22ca7","modified":1573650247676},{"_id":"themes/next-reloaded/source/lib/velocity/velocity.min.js","hash":"bf172816a9c57f9040e3d19c24e181a142daf92b","modified":1573650247683},{"_id":"themes/next-reloaded/source/lib/font-awesome/.npmignore","hash":"c31ff06a740955e44edd4403902e653ccabfd4db","modified":1573650247675},{"_id":"themes/next-reloaded/source/lib/velocity/velocity.ui.min.js","hash":"dde584994ac13dc601836e86f4cf490e418d9723","modified":1573650247684},{"_id":"themes/next-reloaded/source/js/schemes/muse.js","hash":"a8aea6d062c2859b503ea1bb8b7c9ce364ed9100","modified":1573650247671},{"_id":"themes/next-reloaded/source/js/schemes/pisces.js","hash":"8138e7d3e98a59a8a23daa98deac4c0024838b09","modified":1573650247671},{"_id":"themes/next-reloaded/source/css/_variables/base.styl","hash":"fc48141e45c9c1275013cdd5d552e4867ae92810","modified":1573650247658},{"_id":"themes/next-reloaded/source/css/_common/components/back-to-top.styl","hash":"bf86c81c57db3ed8fbb67df44fc2c0a79cd6ffd6","modified":1573650247605},{"_id":"themes/next-reloaded/source/css/_common/components/back-to-top-sidebar.styl","hash":"672866ede12bc2dd0835858f2697703fbc9dacb2","modified":1573650247605},{"_id":"themes/next-reloaded/source/css/_common/components/rainbow.styl","hash":"fbcffb91e7f1ca3cde988353e36e4bf75770a8e8","modified":1573650247615},{"_id":"themes/next-reloaded/source/css/_common/components/components.styl","hash":"daf188e77bd9d9fcff74c5659e875ebdd2010f08","modified":1573650247606},{"_id":"themes/next-reloaded/source/css/_common/components/reading-progress.styl","hash":"4052c6c598a9dc443ffac171cc6cb31e981c5e5d","modified":1573650247615},{"_id":"themes/next-reloaded/source/css/_common/scaffolding/buttons.styl","hash":"5c27faaaf5a201d1c41c08ad5bfe1757a894fd69","modified":1573650247632},{"_id":"themes/next-reloaded/source/css/_common/scaffolding/base.styl","hash":"1efa25a0efc072a65735c3c7d19267ce958afbbe","modified":1573650247632},{"_id":"themes/next-reloaded/source/css/_common/scaffolding/comments.styl","hash":"5772ee6cdc50a9e1a4425d79114d46065babe217","modified":1573650247633},{"_id":"themes/next-reloaded/source/css/_common/scaffolding/pagination.styl","hash":"b619f39e18398422e0ac4999d8f042a5eaebe9cd","modified":1573650247636},{"_id":"themes/next-reloaded/source/css/_common/scaffolding/tables.styl","hash":"77015610da04ec0214d14e65effd0d87f3ff9dec","modified":1573650247638},{"_id":"themes/next-reloaded/source/css/_common/scaffolding/scaffolding.styl","hash":"43045d115f8fe95732c446aa45bf1c97609ff2a5","modified":1573650247637},{"_id":"themes/next-reloaded/source/css/_common/scaffolding/normalize.styl","hash":"6d740699fb6a7640647a8fd77c4ea4992d8d6437","modified":1573650247635},{"_id":"themes/next-reloaded/source/css/_common/scaffolding/toggles.styl","hash":"20e0e3e3eba384930c022e21511214d244b4c9e7","modified":1573650247642},{"_id":"themes/next-reloaded/source/css/_schemes/Gemini/index.styl","hash":"404ecb2e51eb85020eee2405372cc4c4946106ad","modified":1573650247645},{"_id":"themes/next-reloaded/source/css/_common/outline/mobile.styl","hash":"78406dfb644b0e516f697aead3ed5d545c5b8144","modified":1573650247625},{"_id":"themes/next-reloaded/source/css/_schemes/Mist/_header.styl","hash":"f03bde9f5804b14f6b297e22a4f0de9a25b38914","modified":1573650247646},{"_id":"themes/next-reloaded/source/css/_common/outline/outline.styl","hash":"ca1da6314c123f1bf0a95feefb073f08bb8c256a","modified":1573650247625},{"_id":"themes/next-reloaded/source/css/_schemes/Mist/_layout.styl","hash":"5ae9f601b4c85afe33c5fe338b371b507d6f351c","modified":1573650247646},{"_id":"themes/next-reloaded/source/css/_schemes/Mist/_posts-expand.styl","hash":"7199707befa5469f2a3fb18ca49c2e0ff2c62ee0","modified":1573650247647},{"_id":"themes/next-reloaded/source/css/_schemes/Mist/index.styl","hash":"c5142739e01e9f25c8b32b2209af85c787bb2b42","modified":1573650247648},{"_id":"themes/next-reloaded/source/css/_schemes/Mist/_menu.styl","hash":"68f4854a327a51c2092c6d605ed195dfaf413823","modified":1573650247647},{"_id":"themes/next-reloaded/source/css/_schemes/Pisces/_menu.styl","hash":"0f4f40e93a0127feadb0bedbe3f8e069a288fae0","modified":1573650247653},{"_id":"themes/next-reloaded/source/css/_schemes/Pisces/_layout.styl","hash":"d7a59c099ba678e13e55163b6675776c7266aebe","modified":1573650247652},{"_id":"themes/next-reloaded/source/css/_schemes/Pisces/index.styl","hash":"25c2a7930da14f023329df20f38df2728057fb4d","modified":1573650247655},{"_id":"themes/next-reloaded/source/css/_schemes/Pisces/_header.styl","hash":"55a1e7deda42cb3318d1e19b904c9c91891659f3","modified":1573650247652},{"_id":"themes/next-reloaded/source/css/_schemes/Pisces/_sub-menu.styl","hash":"111766f2494ae2b7d6f432c9eb3bda4793e47f9a","modified":1573650247654},{"_id":"themes/next-reloaded/source/css/_schemes/Pisces/_sidebar.styl","hash":"1ae5f3b48300457940102f2201fba7b8547ace4b","modified":1573650247654},{"_id":"themes/next-reloaded/source/css/_schemes/Muse/_layout.styl","hash":"49c76bc723d3952abb613d9d68398ed7305da999","modified":1573650247649},{"_id":"themes/next-reloaded/source/css/_schemes/Muse/_sub-menu.styl","hash":"2d3e05015796a790abd9d68957a5c698c0c9f9b6","modified":1573650247650},{"_id":"themes/next-reloaded/source/css/_schemes/Muse/_menu.styl","hash":"3923dccd95e404c6c8d4578306551d40f230c62d","modified":1573650247650},{"_id":"themes/next-reloaded/source/css/_schemes/Muse/_sidebar.styl","hash":"4dc216cb9f1c12bf7720012fd24e126ef6a4eca7","modified":1573650247650},{"_id":"themes/next-reloaded/source/css/_schemes/Muse/_header.styl","hash":"9a7d7502ce394ddeba1773f90bbe19016b0cf0f6","modified":1573650247649},{"_id":"themes/next-reloaded/source/css/_schemes/Muse/index.styl","hash":"25c2a7930da14f023329df20f38df2728057fb4d","modified":1573650247651},{"_id":"themes/next-reloaded/source/lib/canvas-nest/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1573661660561},{"_id":"themes/next-reloaded/source/lib/canvas-nest/.git/index","hash":"6e1af4499be1d8e937d4317de69400af5dd9afc8","modified":1573661660588},{"_id":"themes/next-reloaded/source/lib/canvas-nest/.git/config","hash":"78c4459d066ad795856608d603d780b53488073d","modified":1573661660572},{"_id":"themes/next-reloaded/source/lib/canvas-nest/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1573661657965},{"_id":"themes/next-reloaded/source/lib/canvas-nest/.github/stale.yml","hash":"dbd5e6bf89b76ad1f2b081578b239c7ae32755af","modified":1573661660583},{"_id":"themes/next-reloaded/source/lib/canvas-nest/.git/packed-refs","hash":"fd1b6267c89ab359510f522c46fd70bfd88f9668","modified":1573661660553},{"_id":"themes/next-reloaded/source/lib/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1573650247677},{"_id":"themes/next-reloaded/source/lib/font-awesome/css/font-awesome.css","hash":"3655f1fdf1e584c4d8e8d39026093ca306a5a341","modified":1573650247677},{"_id":"themes/next-reloaded/source/lib/font-awesome/css/font-awesome.min.css","hash":"88af80502c44cd52ca81ffe7dc7276b7eccb06cf","modified":1573650247678},{"_id":"themes/next-reloaded/source/css/_common/components/pages/schedule.styl","hash":"686c780e6a483a2e494d9aab682803666ef63b3b","modified":1573650247608},{"_id":"themes/next-reloaded/source/css/_common/components/pages/pages.styl","hash":"6cf78a379bb656cc0abb4ab80fcae60152ce41ad","modified":1573650247608},{"_id":"themes/next-reloaded/source/css/_common/components/pages/categories.styl","hash":"18edddb2ffb3f85a68e4367f81e06c461e07bc25","modified":1573650247607},{"_id":"themes/next-reloaded/source/css/_common/components/pages/breadcrumb.styl","hash":"236a039b0900f4267de566b46f62314ad967d30f","modified":1573650247607},{"_id":"themes/next-reloaded/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1573650247681},{"_id":"themes/next-reloaded/source/css/_common/components/pages/tag-cloud.styl","hash":"a22c639cdf1073c9d060af62233125991ddf4dd5","modified":1573650247609},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-copyright.styl","hash":"37701d40233a587401bcfc5ede056d8d1a8ba006","modified":1573650247610},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-gallery.styl","hash":"616b11ef7a87751b164ad6d55923833ea475c988","modified":1573650247611},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-collapse.styl","hash":"49bebe05a149f9fffba8d7d004a617e8a6e5e660","modified":1573650247609},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-expand.styl","hash":"a5ef170128ab8bc9c0336d6d8d082a97f677563e","modified":1573650247611},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-header.styl","hash":"4af60e5cfc8161e93b27090400ff74b8e2f84eea","modified":1573650247612},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-eof.styl","hash":"724ca213d15ae27158c2cddf9c26d3dba3582283","modified":1573650247610},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-reward.styl","hash":"f0a5b3b7f9f18d37595eafb1809312d4b7965c58","modified":1573650247613},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-nav.styl","hash":"bb1cdbe39d9948474f80d0915ac9cf9cf63fbe7f","modified":1573650247612},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-rtl.styl","hash":"09dda2667628d1f91b2e37d8fc6df1413f961b64","modified":1573650247613},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-tags.styl","hash":"5cc9e7394c927065c688cba5edd6e0a27587f1d8","modified":1573650247613},{"_id":"themes/next-reloaded/source/css/_common/components/third-party/math.styl","hash":"6880467b4f6d7b057fb8291aa10966429a0a3bff","modified":1573650247617},{"_id":"themes/next-reloaded/source/css/_common/components/post/post.styl","hash":"c5ecffcb9b22308f2049a2ff46f8f57067148ba4","modified":1573650247614},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-widgets.styl","hash":"b266d2ce5e2b117be01537889e839a69004dc0bb","modified":1573650247614},{"_id":"themes/next-reloaded/source/css/_common/components/third-party/gitalk.styl","hash":"b87f4a06c0db893df4f756f24be182e1a4751f24","modified":1573650247616},{"_id":"themes/next-reloaded/source/css/_common/components/third-party/related-posts.styl","hash":"8ed7a9d5dfac592de703421b543978095129aa5b","modified":1573650247617},{"_id":"themes/next-reloaded/source/css/_common/components/third-party/third-party.styl","hash":"1f6b0d3ab227697ca115e57fd61122ea7950e19d","modified":1573650247618},{"_id":"themes/next-reloaded/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"0bf030b71cc75d7d2c0517c9f2ed61d1dba7722d","modified":1573650247633},{"_id":"themes/next-reloaded/source/css/_common/components/third-party/search.styl","hash":"089e9e3ec17e68a7cfec5ae065e958eb40dbf71e","modified":1573650247618},{"_id":"themes/next-reloaded/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1573650247682},{"_id":"themes/next-reloaded/source/css/_common/scaffolding/highlight/highlight.styl","hash":"d7a4bb39b50be363afaf143be05e8bc1f409c86e","modified":1573650247634},{"_id":"themes/next-reloaded/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"8c318a485c56dbdcdb22fd00781484ecc151bf8a","modified":1573650247639},{"_id":"themes/next-reloaded/source/css/_common/scaffolding/highlight/diff.styl","hash":"83bd737f663a8461e66985af8ddbfc0a731fc939","modified":1573650247634},{"_id":"themes/next-reloaded/source/css/_common/scaffolding/highlight/theme.styl","hash":"c911045b2ce9a66e38d9dd30c7ed078abbc10cbf","modified":1573650247635},{"_id":"themes/next-reloaded/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"4727e2721029acc7f70ea6a0f2775d6aa289edaf","modified":1573650247639},{"_id":"themes/next-reloaded/source/css/_common/scaffolding/tags/label.styl","hash":"77d4f332cf805aa7d294346c99e2d72afe2e82a4","modified":1573650247640},{"_id":"themes/next-reloaded/source/css/_common/scaffolding/tags/tabs.styl","hash":"1bb94cf2d8d3dbb4e2cb1d617df0137046fe90fc","modified":1573650247641},{"_id":"themes/next-reloaded/source/css/_common/scaffolding/tags/pdf.styl","hash":"c9337e837f10c5f40c27a0c0a012f39dfadc7572","modified":1573650247641},{"_id":"themes/next-reloaded/source/css/_common/scaffolding/tags/note.styl","hash":"4ef9d8d3e4a00d622f0dd22418a0848eed9dcc17","modified":1573650247640},{"_id":"themes/next-reloaded/source/css/_common/scaffolding/tags/tags.styl","hash":"51d46fa3c7c6b691c61a2c2b0ac005c97cfbf72b","modified":1573650247642},{"_id":"themes/next-reloaded/source/css/_common/outline/header/bookmark.styl","hash":"f7977cfacaca9db6fab4d154486ad57ec4b0fde9","modified":1573650247620},{"_id":"themes/next-reloaded/source/css/_common/outline/header/github-banner.styl","hash":"0bd0f4a28b3362898f4d9061b307b12bd128f6b0","modified":1573650247621},{"_id":"themes/next-reloaded/source/css/_common/outline/header/header.styl","hash":"459a39c54e4a16db287f390160fc06a829d64160","modified":1573650247622},{"_id":"themes/next-reloaded/source/css/_common/outline/footer/footer.styl","hash":"d38a6b55ceea75016e73908ce9e223f9147e123c","modified":1573650247619},{"_id":"themes/next-reloaded/source/css/_common/outline/header/headerband.styl","hash":"6d5f26646e2914474f295de8bf6dc327d4acd529","modified":1573650247623},{"_id":"themes/next-reloaded/source/css/_common/outline/header/site-meta.styl","hash":"3e6287e2241eac9a4090b452cd270c37dc240ed2","modified":1573650247624},{"_id":"themes/next-reloaded/source/css/_common/outline/header/site-nav.styl","hash":"19677978a4b2b0712d20fee15e952a78e7ba6365","modified":1573650247624},{"_id":"themes/next-reloaded/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"49722d555a2edb18094bb2cb3d7336dd72051b93","modified":1573650247626},{"_id":"themes/next-reloaded/source/css/_common/outline/header/menu.styl","hash":"de55bc28b9ecbc5fb66a177c2db735223e04e54c","modified":1573650247623},{"_id":"themes/next-reloaded/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"bfbb2b8dfceb79c5adcc31338f9cc8efdd3c1bc6","modified":1573650247627},{"_id":"themes/next-reloaded/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"00b2055f170e54267321d27118e0a7f07d10890b","modified":1573650247628},{"_id":"themes/next-reloaded/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"400c180753d3517a7332108d83ea7f2e7acbceca","modified":1573650247628},{"_id":"themes/next-reloaded/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"098b4bdf49c7300490f959386d5d1185a32543f6","modified":1573650247630},{"_id":"themes/next-reloaded/source/css/_common/outline/sidebar/site-state.styl","hash":"a782cd5ceee062fdfb91a9732017d19672973784","modified":1573650247631},{"_id":"themes/next-reloaded/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"12f7eaf6b56624cbc411528562d6bb848ff97039","modified":1573650247628},{"_id":"themes/next-reloaded/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"7406d2b31b9d329043160191c98232e5aeebbc2c","modified":1573650247629},{"_id":"themes/next-reloaded/source/lib/canvas-nest/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1573661657971},{"_id":"themes/next-reloaded/source/css/_common/outline/sidebar/sidebar.styl","hash":"f6f6306a3975c1544688b95a139af8d9262499b4","modified":1573650247630},{"_id":"themes/next-reloaded/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"a78eb9f212f405378bd38582742581d26a57fe7f","modified":1573650247630},{"_id":"themes/next-reloaded/source/lib/canvas-nest/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1573661657967},{"_id":"themes/next-reloaded/source/lib/canvas-nest/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1573661657970},{"_id":"themes/next-reloaded/source/lib/canvas-nest/.git/hooks/fsmonitor-watchman.sample","hash":"f7c0aa40cb0d620ff0bca3efe3521ec79e5d7156","modified":1573661657969},{"_id":"themes/next-reloaded/source/lib/canvas-nest/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1573661657966},{"_id":"themes/next-reloaded/source/lib/canvas-nest/.git/hooks/pre-commit.sample","hash":"33729ad4ce51acda35094e581e4088f3167a0af8","modified":1573661657972},{"_id":"themes/next-reloaded/source/lib/canvas-nest/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1573661657974},{"_id":"themes/next-reloaded/source/lib/canvas-nest/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1573661657974},{"_id":"themes/next-reloaded/source/lib/canvas-nest/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1573661657975},{"_id":"themes/next-reloaded/source/lib/canvas-nest/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1573661657977},{"_id":"themes/next-reloaded/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1573650247680},{"_id":"themes/next-reloaded/source/lib/canvas-nest/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1573661657979},{"_id":"themes/next-reloaded/source/lib/canvas-nest/.git/logs/HEAD","hash":"61d90361b98d67fed101879266a4350006a2515e","modified":1573661660565},{"_id":"themes/next-reloaded/source/lib/canvas-nest/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1573661657978},{"_id":"themes/next-reloaded/source/lib/canvas-nest/.git/objects/44/6ddf9b6c0e5ade17ca5cb99f9b3a5300919c57","hash":"fb72799ff98445f72fda041337da4cf105d9dcba","modified":1573661660426},{"_id":"themes/next-reloaded/source/lib/canvas-nest/.git/objects/46/cad4f872aa93e813aed99547c4705322ca483f","hash":"b0465d3186e2d58a8a99c56c6e68aa2965a396d4","modified":1573661660329},{"_id":"themes/next-reloaded/source/lib/canvas-nest/.git/objects/0c/dada082d621dbfdd00f7020c33dc751129167f","hash":"b490c11cdefde6b331a7d4ddb055e34ad08459d8","modified":1573661660386},{"_id":"themes/next-reloaded/source/lib/canvas-nest/.git/objects/2a/f622a4d7df40a2708946e91d6d7a0df1dc468c","hash":"3da7207fb18d361b83c56f4e35f67e9e945abd82","modified":1573661660491},{"_id":"themes/next-reloaded/source/lib/canvas-nest/.git/objects/17/9eb5d6cd5f44ba3dd9e08b4ffcd83bb26db80a","hash":"03d593c92c9fad045d298f58afdbbcfbde923999","modified":1573661660380},{"_id":"themes/next-reloaded/source/lib/canvas-nest/.git/objects/2f/9eba51ec174b1e0c719d12cafa7c3c07140471","hash":"fc994d9d8b3b21ec7c941eea7e3862970e297e9b","modified":1573661660393},{"_id":"themes/next-reloaded/source/lib/canvas-nest/.git/objects/50/dd2a6539498a70226c81a587db486b47e839ff","hash":"3844b0c815d0b4b32c6312c751a826bf9dc2c945","modified":1573661660336},{"_id":"themes/next-reloaded/source/lib/canvas-nest/.git/objects/45/9262fe92f0115707bf8d8764f1886bc5e7c9e0","hash":"36040483f8af76775b7e4b6d87cec53729625399","modified":1573661660505},{"_id":"themes/next-reloaded/source/lib/canvas-nest/.git/objects/5a/69ce9c2e4a1a34f6063ae9a121af1555669c69","hash":"dad25cc0f450e2827b5676975f4a70636e3fd2c8","modified":1573661660406},{"_id":"themes/next-reloaded/source/lib/canvas-nest/.git/objects/5e/8ae972c99b04af7dd56dabfc485e8fdae5094d","hash":"791b3349c5696ccacae00bffbdbb8d88a03e61a9","modified":1573661660344},{"_id":"themes/next-reloaded/source/lib/canvas-nest/.git/objects/69/a20d65d83035fdb01734a8eabe3340f740a4cb","hash":"9e95b02d8e43ec92e06bee3f60dffb74e8e7b9fa","modified":1573661660400},{"_id":"themes/next-reloaded/source/lib/canvas-nest/.git/objects/69/39233ece53c9bdb9a1faf3271ed5768b034aad","hash":"5a770d418c1bb7b0f031f4d5416530002032fcf3","modified":1573661660420},{"_id":"themes/next-reloaded/source/lib/canvas-nest/.git/objects/51/7c5eb7dcc2cb9769efea2e7375ff6e04123150","hash":"ec53157077d47430f4729bf164999d18d370aeab","modified":1573661660455},{"_id":"themes/next-reloaded/source/lib/canvas-nest/.git/objects/75/de2b8fa62d52690de32c351c63ab6446104ed5","hash":"52d10122d633ce4895a0690c5955e1b356f5a391","modified":1573661660499},{"_id":"themes/next-reloaded/source/lib/canvas-nest/.git/objects/8c/150fefb741be4edee07810003c8a845113e209","hash":"067de29d5efa0a46cdc8f9f113820e5e09bfa50a","modified":1573661660527},{"_id":"themes/next-reloaded/source/lib/canvas-nest/.git/objects/86/1c9f4241fe0eb6af02ad770d5ce04c1f68972b","hash":"7005c3e36015a4af30d4b91bd5a849a7861a073e","modified":1573661660484},{"_id":"themes/next-reloaded/source/lib/canvas-nest/.git/objects/7b/c7e3186212b6f2e06d3370502565e2c6326890","hash":"379f3c6486f589fc9c1ab07d0382adacf4f655a2","modified":1573661660352},{"_id":"themes/next-reloaded/source/lib/canvas-nest/.git/objects/99/be66a33ab4ebc34f62f2880a0e0cc6d334d0f2","hash":"f2346fe8ddd7d7abf38f2946f3083d8150f502d2","modified":1573661660446},{"_id":"themes/next-reloaded/source/lib/canvas-nest/.git/objects/91/f99a0c53b26dd54f56b9e452c68f56b06f8f7e","hash":"3dca8a5629e66599b6e0f146aa32f1b7ce023d89","modified":1573661660478},{"_id":"themes/next-reloaded/source/lib/canvas-nest/.git/objects/98/67d1132e0e50bbb7df754a63358d70741df6d5","hash":"3cb710a1faee73c08036f5e2df7df3a7ce29e9dd","modified":1573661660359},{"_id":"themes/next-reloaded/source/lib/canvas-nest/.git/objects/90/f6477118d05f5f96ce0a63c6f18b7b2baea200","hash":"385f58e92981f27fa54eb52bf60424e87c70a9d8","modified":1573661660372},{"_id":"themes/next-reloaded/source/lib/canvas-nest/.git/objects/b1/bb278ca2e50dff1b343f9d5ca025272859432f","hash":"74f0afa72a30268d84613fb0d1d893bba866f01d","modified":1573661660471},{"_id":"themes/next-reloaded/source/lib/canvas-nest/.git/objects/ab/45cbef9bc70ceff60f1ed52f2a5c34f6ad5725","hash":"ee2fa8f3df0de9092a4fce015cefd76ea18f4cfd","modified":1573661660520},{"_id":"themes/next-reloaded/source/lib/canvas-nest/.git/objects/aa/da83ad9aa55faa2b34ede31b1d41e16966f80b","hash":"b304541ab95b7969a63ba2ec4f60f5391bd8bb44","modified":1573661660366},{"_id":"themes/next-reloaded/source/lib/canvas-nest/.git/objects/bb/5755c22b6c1b7461319624f0f000bc947882ee","hash":"2b87a2a354a0fa77cbddf461b03b0b8e43c16a4f","modified":1573661660433},{"_id":"themes/next-reloaded/source/lib/canvas-nest/.git/objects/ca/3466a8cbf05c2982c58199d6ee71ec6d0271ca","hash":"a9b80b5d827b5e84229b1afd7920d9218dce610f","modified":1573661660439},{"_id":"themes/next-reloaded/source/lib/canvas-nest/.git/objects/d1/b8c85241243a80f16d56e7a50244d3695f6e6e","hash":"baf56a83286c72af11667786dc59e7c58d30e427","modified":1573661660512},{"_id":"themes/next-reloaded/source/lib/canvas-nest/.git/objects/d4/95d28a8fab74d23908f6ccef9e4db2625fbacb","hash":"59e6067b0a806deee7bda6460b36c0f63e2e1db5","modified":1573661660463},{"_id":"themes/next-reloaded/source/lib/canvas-nest/.git/objects/d6/5de52977302632417c21e015956fb3dab8cabd","hash":"e0c8f0483b20434e63748a649ca4afbb417997f4","modified":1573661660414},{"_id":"themes/next-reloaded/source/lib/canvas-nest/.git/refs/heads/master","hash":"04088d44304ede9ff4c66a3725444cad71096e18","modified":1573661660565},{"_id":"themes/next-reloaded/source/lib/canvas-nest/.git/objects/e1/5c0793114874195462829db04d021face6640e","hash":"ff6c6d9f05b171ba67b44564ae3574d16eae6222","modified":1573661660321},{"_id":"themes/next-reloaded/source/lib/canvas-nest/.git/logs/refs/heads/master","hash":"61d90361b98d67fed101879266a4350006a2515e","modified":1573661660567},{"_id":"themes/next-reloaded/source/lib/canvas-nest/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1573661660559},{"_id":"themes/next-reloaded/source/lib/canvas-nest/.git/logs/refs/remotes/origin/HEAD","hash":"61d90361b98d67fed101879266a4350006a2515e","modified":1573661660559},{"_id":"public/baidusitemap.xml","hash":"fa339cc45702b4a4997f05db8503ff1a3f217a3c","modified":1573717235989},{"_id":"public/search.xml","hash":"bb9b8efc6787ed9b25a33e0e42ee4e3dbc272e75","modified":1573717236014},{"_id":"public/sitemap.xml","hash":"aefdf26b9330bd07849e5e6d73de3b96a423aab0","modified":1573717236015},{"_id":"public/categories/index.html","hash":"672f925bb3d630dbca58fea8159709b73c99649a","modified":1573717236061},{"_id":"public/tags/index.html","hash":"01edb4bdcff8852635edd61634bfa0ac80e91ff0","modified":1573717236061},{"_id":"public/2019-11-07-Clementine教程.html","hash":"33dc8b17c2d192ab110d4dc9f915b2e7460e0344","modified":1573717236061},{"_id":"public/2019-10-31-内嵌汇编.html","hash":"e6b34de62ee02f82943a1fc24a55e4214f83bbd6","modified":1573717236061},{"_id":"public/2019-10-14-数组中的主要元素.html","hash":"ef8948de52cac22cb0608ad031140e7c0bce5ff6","modified":1573717236061},{"_id":"public/2019-10-07-逆序对的计数.html","hash":"066d11dc898d87fb5a0a0b9fbc64bede3a7b642f","modified":1573717236061},{"_id":"public/2019-09-19-数组中的第K大的数.html","hash":"7fa5eb1afb0c71b62576a2e2c803e3be58fdf4df","modified":1573717236061},{"_id":"public/2019-09-08-OJ输入输出.html","hash":"230a01863bbf4532bd9bf101bec07911e916ec5d","modified":1573717236061},{"_id":"public/2019-09-08-实模式寻址方式.html","hash":"7465b9ae86f76c09db8ea10278281f3429f48cad","modified":1573717236062},{"_id":"public/2019-08-24-shadowsocks的部署.html","hash":"6d474fb82c1da5899ce7e9605903f84a0af96d65","modified":1573717236062},{"_id":"public/2019-04-26-Redis-Makefile注解.html","hash":"56977b8fabe2e67dec5aa3dad0e3a661212f8aae","modified":1573717236062},{"_id":"public/2019-04-25-GCC的编译选项.html","hash":"b4be756321b05b770967b21c7781424981618084","modified":1573717236062},{"_id":"public/2019-04-17-青蛙跳台阶问题.html","hash":"ba0299ad6a80b27ef74117d3730f302bb2f8332f","modified":1573717236062},{"_id":"public/2019-04-03-gdb-调试.html","hash":"fbe019a42d6e9ae50425a8b66ca67b302eb5e329","modified":1573717236062},{"_id":"public/2019-04-10-Linux-shell脚本计算运行时间.html","hash":"2a51e21ed5701f5d5f18b1414b58c8b41a3636bc","modified":1573717236062},{"_id":"public/2019-04-01-Docker-学习.html","hash":"b318646f786248f776dd5b348e29f80ea71b607a","modified":1573717236062},{"_id":"public/2019-03-31-计算Linux系统的CPU利用率.html","hash":"d2a941785c79efd4281d1dd6cb4bbb05e253690c","modified":1573717236062},{"_id":"public/2019-03-29-Redis设计与实现读书笔记——第8章-对象.html","hash":"e60a7f84b3dd222ca370e90b7979616cacc009f9","modified":1573717236062},{"_id":"public/2019-03-27-Redis-设计与实现读书笔记——第四章-字典.html","hash":"f9c5d9924dd7aaf1f42ee7a177678b8d204cdea2","modified":1573717236062},{"_id":"public/2019-03-27-剑指offer-读书笔记——第2章.html","hash":"ea5cae80602eb364a5a672734dd850b5f207e767","modified":1573717236062},{"_id":"public/2019-03-26-使用Travis-CI自动部署博客.html","hash":"6e1d19b00d42c82728e84b55de955e0aa967adf1","modified":1573717236062},{"_id":"public/Redis源码阅读——SDS/2019-03-22-Redis源码阅读——SDS.html","hash":"3ea6397d7351045084a30fd7cdc359947884dee5","modified":1573717236062},{"_id":"public/2019-03-20-Redis设计与实现读书笔记.html","hash":"ad7ef78be6a899664bd3a06cc2f86407dd327dfc","modified":1573717236062},{"_id":"public/ping 问题.html","hash":"2c74b9c33485c42a5d759024f9de7a0ae43b891c","modified":1573717236063},{"_id":"public/使用shell脚本遍历redis数据库中的所有kv对.html","hash":"c81680b6ecd73bb54f4d988fd7e723762c987d48","modified":1573717236063},{"_id":"public/使用YCSB 评测redis性能.html","hash":"049e6c3a1dc72419ad486105e77c9ae2d9526f03","modified":1573717236063},{"_id":"public/apt-get install 失败.html","hash":"fcee30af420be002383d2f63202767c3a64dc24d","modified":1573717236063},{"_id":"public/make学习.html","hash":"5eda28dfd4435fcab944023c38eaffbb25774599","modified":1573717236063},{"_id":"public/Linux 命令 学习.html","hash":"d7570443bea9f0e143293e2aceaf647bc361aa3f","modified":1573717236063},{"_id":"public/tee命令解析.html","hash":"6fdc94045cf66b22d30ed6255310adaf037ec6d6","modified":1573717236063},{"_id":"public/BigdataBench-deploy.html","hash":"298914d3b219c78843cd027e97994093b018a0db","modified":1573717236063},{"_id":"public/图计算常用算法.html","hash":"d2661af22f0b3b6ffd5bdf9a30c61e11ea73292e","modified":1573717236063},{"_id":"public/ceph部署文档.html","hash":"7d259e3925e3f1acd7b13c7b70feca1dfc193146","modified":1573717236063},{"_id":"public/archives/index.html","hash":"f0f812776c0d0895e7bcbd098971fb354e07ea54","modified":1573717236063},{"_id":"public/archives/page/2/index.html","hash":"3f05b694ce88cd01326beb82ff6e2fe9dfe81516","modified":1573717236063},{"_id":"public/archives/page/3/index.html","hash":"bc7bca383c00e177e3adea108ce90fa6f8cff15a","modified":1573717236063},{"_id":"public/archives/page/4/index.html","hash":"06b4d98491458dfeca51923004c80bf091a9694c","modified":1573717236063},{"_id":"public/archives/2018/index.html","hash":"5222c26a5521c5d32ae41b25244a40edf1e2143e","modified":1573717236063},{"_id":"public/archives/2018/04/index.html","hash":"d29a24c07c208d34634246624c51fd709e363f7c","modified":1573717236063},{"_id":"public/archives/2018/06/index.html","hash":"2b3553103ef2b6d59facb302c6ccb55d46edac28","modified":1573717236064},{"_id":"public/archives/2018/07/index.html","hash":"e792a536f01c0d76f9bc7adb3da5b0eb575258a1","modified":1573717236064},{"_id":"public/archives/2018/10/index.html","hash":"0ccb49acfb29a5d463faad5e9f8691540b617002","modified":1573717236064},{"_id":"public/archives/2019/index.html","hash":"9555f2b9296f98e4c0dd8f4371d847fbc6c9263d","modified":1573717236064},{"_id":"public/archives/2019/page/2/index.html","hash":"55c6373c33235ec52ed292846fb8bcbf813835ab","modified":1573717236064},{"_id":"public/archives/2019/page/3/index.html","hash":"94538b03e405cb167a21cc7c07ab4cc57905f2fb","modified":1573717236064},{"_id":"public/archives/2019/03/index.html","hash":"e2b4b6f45a6f710852165489c8ed5409eff8f315","modified":1573717236064},{"_id":"public/archives/2019/03/page/2/index.html","hash":"d81973aab64baa4dfa845e9e12463533e55b149c","modified":1573717236064},{"_id":"public/archives/2019/04/index.html","hash":"4828c6703f77f16d2ff6291efb21665cc91fbca4","modified":1573717236064},{"_id":"public/archives/2019/08/index.html","hash":"d6e47e7bf3c2a29af8a4e97b721dbb4b305b0d61","modified":1573717236064},{"_id":"public/archives/2019/09/index.html","hash":"13d70b22e6a113784703877b06068622dc0f7444","modified":1573717236064},{"_id":"public/archives/2019/10/index.html","hash":"f1b0a8cb4d462f8c2b5a9006636c88c8409cad8d","modified":1573717236064},{"_id":"public/archives/2019/11/index.html","hash":"0d33aaf75cca9890ee304331fc98bafe0e6f1163","modified":1573717236064},{"_id":"public/categories/Hexo/index.html","hash":"53bf966c49162af1ad863495abe9757af9f5a60e","modified":1573717236065},{"_id":"public/categories/读书笔记/index.html","hash":"4aae53f5c77848b9d33f05424ae4595a389898fc","modified":1573717236065},{"_id":"public/categories/Linux/index.html","hash":"f4111889006cb4d7e830e9d8c2dd06ac1d576094","modified":1573717236065},{"_id":"public/categories/题解/index.html","hash":"a1b7211ec037bbc0fe753ba09593755c3d372ae9","modified":1573717236065},{"_id":"public/categories/源码阅读/index.html","hash":"452fe6f4194cf745f8e0cdca0ada2fc33f033b34","modified":1573717236065},{"_id":"public/categories/计算机基础/index.html","hash":"9b8597f7141c4a4e504d61380ac67ca9d655ec71","modified":1573717236065},{"_id":"public/categories/deploy/index.html","hash":"ca8c6c051105654c5200207ac79dfe6220437eb9","modified":1573717236065},{"_id":"public/categories/编程语言/index.html","hash":"e9d9522a81cf4a129676d6d2f3fbd8d293aa900a","modified":1573717236065},{"_id":"public/categories/数据挖掘/index.html","hash":"dc6adb6c13b04cbefcfa0e754a8d95ab6154fdc8","modified":1573717236065},{"_id":"public/categories/algorithm/index.html","hash":"8e4fba26c4195fe69adeabb47ce207f3f618049a","modified":1573717236065},{"_id":"public/index.html","hash":"a0e494b472274003073fb705288d21f1f40dfaec","modified":1573717236065},{"_id":"public/page/2/index.html","hash":"742a3bee2501d3d43bd81dcef71cc474e1017dd5","modified":1573717236065},{"_id":"public/page/3/index.html","hash":"0630b608cfb23da9aa3f5459f2160dbd3deaf02e","modified":1573717236065},{"_id":"public/page/4/index.html","hash":"8ee0819321003266c2bee349d814650a515003cb","modified":1573717236065},{"_id":"public/tags/Hexo/index.html","hash":"27db752bd37213f6724ae3c01566215fe92af85a","modified":1573717236065},{"_id":"public/tags/Travis-CI/index.html","hash":"91468507f5964b7f77f94906e8e1728a7e82d58f","modified":1573717236065},{"_id":"public/tags/redis/index.html","hash":"3e7268d12f8f8048fc315a516d729f1bae6c73da","modified":1573717236065},{"_id":"public/tags/源码阅读/index.html","hash":"a91bde8c8dd88c534797579f4fe8eb3b39e6f8e9","modified":1573717236065},{"_id":"public/tags/dict/index.html","hash":"04624f35ed4b07db3d72bbb917a9eec8b18b9e93","modified":1573717236066},{"_id":"public/tags/Linux/index.html","hash":"4f1776cfc747aaa509912ee945e5f688de31749a","modified":1573717236066},{"_id":"public/tags/shell/index.html","hash":"b6b748264c3c6e69378d8208a60799ed0535763e","modified":1573717236066},{"_id":"public/tags/coding/index.html","hash":"3d35e3ffa3f6195e79de4b66156aaa216a930c9b","modified":1573717236066},{"_id":"public/tags/c/index.html","hash":"00e982f31f63459ef903dd02dc2d27c18371f62b","modified":1573717236066},{"_id":"public/tags/object/index.html","hash":"a40e089ab8b13e1818fd47549897c34aaefc0eff","modified":1573717236066},{"_id":"public/tags/gdb/index.html","hash":"d1a3224bd78fff8f060081de21c808fe6cd85196","modified":1573717236066},{"_id":"public/tags/工具/index.html","hash":"b5a9ddb9623b070a34543e03ede1e70fb26a6b73","modified":1573717236066},{"_id":"public/tags/docker/index.html","hash":"449714cdb9520a91608bb24bc44ec173b3c6d637","modified":1573717236066},{"_id":"public/tags/容器/index.html","hash":"f8c98d3ca5bd4999daa6eddb2f3b1813dcd651cb","modified":1573717236066},{"_id":"public/tags/牛客/index.html","hash":"bb25cb075efdeb83b46ee006d1efe140b4e449a7","modified":1573717236066},{"_id":"public/tags/斐波拉契数列/index.html","hash":"cc96ee1e16280dd070bf4e00ff6188e4d23de695","modified":1573717236066},{"_id":"public/tags/剑指offer/index.html","hash":"f1f54e9774fb1350d23b7c69c51458f0acf3ba34","modified":1573717236066},{"_id":"public/tags/OJ/index.html","hash":"14c7a857d23abce72ddeab5798fde756080b5c5d","modified":1573717236066},{"_id":"public/tags/编程/index.html","hash":"d314697bbcb1c4c7b9c54f25922e8ecc11487e46","modified":1573717236066},{"_id":"public/tags/gcc/index.html","hash":"d35310216fd3d22c97a24e6fd26df4c399742519","modified":1573717236066},{"_id":"public/tags/make/index.html","hash":"70bb05f4b630a9e8ec64b2023cca517ac9b078e6","modified":1573717236066},{"_id":"public/tags/Makefile/index.html","hash":"da3cab1b788114ba3884fc186413a6862e321a57","modified":1573717236066},{"_id":"public/tags/内存寻址/index.html","hash":"cac205bfa3b3a3dd6bc511e47d777b5bc7146818","modified":1573717236067},{"_id":"public/tags/寄存器/index.html","hash":"43a5f66324cd352edddb43845b0f515d3918936e","modified":1573717236067},{"_id":"public/tags/BIOS/index.html","hash":"242eae9218bf73b5eedbc04c1a0bd641ff2b650b","modified":1573717236067},{"_id":"public/tags/shadowsocks/index.html","hash":"b06e8d8aa1150b51867852ea56d7acce11550ff7","modified":1573717236067},{"_id":"public/tags/翻墙/index.html","hash":"0d8aa257944c3dcd0cdd56142a4e6b913ce526f9","modified":1573717236067},{"_id":"public/tags/ipv6/index.html","hash":"f2eb572e12ffe499cff85024e28dad3aac13698a","modified":1573717236067},{"_id":"public/tags/leetcode/index.html","hash":"d020fd20c923961371e77cb697c49bbe2330379d","modified":1573717236067},{"_id":"public/tags/归并排序/index.html","hash":"dd3ddf59ae42f94ea277d7c84406516c215a4c90","modified":1573717236067},{"_id":"public/tags/分治/index.html","hash":"42777c5fc9c237264320608d92259a2199a873c4","modified":1573717236067},{"_id":"public/tags/快排/index.html","hash":"0cac677393d291c672d3a5d33f4fdc0e4997be80","modified":1573717236067},{"_id":"public/tags/汇编/index.html","hash":"3c536ad2a4e9b053b3c3c5160616b3351a81510a","modified":1573717236067},{"_id":"public/tags/C语言/index.html","hash":"2bf08ab104b6a8ffa23baeb0944a40d51a5cc108","modified":1573717236067},{"_id":"public/tags/哈希/index.html","hash":"22658ba1cb2c95a1e335c5a7e651105336522082","modified":1573717236067},{"_id":"public/tags/摩尔投票/index.html","hash":"c98f9eff4ccb8dc15f755322127be3fd0d5e9d48","modified":1573717236067},{"_id":"public/tags/command/index.html","hash":"2146c058c2d0c289822a7c0a57aeefa12017b339","modified":1573717236067},{"_id":"public/tags/Clementine/index.html","hash":"9e74573edf96e9493c5336669e39a0e23fe59a6a","modified":1573717236067},{"_id":"public/tags/bigdatabench/index.html","hash":"8610680ae9829b679bed0fc112023b973b7d59a5","modified":1573717236067},{"_id":"public/tags/运维/index.html","hash":"47c22a47501354c8d15a92039cb82e92e38a7006","modified":1573717236067},{"_id":"public/tags/ceph/index.html","hash":"7a1a87dcc72c9470adaef72af5a87068b8aec700","modified":1573717236067},{"_id":"public/tags/网络问题/index.html","hash":"cc0576e250909cf40b69659b7b4893501fab15b3","modified":1573717236068},{"_id":"public/tags/benchmark/index.html","hash":"b11516c9ffb0b103fd8548ad1b54c62c9551b690","modified":1573717236068},{"_id":"public/tags/graph/index.html","hash":"66f56c74d5b3c1641272adcb5383d4246a451ee2","modified":1573717236073},{"_id":"public/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1573717236073},{"_id":"public/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1573717236073},{"_id":"public/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1573717236073},{"_id":"public/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1573717236073},{"_id":"public/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1573717236073},{"_id":"public/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1573717236073},{"_id":"public/robots.txt","hash":"bbfef6d0a1bee35d06457106003c6c0e399ea6e0","modified":1573717236073},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1573717236074},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1573717236074},{"_id":"public/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1573717236074},{"_id":"public/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1573717236074},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1573717236074},{"_id":"public/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1573717236074},{"_id":"public/images/favicon.png","hash":"9ad0834cb90e0a8ff8ee739e51d8109aceb7cf68","modified":1573717236074},{"_id":"public/images/favicon16x16.png","hash":"a63a2e0b78898ee887f4cced3e2b9559dc0dcc3f","modified":1573717236074},{"_id":"public/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1573717236074},{"_id":"public/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1573717236075},{"_id":"public/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1573717236075},{"_id":"public/lib/canvas-nest/LICENSE","hash":"336611e76f0638d3d8aeca6b1b97138d2a07523f","modified":1573717236075},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"ee33b2798b1e714b904d663436c6b3521011d1fa","modified":1573717236075},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1573717236075},{"_id":"public/BigdataBench-deploy/runcc.png","hash":"92edff3c535d6744e38fd0b933a5474d768b5ecc","modified":1573717236075},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1573717236539},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1573717236541},{"_id":"public/js/bookmark.js","hash":"c9acb262acf0cf127497b570fa9479fb32f34547","modified":1573717236550},{"_id":"public/js/motion.js","hash":"9ac69597315b5b7b4c8900b7949d2a31387d6284","modified":1573717236550},{"_id":"public/js/algolia-search.js","hash":"813afcc30feee11d59f297f2d5a96f98fbbd4743","modified":1573717236550},{"_id":"public/js/local-search.js","hash":"fda0f761ae20577f22c1528dde7ae059368fe9a8","modified":1573717236550},{"_id":"public/js/next-boot.js","hash":"f7045763e277e685c271bd4b4c37e531d699ac63","modified":1573717236550},{"_id":"public/js/utils.js","hash":"a2984bf0631756a904cd43f8e3a8f6fb15b9ceb5","modified":1573717236550},{"_id":"public/lib/canvas-nest/README.html","hash":"3f775753e74420ec8f5d090955140de882c24678","modified":1573717236551},{"_id":"public/lib/canvas-nest/canvas-nest-nomobile.min.js","hash":"956eada198babd00f028e8908767cb158926c3f3","modified":1573717236551},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1573717236551},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1573717236551},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1573717236551},{"_id":"public/js/schemes/muse.js","hash":"792f4522a3b0b96584a041a4aca20fcded410079","modified":1573717236551},{"_id":"public/js/schemes/pisces.js","hash":"dccbb1be3938050e13277251ab5d88c736edf396","modified":1573717236551},{"_id":"public/css/main.css","hash":"63efbb547439716e5f2909d0e894529af29524b2","modified":1573717236551},{"_id":"public/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1573717236551},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1573717236551},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1573717236551},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1573717236551},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1573717236551},{"_id":"themes/next-reloaded/source/lib/canvas-nest - 副本/LICENSE","hash":"336611e76f0638d3d8aeca6b1b97138d2a07523f","modified":1573719520817},{"_id":"themes/next-reloaded/source/lib/canvas-nest - 副本/README.md","hash":"6cb4993cbe75298f9b6a8738cb210f06489df840","modified":1573719520818},{"_id":"themes/next-reloaded/source/lib/canvas-nest - 副本/canvas-nest-nomobile.min.js","hash":"6b4437a9cd8aa04329cc6220a595acfe1fb9b598","modified":1573719520819},{"_id":"themes/next-reloaded/source/lib/canvas-nest - 副本/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1573719520820},{"_id":"themes/next-reloaded/source/lib/canvas-nest - 副本/.github/stale.yml","hash":"dbd5e6bf89b76ad1f2b081578b239c7ae32755af","modified":1573719520817},{"_id":"public/lib/canvas-nest - 副本/LICENSE","hash":"336611e76f0638d3d8aeca6b1b97138d2a07523f","modified":1573720761009},{"_id":"public/lib/canvas-nest - 副本/README.html","hash":"3f775753e74420ec8f5d090955140de882c24678","modified":1573720761014},{"_id":"public/lib/canvas-nest - 副本/canvas-nest-nomobile.min.js","hash":"956eada198babd00f028e8908767cb158926c3f3","modified":1573720761014},{"_id":"public/lib/canvas-nest - 副本/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1573720761014}],"Category":[{"name":"Hexo","_id":"ck2yelxgw0004m8tzgck557ju"},{"name":"读书笔记","_id":"ck2yelxh10009m8tz9jkml368"},{"name":"Linux","_id":"ck2yelxha000lm8tzagoiunz1"},{"name":"题解","_id":"ck2yelxhp001fm8tza7cgnbct"},{"name":"源码阅读","_id":"ck2yelxhw001sm8tz1aatnytb"},{"name":"计算机基础","_id":"ck2yelxi00020m8tz5q8pbsb6"},{"name":"deploy","_id":"ck2yelxi30027m8tzub9f32zi"},{"name":"编程语言","_id":"ck2yelxia002om8tzqj563jiv"},{"name":"数据挖掘","_id":"ck2yelxid002wm8tzey2x9bjy"},{"name":"algorithm","_id":"ck2yelxih003am8tz3poqvixe"}],"Data":[],"Page":[{"title":"categories","date":"2019-03-10T12:10:41.000Z","type":"categories","_content":"\n","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2019-03-10 20:10:41\ntype: \"categories\"\n---\n\n","updated":"2019-03-26T05:30:52.809Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ck2yelxgr0001m8tzy9knzaa4","content":"","site":{"data":{}},"length":0,"excerpt":"","more":""},{"title":"tags","date":"2019-03-10T12:15:52.000Z","type":"tags","_content":"\n","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2019-03-10 20:15:52\ntype: \"tags\"\n---\n\n","updated":"2019-03-26T05:30:52.810Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ck2yelxgu0003m8tzafy61j4t","content":"","site":{"data":{}},"length":0,"excerpt":"","more":""}],"Post":[{"title":"使用Travis-CI自动部署博客","date":"2019-03-26T01:52:01.000Z","copyright":true,"_content":"\n# 使用Travis-CI自动部署博客\n\n因为在github上面存储的是编译好的html代码，不是hexo博客中的博客源文件，所以如果没有备份源文件的话，丢失了源文件（包括md,一堆配置文件）后就不能继续更新博客了，而且也不能多端部署Hexo。网上看到可以使用Travis-CI来自动部署，同时解决了博客源文件的备份问题。\n\n<!--more-->\n\n## 新建hexo分支来保存源文件\n\n### 新建分支\n\n直接在对应的github.io项目上的branch 按钮处点击新建分支 hexo。\n\n官方文档<https://help.github.com/en/articles/setting-the-default-branch> \n\n```\n# 克隆项目到本地\n> git clone https://github.com/BraveY/BraveY.github.io.git\n```\n\n### 设置默认分支\n\n参照官方文档设置<https://help.github.com/en/articles/setting-the-default-branch>\n\n### 修改推送hexo分支\n\n现将原来的文件BraveY.github.io 修改为BraveY.github.io.bak 避免拷贝的时候出现文件夹重名，同时将原来的hexo 目录blog文件也修改为blog.bak\n\n直接克隆到 本地\n\n ```\n# 克隆项目到本地\n> git clone https://github.com/BraveY/BraveY.github.io.git\n ```\n\n这时拷贝的项目已经是hexo分支下面的，因为之前是设置了hexo分支作为默认分支的。\n\n将克隆的BraveY.github.io文件夹重命名为blog\n\n在克隆的文件夹里面删除除了.git的所有文件\n\n**注意** ：因为主题的next也是个git仓库，所以需要先把next目录下的.git删除\n\n然后先把theme/next 目录下的.git 给删除掉，不然的话next这个主题本来就是个git仓库，里面的个性化配置是无法上传到自己的项目中的，而且以后也无法克隆。\n\n从blog.bak文件中把所有hexo的源码文件拷过来。\n\n在博客目录下初始化git仓库并将所有文件提交。\n\n添加到远程仓库\n\n```\ngit add . \ngit commit -m\"description\"\ngit push origin \n```\n\n现在hexo分支已经是存放了hexo的源文件了。\n\n## 设置Travis CI\n\n主要参考下面的三个博客，\n\n### Travis CI 官网登陆\n\n使用github账号登陆[Travis CI官网](https://travis-ci.org/)  ，选择博客项目启动。然后进行设置。\n\n没有文章中说的`Build only if .travis.yml is present` 选项，但好像没有影响，采用默认的选项。\n\n### github生成Access Token\n\n参考博客，不赘述。\n\n## Travis CI \n\n### 配置travis.yml\n\n在blog根目录下设置travis配置文件。\n\n.travis.yml 文件的配置为：\n\n```yaml\nlanguage: node_js # 设置语言\nnode_js: stable # 设置相应版本\ncache:\n  apt: true\n  directories:\n  - node_modules  # 缓存不经常更改的内容\nbefore_install:\n- export TZ='Asia/Shanghai' # 更改时区\ninstall:\n- npm install\nscript:\n- hexo clean\n- hexo g \nafter_script:\n- git clone https://${GH_REF} .deploy_git\n- cd .deploy_git\n- git checkout master\n- cd ../\n- mv .deploy_git/.git/ ./public/\n- cd ./public\n- git config user.name \"BraveY\"\n- git config user.email \"lsz_yky@163.com\"\n- git add .\n- git commit -m \"Travis CI Auto Builder at `date +\"%Y-%m-%d %H:%M\"`\"\n- git push --force --quiet \"https://${github_blog@${GH_REF}\" master:master\nbranches:\n  only:\n  - hexo\nenv:\n  global:\n  - GH_REF: github.com/BraveY/BraveY.github.io.git\nnotifications:\n  email:\n  - lsz_yky@163.com\n  on_success: change\n  on_failure: always\n```\n\n### 新增文章到_posts \n\n增减文章后，使用git push 命令即可，自动部署。\n\n可以看到 Travis CI 上面构建的一系列输出，但是博客并没有更新，而且github上的master分支也没有更改过。查看Travis CI 上的输出信息，发现在执行\n\n`git push --force --quiet \"https://${github_blog@${GH_REF}\" master:master` 这句后报错：\n\n```\n/home/travis/.travis/functions: eval: line 104: unexpected EOF while looking for matching `\"'\n/home/travis/.travis/functions: eval: line 105: syntax error: unexpected end of file\n```\n\n然后发现`${github_blog@${GH_REF}` 这句花括号没有对齐匹配，无语。加上漏掉的右边花括号} 重新执行操作。一切正常。\n\n## 博客更新操作\n\n后面就不用自己`hexo g -d ` 了\n\n在_posts目录下增加文章后\n\n```\ngit add .\ngit commit -m\"\"\ngit push origin\n```\n\n感觉可以写个脚本\n\n命名为git_script.ps1  以后直接用powershell运行这个脚本就可以了。\n\n```\ngit add .\n$date = get-date -uformat \"%Y-%m-%d %H:%M:%S\"\ngit commit -m\"new post $date\"\ngit push origin\n```\n\n\n\n## 参考\n\n<https://www.itfanr.cc/2017/08/09/using-travis-ci-automatic-deploy-hexo-blogs/>\n\n<http://www.dxjia.cn/2016/01/27/hexo-write-everywhere/>\n\n<http://www.yanglangjing.com/2018/08/28/travis_ci_auto_deploy_hexo_to_vps/>\n\n","source":"_posts/2019-03-26-使用Travis-CI自动部署博客.md","raw":"---\ntitle: 使用Travis-CI自动部署博客\ndate: 2019-03-26 09:52:01\ncategories: Hexo\ntags:\n- Hexo \n- Travis-CI\ncopyright: true\n---\n\n# 使用Travis-CI自动部署博客\n\n因为在github上面存储的是编译好的html代码，不是hexo博客中的博客源文件，所以如果没有备份源文件的话，丢失了源文件（包括md,一堆配置文件）后就不能继续更新博客了，而且也不能多端部署Hexo。网上看到可以使用Travis-CI来自动部署，同时解决了博客源文件的备份问题。\n\n<!--more-->\n\n## 新建hexo分支来保存源文件\n\n### 新建分支\n\n直接在对应的github.io项目上的branch 按钮处点击新建分支 hexo。\n\n官方文档<https://help.github.com/en/articles/setting-the-default-branch> \n\n```\n# 克隆项目到本地\n> git clone https://github.com/BraveY/BraveY.github.io.git\n```\n\n### 设置默认分支\n\n参照官方文档设置<https://help.github.com/en/articles/setting-the-default-branch>\n\n### 修改推送hexo分支\n\n现将原来的文件BraveY.github.io 修改为BraveY.github.io.bak 避免拷贝的时候出现文件夹重名，同时将原来的hexo 目录blog文件也修改为blog.bak\n\n直接克隆到 本地\n\n ```\n# 克隆项目到本地\n> git clone https://github.com/BraveY/BraveY.github.io.git\n ```\n\n这时拷贝的项目已经是hexo分支下面的，因为之前是设置了hexo分支作为默认分支的。\n\n将克隆的BraveY.github.io文件夹重命名为blog\n\n在克隆的文件夹里面删除除了.git的所有文件\n\n**注意** ：因为主题的next也是个git仓库，所以需要先把next目录下的.git删除\n\n然后先把theme/next 目录下的.git 给删除掉，不然的话next这个主题本来就是个git仓库，里面的个性化配置是无法上传到自己的项目中的，而且以后也无法克隆。\n\n从blog.bak文件中把所有hexo的源码文件拷过来。\n\n在博客目录下初始化git仓库并将所有文件提交。\n\n添加到远程仓库\n\n```\ngit add . \ngit commit -m\"description\"\ngit push origin \n```\n\n现在hexo分支已经是存放了hexo的源文件了。\n\n## 设置Travis CI\n\n主要参考下面的三个博客，\n\n### Travis CI 官网登陆\n\n使用github账号登陆[Travis CI官网](https://travis-ci.org/)  ，选择博客项目启动。然后进行设置。\n\n没有文章中说的`Build only if .travis.yml is present` 选项，但好像没有影响，采用默认的选项。\n\n### github生成Access Token\n\n参考博客，不赘述。\n\n## Travis CI \n\n### 配置travis.yml\n\n在blog根目录下设置travis配置文件。\n\n.travis.yml 文件的配置为：\n\n```yaml\nlanguage: node_js # 设置语言\nnode_js: stable # 设置相应版本\ncache:\n  apt: true\n  directories:\n  - node_modules  # 缓存不经常更改的内容\nbefore_install:\n- export TZ='Asia/Shanghai' # 更改时区\ninstall:\n- npm install\nscript:\n- hexo clean\n- hexo g \nafter_script:\n- git clone https://${GH_REF} .deploy_git\n- cd .deploy_git\n- git checkout master\n- cd ../\n- mv .deploy_git/.git/ ./public/\n- cd ./public\n- git config user.name \"BraveY\"\n- git config user.email \"lsz_yky@163.com\"\n- git add .\n- git commit -m \"Travis CI Auto Builder at `date +\"%Y-%m-%d %H:%M\"`\"\n- git push --force --quiet \"https://${github_blog@${GH_REF}\" master:master\nbranches:\n  only:\n  - hexo\nenv:\n  global:\n  - GH_REF: github.com/BraveY/BraveY.github.io.git\nnotifications:\n  email:\n  - lsz_yky@163.com\n  on_success: change\n  on_failure: always\n```\n\n### 新增文章到_posts \n\n增减文章后，使用git push 命令即可，自动部署。\n\n可以看到 Travis CI 上面构建的一系列输出，但是博客并没有更新，而且github上的master分支也没有更改过。查看Travis CI 上的输出信息，发现在执行\n\n`git push --force --quiet \"https://${github_blog@${GH_REF}\" master:master` 这句后报错：\n\n```\n/home/travis/.travis/functions: eval: line 104: unexpected EOF while looking for matching `\"'\n/home/travis/.travis/functions: eval: line 105: syntax error: unexpected end of file\n```\n\n然后发现`${github_blog@${GH_REF}` 这句花括号没有对齐匹配，无语。加上漏掉的右边花括号} 重新执行操作。一切正常。\n\n## 博客更新操作\n\n后面就不用自己`hexo g -d ` 了\n\n在_posts目录下增加文章后\n\n```\ngit add .\ngit commit -m\"\"\ngit push origin\n```\n\n感觉可以写个脚本\n\n命名为git_script.ps1  以后直接用powershell运行这个脚本就可以了。\n\n```\ngit add .\n$date = get-date -uformat \"%Y-%m-%d %H:%M:%S\"\ngit commit -m\"new post $date\"\ngit push origin\n```\n\n\n\n## 参考\n\n<https://www.itfanr.cc/2017/08/09/using-travis-ci-automatic-deploy-hexo-blogs/>\n\n<http://www.dxjia.cn/2016/01/27/hexo-write-everywhere/>\n\n<http://www.yanglangjing.com/2018/08/28/travis_ci_auto_deploy_hexo_to_vps/>\n\n","slug":"2019-03-26-使用Travis-CI自动部署博客","published":1,"updated":"2019-11-08T13:15:29.554Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2yelxgn0000m8tzj4bx8zls","content":"<h1 id=\"使用Travis-CI自动部署博客\"><a href=\"#使用Travis-CI自动部署博客\" class=\"headerlink\" title=\"使用Travis-CI自动部署博客\"></a>使用Travis-CI自动部署博客</h1><p>因为在github上面存储的是编译好的html代码，不是hexo博客中的博客源文件，所以如果没有备份源文件的话，丢失了源文件（包括md,一堆配置文件）后就不能继续更新博客了，而且也不能多端部署Hexo。网上看到可以使用Travis-CI来自动部署，同时解决了博客源文件的备份问题。</p>\n<a id=\"more\"></a>\n<h2 id=\"新建hexo分支来保存源文件\"><a href=\"#新建hexo分支来保存源文件\" class=\"headerlink\" title=\"新建hexo分支来保存源文件\"></a>新建hexo分支来保存源文件</h2><h3 id=\"新建分支\"><a href=\"#新建分支\" class=\"headerlink\" title=\"新建分支\"></a>新建分支</h3><p>直接在对应的github.io项目上的branch 按钮处点击新建分支 hexo。</p>\n<p>官方文档<a href=\"https://help.github.com/en/articles/setting-the-default-branch\" target=\"_blank\" rel=\"noopener\">https://help.github.com/en/articles/setting-the-default-branch</a> </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 克隆项目到本地</span><br><span class=\"line\">&gt; git clone https://github.com/BraveY/BraveY.github.io.git</span><br></pre></td></tr></table></figure>\n<h3 id=\"设置默认分支\"><a href=\"#设置默认分支\" class=\"headerlink\" title=\"设置默认分支\"></a>设置默认分支</h3><p>参照官方文档设置<a href=\"https://help.github.com/en/articles/setting-the-default-branch\" target=\"_blank\" rel=\"noopener\">https://help.github.com/en/articles/setting-the-default-branch</a></p>\n<h3 id=\"修改推送hexo分支\"><a href=\"#修改推送hexo分支\" class=\"headerlink\" title=\"修改推送hexo分支\"></a>修改推送hexo分支</h3><p>现将原来的文件BraveY.github.io 修改为BraveY.github.io.bak 避免拷贝的时候出现文件夹重名，同时将原来的hexo 目录blog文件也修改为blog.bak</p>\n<p>直接克隆到 本地</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 克隆项目到本地</span><br><span class=\"line\">&gt; git clone https://github.com/BraveY/BraveY.github.io.git</span><br></pre></td></tr></table></figure>\n<p>这时拷贝的项目已经是hexo分支下面的，因为之前是设置了hexo分支作为默认分支的。</p>\n<p>将克隆的BraveY.github.io文件夹重命名为blog</p>\n<p>在克隆的文件夹里面删除除了.git的所有文件</p>\n<p><strong>注意</strong> ：因为主题的next也是个git仓库，所以需要先把next目录下的.git删除</p>\n<p>然后先把theme/next 目录下的.git 给删除掉，不然的话next这个主题本来就是个git仓库，里面的个性化配置是无法上传到自己的项目中的，而且以后也无法克隆。</p>\n<p>从blog.bak文件中把所有hexo的源码文件拷过来。</p>\n<p>在博客目录下初始化git仓库并将所有文件提交。</p>\n<p>添加到远程仓库</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add . </span><br><span class=\"line\">git commit -m&quot;description&quot;</span><br><span class=\"line\">git push origin</span><br></pre></td></tr></table></figure>\n<p>现在hexo分支已经是存放了hexo的源文件了。</p>\n<h2 id=\"设置Travis-CI\"><a href=\"#设置Travis-CI\" class=\"headerlink\" title=\"设置Travis CI\"></a>设置Travis CI</h2><p>主要参考下面的三个博客，</p>\n<h3 id=\"Travis-CI-官网登陆\"><a href=\"#Travis-CI-官网登陆\" class=\"headerlink\" title=\"Travis CI 官网登陆\"></a>Travis CI 官网登陆</h3><p>使用github账号登陆<a href=\"https://travis-ci.org/\" target=\"_blank\" rel=\"noopener\">Travis CI官网</a>  ，选择博客项目启动。然后进行设置。</p>\n<p>没有文章中说的<code>Build only if .travis.yml is present</code> 选项，但好像没有影响，采用默认的选项。</p>\n<h3 id=\"github生成Access-Token\"><a href=\"#github生成Access-Token\" class=\"headerlink\" title=\"github生成Access Token\"></a>github生成Access Token</h3><p>参考博客，不赘述。</p>\n<h2 id=\"Travis-CI\"><a href=\"#Travis-CI\" class=\"headerlink\" title=\"Travis CI\"></a>Travis CI</h2><h3 id=\"配置travis-yml\"><a href=\"#配置travis-yml\" class=\"headerlink\" title=\"配置travis.yml\"></a>配置travis.yml</h3><p>在blog根目录下设置travis配置文件。</p>\n<p>.travis.yml 文件的配置为：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">language:</span> <span class=\"string\">node_js</span> <span class=\"comment\"># 设置语言</span></span><br><span class=\"line\"><span class=\"attr\">node_js:</span> <span class=\"string\">stable</span> <span class=\"comment\"># 设置相应版本</span></span><br><span class=\"line\"><span class=\"attr\">cache:</span></span><br><span class=\"line\"><span class=\"attr\">  apt:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">  directories:</span></span><br><span class=\"line\"><span class=\"bullet\">  -</span> <span class=\"string\">node_modules</span>  <span class=\"comment\"># 缓存不经常更改的内容</span></span><br><span class=\"line\"><span class=\"attr\">before_install:</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">export</span> <span class=\"string\">TZ='Asia/Shanghai'</span> <span class=\"comment\"># 更改时区</span></span><br><span class=\"line\"><span class=\"attr\">install:</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">npm</span> <span class=\"string\">install</span></span><br><span class=\"line\"><span class=\"attr\">script:</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">hexo</span> <span class=\"string\">clean</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">hexo</span> <span class=\"string\">g</span> </span><br><span class=\"line\"><span class=\"attr\">after_script:</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">git</span> <span class=\"string\">clone</span> <span class=\"attr\">https://$&#123;GH_REF&#125;</span> <span class=\"string\">.deploy_git</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">cd</span> <span class=\"string\">.deploy_git</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">git</span> <span class=\"string\">checkout</span> <span class=\"string\">master</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">cd</span> <span class=\"string\">../</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">mv</span> <span class=\"string\">.deploy_git/.git/</span> <span class=\"string\">./public/</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">cd</span> <span class=\"string\">./public</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">git</span> <span class=\"string\">config</span> <span class=\"string\">user.name</span> <span class=\"string\">\"BraveY\"</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">git</span> <span class=\"string\">config</span> <span class=\"string\">user.email</span> <span class=\"string\">\"lsz_yky@163.com\"</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">git</span> <span class=\"string\">add</span> <span class=\"string\">.</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">git</span> <span class=\"string\">commit</span> <span class=\"bullet\">-m</span> <span class=\"string\">\"Travis CI Auto Builder at `date +\"</span><span class=\"string\">%Y-%m-%d</span> <span class=\"string\">%H:%M\"`\"</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">git</span> <span class=\"string\">push</span> <span class=\"bullet\">--force</span> <span class=\"bullet\">--quiet</span> <span class=\"string\">\"https://$&#123;github_blog@$&#123;GH_REF&#125;\"</span> <span class=\"attr\">master:master</span></span><br><span class=\"line\"><span class=\"attr\">branches:</span></span><br><span class=\"line\"><span class=\"attr\">  only:</span></span><br><span class=\"line\"><span class=\"bullet\">  -</span> <span class=\"string\">hexo</span></span><br><span class=\"line\"><span class=\"attr\">env:</span></span><br><span class=\"line\"><span class=\"attr\">  global:</span></span><br><span class=\"line\"><span class=\"attr\">  - GH_REF:</span> <span class=\"string\">github.com/BraveY/BraveY.github.io.git</span></span><br><span class=\"line\"><span class=\"attr\">notifications:</span></span><br><span class=\"line\"><span class=\"attr\">  email:</span></span><br><span class=\"line\"><span class=\"bullet\">  -</span> <span class=\"string\">lsz_yky@163.com</span></span><br><span class=\"line\"><span class=\"attr\">  on_success:</span> <span class=\"string\">change</span></span><br><span class=\"line\"><span class=\"attr\">  on_failure:</span> <span class=\"string\">always</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"新增文章到-posts\"><a href=\"#新增文章到-posts\" class=\"headerlink\" title=\"新增文章到_posts\"></a>新增文章到_posts</h3><p>增减文章后，使用git push 命令即可，自动部署。</p>\n<p>可以看到 Travis CI 上面构建的一系列输出，但是博客并没有更新，而且github上的master分支也没有更改过。查看Travis CI 上的输出信息，发现在执行</p>\n<p><code>git push --force --quiet &quot;https://${github_blog@${GH_REF}&quot; master:master</code> 这句后报错：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/home/travis/.travis/functions: eval: line 104: unexpected EOF while looking for matching `&quot;&apos;</span><br><span class=\"line\">/home/travis/.travis/functions: eval: line 105: syntax error: unexpected end of file</span><br></pre></td></tr></table></figure>\n<p>然后发现<code>${github_blog@${GH_REF}</code> 这句花括号没有对齐匹配，无语。加上漏掉的右边花括号} 重新执行操作。一切正常。</p>\n<h2 id=\"博客更新操作\"><a href=\"#博客更新操作\" class=\"headerlink\" title=\"博客更新操作\"></a>博客更新操作</h2><p>后面就不用自己<code>hexo g -d</code> 了</p>\n<p>在_posts目录下增加文章后</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m&quot;&quot;</span><br><span class=\"line\">git push origin</span><br></pre></td></tr></table></figure>\n<p>感觉可以写个脚本</p>\n<p>命名为git_script.ps1  以后直接用powershell运行这个脚本就可以了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .</span><br><span class=\"line\">$date = get-date -uformat &quot;%Y-%m-%d %H:%M:%S&quot;</span><br><span class=\"line\">git commit -m&quot;new post $date&quot;</span><br><span class=\"line\">git push origin</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://www.itfanr.cc/2017/08/09/using-travis-ci-automatic-deploy-hexo-blogs/\" target=\"_blank\" rel=\"noopener\">https://www.itfanr.cc/2017/08/09/using-travis-ci-automatic-deploy-hexo-blogs/</a></p>\n<p><a href=\"http://www.dxjia.cn/2016/01/27/hexo-write-everywhere/\" target=\"_blank\" rel=\"noopener\">http://www.dxjia.cn/2016/01/27/hexo-write-everywhere/</a></p>\n<p><a href=\"http://www.yanglangjing.com/2018/08/28/travis_ci_auto_deploy_hexo_to_vps/\" target=\"_blank\" rel=\"noopener\">http://www.yanglangjing.com/2018/08/28/travis_ci_auto_deploy_hexo_to_vps/</a></p>\n","site":{"data":{}},"length":2794,"excerpt":"<h1 id=\"使用Travis-CI自动部署博客\"><a href=\"#使用Travis-CI自动部署博客\" class=\"headerlink\" title=\"使用Travis-CI自动部署博客\"></a>使用Travis-CI自动部署博客</h1><p>因为在github上面存储的是编译好的html代码，不是hexo博客中的博客源文件，所以如果没有备份源文件的话，丢失了源文件（包括md,一堆配置文件）后就不能继续更新博客了，而且也不能多端部署Hexo。网上看到可以使用Travis-CI来自动部署，同时解决了博客源文件的备份问题。</p>","more":"<h2 id=\"新建hexo分支来保存源文件\"><a href=\"#新建hexo分支来保存源文件\" class=\"headerlink\" title=\"新建hexo分支来保存源文件\"></a>新建hexo分支来保存源文件</h2><h3 id=\"新建分支\"><a href=\"#新建分支\" class=\"headerlink\" title=\"新建分支\"></a>新建分支</h3><p>直接在对应的github.io项目上的branch 按钮处点击新建分支 hexo。</p>\n<p>官方文档<a href=\"https://help.github.com/en/articles/setting-the-default-branch\" target=\"_blank\" rel=\"noopener\">https://help.github.com/en/articles/setting-the-default-branch</a> </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 克隆项目到本地</span><br><span class=\"line\">&gt; git clone https://github.com/BraveY/BraveY.github.io.git</span><br></pre></td></tr></table></figure>\n<h3 id=\"设置默认分支\"><a href=\"#设置默认分支\" class=\"headerlink\" title=\"设置默认分支\"></a>设置默认分支</h3><p>参照官方文档设置<a href=\"https://help.github.com/en/articles/setting-the-default-branch\" target=\"_blank\" rel=\"noopener\">https://help.github.com/en/articles/setting-the-default-branch</a></p>\n<h3 id=\"修改推送hexo分支\"><a href=\"#修改推送hexo分支\" class=\"headerlink\" title=\"修改推送hexo分支\"></a>修改推送hexo分支</h3><p>现将原来的文件BraveY.github.io 修改为BraveY.github.io.bak 避免拷贝的时候出现文件夹重名，同时将原来的hexo 目录blog文件也修改为blog.bak</p>\n<p>直接克隆到 本地</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 克隆项目到本地</span><br><span class=\"line\">&gt; git clone https://github.com/BraveY/BraveY.github.io.git</span><br></pre></td></tr></table></figure>\n<p>这时拷贝的项目已经是hexo分支下面的，因为之前是设置了hexo分支作为默认分支的。</p>\n<p>将克隆的BraveY.github.io文件夹重命名为blog</p>\n<p>在克隆的文件夹里面删除除了.git的所有文件</p>\n<p><strong>注意</strong> ：因为主题的next也是个git仓库，所以需要先把next目录下的.git删除</p>\n<p>然后先把theme/next 目录下的.git 给删除掉，不然的话next这个主题本来就是个git仓库，里面的个性化配置是无法上传到自己的项目中的，而且以后也无法克隆。</p>\n<p>从blog.bak文件中把所有hexo的源码文件拷过来。</p>\n<p>在博客目录下初始化git仓库并将所有文件提交。</p>\n<p>添加到远程仓库</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add . </span><br><span class=\"line\">git commit -m&quot;description&quot;</span><br><span class=\"line\">git push origin</span><br></pre></td></tr></table></figure>\n<p>现在hexo分支已经是存放了hexo的源文件了。</p>\n<h2 id=\"设置Travis-CI\"><a href=\"#设置Travis-CI\" class=\"headerlink\" title=\"设置Travis CI\"></a>设置Travis CI</h2><p>主要参考下面的三个博客，</p>\n<h3 id=\"Travis-CI-官网登陆\"><a href=\"#Travis-CI-官网登陆\" class=\"headerlink\" title=\"Travis CI 官网登陆\"></a>Travis CI 官网登陆</h3><p>使用github账号登陆<a href=\"https://travis-ci.org/\" target=\"_blank\" rel=\"noopener\">Travis CI官网</a>  ，选择博客项目启动。然后进行设置。</p>\n<p>没有文章中说的<code>Build only if .travis.yml is present</code> 选项，但好像没有影响，采用默认的选项。</p>\n<h3 id=\"github生成Access-Token\"><a href=\"#github生成Access-Token\" class=\"headerlink\" title=\"github生成Access Token\"></a>github生成Access Token</h3><p>参考博客，不赘述。</p>\n<h2 id=\"Travis-CI\"><a href=\"#Travis-CI\" class=\"headerlink\" title=\"Travis CI\"></a>Travis CI</h2><h3 id=\"配置travis-yml\"><a href=\"#配置travis-yml\" class=\"headerlink\" title=\"配置travis.yml\"></a>配置travis.yml</h3><p>在blog根目录下设置travis配置文件。</p>\n<p>.travis.yml 文件的配置为：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">language:</span> <span class=\"string\">node_js</span> <span class=\"comment\"># 设置语言</span></span><br><span class=\"line\"><span class=\"attr\">node_js:</span> <span class=\"string\">stable</span> <span class=\"comment\"># 设置相应版本</span></span><br><span class=\"line\"><span class=\"attr\">cache:</span></span><br><span class=\"line\"><span class=\"attr\">  apt:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">  directories:</span></span><br><span class=\"line\"><span class=\"bullet\">  -</span> <span class=\"string\">node_modules</span>  <span class=\"comment\"># 缓存不经常更改的内容</span></span><br><span class=\"line\"><span class=\"attr\">before_install:</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">export</span> <span class=\"string\">TZ='Asia/Shanghai'</span> <span class=\"comment\"># 更改时区</span></span><br><span class=\"line\"><span class=\"attr\">install:</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">npm</span> <span class=\"string\">install</span></span><br><span class=\"line\"><span class=\"attr\">script:</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">hexo</span> <span class=\"string\">clean</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">hexo</span> <span class=\"string\">g</span> </span><br><span class=\"line\"><span class=\"attr\">after_script:</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">git</span> <span class=\"string\">clone</span> <span class=\"attr\">https://$&#123;GH_REF&#125;</span> <span class=\"string\">.deploy_git</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">cd</span> <span class=\"string\">.deploy_git</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">git</span> <span class=\"string\">checkout</span> <span class=\"string\">master</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">cd</span> <span class=\"string\">../</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">mv</span> <span class=\"string\">.deploy_git/.git/</span> <span class=\"string\">./public/</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">cd</span> <span class=\"string\">./public</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">git</span> <span class=\"string\">config</span> <span class=\"string\">user.name</span> <span class=\"string\">\"BraveY\"</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">git</span> <span class=\"string\">config</span> <span class=\"string\">user.email</span> <span class=\"string\">\"lsz_yky@163.com\"</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">git</span> <span class=\"string\">add</span> <span class=\"string\">.</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">git</span> <span class=\"string\">commit</span> <span class=\"bullet\">-m</span> <span class=\"string\">\"Travis CI Auto Builder at `date +\"</span><span class=\"string\">%Y-%m-%d</span> <span class=\"string\">%H:%M\"`\"</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">git</span> <span class=\"string\">push</span> <span class=\"bullet\">--force</span> <span class=\"bullet\">--quiet</span> <span class=\"string\">\"https://$&#123;github_blog@$&#123;GH_REF&#125;\"</span> <span class=\"attr\">master:master</span></span><br><span class=\"line\"><span class=\"attr\">branches:</span></span><br><span class=\"line\"><span class=\"attr\">  only:</span></span><br><span class=\"line\"><span class=\"bullet\">  -</span> <span class=\"string\">hexo</span></span><br><span class=\"line\"><span class=\"attr\">env:</span></span><br><span class=\"line\"><span class=\"attr\">  global:</span></span><br><span class=\"line\"><span class=\"attr\">  - GH_REF:</span> <span class=\"string\">github.com/BraveY/BraveY.github.io.git</span></span><br><span class=\"line\"><span class=\"attr\">notifications:</span></span><br><span class=\"line\"><span class=\"attr\">  email:</span></span><br><span class=\"line\"><span class=\"bullet\">  -</span> <span class=\"string\">lsz_yky@163.com</span></span><br><span class=\"line\"><span class=\"attr\">  on_success:</span> <span class=\"string\">change</span></span><br><span class=\"line\"><span class=\"attr\">  on_failure:</span> <span class=\"string\">always</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"新增文章到-posts\"><a href=\"#新增文章到-posts\" class=\"headerlink\" title=\"新增文章到_posts\"></a>新增文章到_posts</h3><p>增减文章后，使用git push 命令即可，自动部署。</p>\n<p>可以看到 Travis CI 上面构建的一系列输出，但是博客并没有更新，而且github上的master分支也没有更改过。查看Travis CI 上的输出信息，发现在执行</p>\n<p><code>git push --force --quiet &quot;https://${github_blog@${GH_REF}&quot; master:master</code> 这句后报错：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/home/travis/.travis/functions: eval: line 104: unexpected EOF while looking for matching `&quot;&apos;</span><br><span class=\"line\">/home/travis/.travis/functions: eval: line 105: syntax error: unexpected end of file</span><br></pre></td></tr></table></figure>\n<p>然后发现<code>${github_blog@${GH_REF}</code> 这句花括号没有对齐匹配，无语。加上漏掉的右边花括号} 重新执行操作。一切正常。</p>\n<h2 id=\"博客更新操作\"><a href=\"#博客更新操作\" class=\"headerlink\" title=\"博客更新操作\"></a>博客更新操作</h2><p>后面就不用自己<code>hexo g -d</code> 了</p>\n<p>在_posts目录下增加文章后</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m&quot;&quot;</span><br><span class=\"line\">git push origin</span><br></pre></td></tr></table></figure>\n<p>感觉可以写个脚本</p>\n<p>命名为git_script.ps1  以后直接用powershell运行这个脚本就可以了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .</span><br><span class=\"line\">$date = get-date -uformat &quot;%Y-%m-%d %H:%M:%S&quot;</span><br><span class=\"line\">git commit -m&quot;new post $date&quot;</span><br><span class=\"line\">git push origin</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://www.itfanr.cc/2017/08/09/using-travis-ci-automatic-deploy-hexo-blogs/\" target=\"_blank\" rel=\"noopener\">https://www.itfanr.cc/2017/08/09/using-travis-ci-automatic-deploy-hexo-blogs/</a></p>\n<p><a href=\"http://www.dxjia.cn/2016/01/27/hexo-write-everywhere/\" target=\"_blank\" rel=\"noopener\">http://www.dxjia.cn/2016/01/27/hexo-write-everywhere/</a></p>\n<p><a href=\"http://www.yanglangjing.com/2018/08/28/travis_ci_auto_deploy_hexo_to_vps/\" target=\"_blank\" rel=\"noopener\">http://www.yanglangjing.com/2018/08/28/travis_ci_auto_deploy_hexo_to_vps/</a></p>"},{"title":"Redis设计与实现读书笔记——第二章SDS","date":"2019-03-20T07:20:23.000Z","copyright":true,"_content":"\n# Redis设计与实现读书笔记——第二章 \n\n为了做Redis相关实验，在网上粗略看了Redis设计与实现的电子版，感觉收获很多，但是因为是旧版，所以买了第二版，重读第二次。\n\n<!--more-->\n\n## 第二章 简单动态字符串\n\n### 简介\n\n1. 字符串值的键值对在底层都是由SDS实现的。\n2. sds的功能：\n   1. 存储字符串值\n   2. 用作缓冲区\n      1. AOF模块缓冲区\n      2. 客户端状态的输入缓冲区\n\n### 2.1 SDS的定义\n\n文件：sds.h/sdshdr 结构体 \n\n书中的为3.0版本，4.0版本有较大改动。\n\nversion: redis-4.02 \n\n参考：https://www.cnblogs.com/chenpingzhao/p/7292182.html\n\nhttps://www.codesheep.cn/2018/08/09/Redis%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E5%86%85%E9%83%A8%E7%BC%96%E7%A0%81%E5%89%96%E6%9E%90/\n\n````c\ntypedef char *sds;  //注意，sds其实不是一个结构体类型，而是被typedef的char*\n\n/* Note: sdshdr5 is never used, we just access the flags byte directly.\n * However is here to document the layout of type 5 SDS strings. */\nstruct __attribute__ ((__packed__)) sdshdr5 {\n    unsigned char flags; /* 3 lsb of type, and 5 msb of string length */\n    char buf[];\n};\nstruct __attribute__ ((__packed__)) sdshdr8 {\n    uint8_t len; /* used */\n    uint8_t alloc; /* excluding the header and null terminator */\n    unsigned char flags; /* 3 lsb of type, 5 unused bits */\n    char buf[];\n};\nstruct __attribute__ ((__packed__)) sdshdr16 {\n    uint16_t len; /* used */\n    uint16_t alloc; /* excluding the header and null terminator */\n    unsigned char flags; /* 3 lsb of type, 5 unused bits */\n    char buf[];\n};\nstruct __attribute__ ((__packed__)) sdshdr32 {\n    uint32_t len; /* used */\n    uint32_t alloc; /* excluding the header and null terminator */\n    unsigned char flags; /* 3 lsb of type, 5 unused bits */\n    char buf[];\n};\nstruct __attribute__ ((__packed__)) sdshdr64 {\n    uint64_t len; /* used */\n    uint64_t alloc; /* excluding the header and null terminator */\n    unsigned char flags; /* 3 lsb of type, 5 unused bits */\n    char buf[];\n};\n\n````\n\n除了结构体字段对len和alloc的数据类型的不同(` unit8, unit16， unit32, unit64`)，  其字段含义相差无几。其中header记录`len, alloc, flags` 信息。不同的header的目的是节省内存。**header与buf数组在内存地址上前后相邻。**\n\n```\n+--------+-------------------------------+-----------+\n| Header | Binary safe C alike string... | Null term |\n+--------+-------------------------------+-----------+\n         |\n         `-> Pointer returned to the user.\n```\n\n```\nlen: 记录buf数组中已使用的字节数量 等于保存的字符串的长度 （不算结尾的\\0 标识符）\nalloc: 字符串最大的容量。（除开header和最后的null终止符） \nflags: 总是会占用一个字节 8bit，加上unsigned是因为flags都是非负数 ，其中的最低3个bit用来表示header的类型还有 5个bit没有使用。\nbuf: 字符数组，用于保存字符串。  柔性数组\n```\n\nbuf的大小=alloc+1；\n\nheader类型定义中，注意的地方：\n\n- 在各个header的定义中使用了__attribute__ ((packed))，是为了让**编译器以紧凑模式来分配内存**，取消字节对齐。\n\n  - 结构体的成员内存是'\"连续\"的，但是这个连续是以对齐的单位而言的。比如说A成员的内存是3个字节，假设对齐单位是4个字节，会给A成员多分配一个字节。A成员后面才又紧接B成员的内存。\n  - 如果没有这个属性，编译器可能会为struct的字段做优化对齐，在其中填充空字节。那样的话，就不能保证header和sds的数据部分紧紧前后相邻，也不能按照固定向低地址方向偏移1个字节的方式来获取flags字段了。\n\n- 在各个header的定义中最后有一个char buf[]。我们注意到这是一个没有指明长度的字符数组，这是C语言中定义字符数组的一种特殊写法，称为**柔性数组**（[flexible array member](https://en.wikipedia.org/wiki/Flexible_array_member)），只能定义在一个结构体的最后一个字段上。它在这里只是起到一个标记的作用，表示在flags字段后面就是一个字符数组，或者说，它指明了紧跟在flags字段后面的这个字符数组在结构体中的偏移位置。而程序在为header分配的内存的时候，它并不占用内存空间。如果计算sizeof(struct sdshdr16)的值，那么结果是5个字节，其中没有buf字段。\n\n- sdshdr5与其它几个header结构不同，它不包含alloc字段，而长度使用flags的高5位来存储。因此，它不能为字符串分配空余空间。如果字符串需要动态增长，那么它就必然要重新分配内存才行。所以说，这种类型的sds字符串更适合存储静态的短字符串（长度小于32）。 因为长度的范围是5个bit来存储的\n  $$\n  2^5-1 = 31\n  $$\n\n\n\n\nsds字符串的header，其实隐藏在真正的字符串数据的前面（低地址方向）。这样的一个定义，有如下几个好处\n\n- header和数据相邻，而不用分成两块内存空间来单独分配。这有利于减少内存碎片，提高存储效率（memory efficiency）。\n- 虽然header有多个类型，但sds可以用统一的char *来表达。且它与传统的C语言字符串保持类型兼容。如果一个sds里面存储的是可打印字符串，那么我们可以直接把它传给C函数，比如使用strcmp比较字符串大小，或者使用printf进行打印。\n### 2.2 SDS与C字符串的区别\n\nc语言使用N+1长度的字符数组来表示长度为N的字符串，因为需要增加一个`\\0` 字符终止\n\n#### 2.2.1  常数复杂度获取字符串长度\n\n因为c语言要知道字符串的长度只能遍历数组，所以复杂度为O(N)。 \n\n而获取sds的字符串长度，只需要返回len的值就可以了复杂度为O(1)。这样对一个非常长的字符串键反复执行STRLEN命令，也不会对系统性能造成任何影响。\n\n#### 2.2.2 杜绝缓冲区溢出\n\nC字符串不记录自身长度会带来易造成缓冲区溢出的问题。 比如使用strcat函数拼接两个字符串，被拼接的字符串要是没有提前分配空间，就会造成缓冲区溢出。（溢出的字节会导致这个字符串内存紧邻的其他字符串的内容被修改）\n\n而SDS的空间分配策略完全杜绝了发生缓冲区溢出的可能，SDS的API需要修改SDS时，会先检查空间alloc是否满足修改所需的要求。不满足的话会先将空间扩展至修改所需的大小，再执行修改。\n\n#### 2.2.3 减少修改字符串时带来的内存重分配次数\n\nC语言字符串用N+1个字节长的数组来保存N个字节的字符串，因为这个关联性所以每次每次增长或者缩短一个C字符串，都要对这个字符串进行一次内存重分配操作。\n\n- 执行增长操作 比如append，需要首先通过内存重分配来扩展底层数组的空间大小，否则产生缓冲区溢出\n- 执行所动操作比如截断操作trime，需要首先通过内存重分配来释放字符串不再使用的空间，否则造成内存泄漏。\n\n内存重分配涉及复杂的算法，并且可能需要执行系统调用，所以通常是一个比较耗时的操作。这对Redis经常用于速度要求严苛，数据被频繁修改的场合来说，是不可接受的。\n\n因此SDS通过未使用空间解除了字符串长度和底层数组长度之间的关联：buf的长度可以大于len的长度。 **（4.0版本的源码还未找到对应的函数，所以可能和书上说的有变化了）**\n\n1. 空间预分配 ——减少连续执行字符串增长操作所需的内存重分配次数。\n\n   - 用于优化字符串**增长**操作。\n\n     当需要对SDS的空间进行空间扩展时，不仅会对SDS分配修改所必需的空间，还会额外分配未使用空间。\n\n     当len < 1Mb时 alloc = 2*len; 当len >= 1 mb时 alloc= len +1Mb。\n\n   源码分析\n\n   ```c\n   /* Enlarge the free space at the end of the sds string so that the caller\n    * is sure that after calling this function can overwrite up to addlen\n    * bytes after the end of the string, plus one more byte for nul term.\n    *\n    * Note: this does not change the *length* of the sds string as returned\n    * by sdslen(), but only the free buffer space we have. */\n   sds sdsMakeRoomFor(sds s, size_t addlen) {\n       void *sh, *newsh;\n       size_t avail = sdsavail(s);\n       size_t len, newlen;\n       char type, oldtype = s[-1] & SDS_TYPE_MASK;\n       int hdrlen;\n   \n       /* Return ASAP if there is enough space left. */\n       if (avail >= addlen) return s;\n   \n       len = sdslen(s);\n       sh = (char*)s-sdsHdrSize(oldtype);\n       newlen = (len+addlen);  // 预分配\n       if (newlen < SDS_MAX_PREALLOC)\n           newlen *= 2;\n       else\n           newlen += SDS_MAX_PREALLOC;\n   \n       type = sdsReqType(newlen);\n   \n       /* Don't use type 5: the user is appending to the string and type 5 is\n        * not able to remember empty space, so sdsMakeRoomFor() must be called\n        * at every appending operation. */\n       if (type == SDS_TYPE_5) type = SDS_TYPE_8;\n   \n       hdrlen = sdsHdrSize(type);\n       if (oldtype==type) {\n           newsh = s_realloc(sh, hdrlen+newlen+1);\n           if (newsh == NULL) return NULL;\n           s = (char*)newsh+hdrlen;\n       } else {\n           /* Since the header size changes, need to move the string forward,\n            * and can't use realloc */\n           newsh = s_malloc(hdrlen+newlen+1);\n           if (newsh == NULL) return NULL;\n           memcpy((char*)newsh+hdrlen, s, len+1);\n           s_free(sh);\n           s = (char*)newsh+hdrlen;\n           s[-1] = type;\n           sdssetlen(s, len);\n       }\n       sdssetalloc(s, newlen);\n       return s;\n   }\n   ```\n\n   \n\n2. 惰性空间释放\n\n   - 用于优化SDS的字符串**缩短**操作\n\n     缩短SDS保存的字符串时，并不立即使用内存重分配来回收缩短后多出来的字节，而是使用free属性，将这些字节的数量记录起来，并等待将来使用。\n\n#### 2.2.4 二进制安全\n\nC字符串中的字符必须符合某种编码（如ASCII），除了末尾字符串中间不能有`\\0` 这个空字符，否则最先被程序读取的空字符将被认为是结尾，导致C字符串只能保存文本数据，而不能保存图片、音频、视频、压缩文件这样的二进制数据。\n\n所谓二进制安全：以处理二进制的方式来处理SDS存放在buf数组里的数据，程序不会对其中的数据做任何限制、过滤、或者假设，数据在写入时是什么样的，被读取是就是什么样的。因为SDS使用len来判断字符串是否结束。\n\n所以buf是字节数组，而不是字符数组。\n\n#### 2.2.5 兼容部分C字符串函数\n\n因为遵循C字符串以`\\0`结尾的惯例，所以可以兼容`<string.h>/strcasecmp ` ,`<stdio.h>/printf` 这些函数。但是是否是书上的使用结构体指针还是博客说的可以直接使用sds来调用？还需验证。\n\n书：`printf(\"%s\", sds->buf)`  sds是指向结构体的指针。\n\n博客：https://blog.csdn.net/yangbodong22011/article/details/78419966   :`printf(%s, sds)`\n\n源码中是直接使用sds\n\n#### 2.2.6 总结\n\n|                C字符串                 |              SDS               |\n| :------------------------------------: | :----------------------------: |\n|       获取字符串长度复杂度为O(N)       |   获取字符串长度复杂度为O(1)   |\n|     API不安全，可能造成缓冲区溢出      |  API安全，不会造成缓冲区溢出   |\n| 修改字符串长度N次必然执行N次内存重分配 |     最多执行N次内存重分配      |\n|            只能保存文本数据            | 二进制安全文本与二进制数据皆可 |\n|     可使用`<string.h>`库中所有函数     |  部分使用`<string.h>`库中函数  |\n\n### 2.3 SDSAPI\n\n\n\n|               函数                |                    作用                    |\n| :-------------------------------: | :----------------------------------------: |\n|        sdslen(const sds s)        |          获取sds字符串长度 O（1）          |\n|  sdssetlen(sds s, size_t newlen)  |             设置sds字符串长度              |\n|   sdsinclen(sds s, size_t inc)    |             增加sds字符串长度              |\n|       sdsalloc(const sds s)       |             获取sds字符串容量              |\n| sdssetalloc(sds s, size_t newlen) |            设置sds字符串容量。             |\n|       sdsavail(const sds s)       |   获取sds字符串空余空间（即alloc - len）   |\n|       sdsHdrSize(char type)       |        根据header类型得到header大小        |\n|  sdsReqType(size_t string_size)   | 根据字符串数据长度计算所需要的header类型。 |\n\n#### sdsReqType函数源码分析\n\n```c\nstatic inline char sdsReqType(size_t string_size) {\n    if (string_size < 1<<5) // string_size < 2^5\n        return SDS_TYPE_5;\n    if (string_size < 1<<8)  //string_size < 2^8\n        return SDS_TYPE_8;\n    if (string_size < 1<<16)\t//string_size < 2^16\n        return SDS_TYPE_16;\n#if (LONG_MAX == LLONG_MAX)\n    if (string_size < 1ll<<32)  //string_size < 2^32\n        return SDS_TYPE_32;\n#endif\n    return SDS_TYPE_64; \n}\n```\n\n采用左移来计算对应多少位的范围，而不是用2^5 这样的乘法。**直接移位比使用幂来计算快很多**。\n\n`1<<5`   计算出来就是2^5 次方。1是int型，4byte32位。最低8bit位的二进制为：00000001 左移5位后变成了：00100000 对应的十进制既是32。\n\n计算n个bit位的最大值：(1<<n) -1\n\n但是需要注意位数不够的情况。因为1是int型，只有32个bit。所以在左移32个bit时，需要使用long long int型。用1ll来表示，此时1ll为64个bit。\n\n还得考虑机器是否为64位机器，在32位机器上LONG_MAX = 2147483647L，64位机器上LONG_MAX = 9223372036854775807L 。不论32位机器还是64位机器上 LLONG_MAX 都是9223372036854775807L 。所以当LONG_MAX == LLONG_MAX 说明字长为64bit。加上条件编译，说明在32位机器上不使用sdshdr32而直接跳到了sdshdr64，仅仅在64位机器上使用sdshdr32。原因是什么？还没想通\n\n#### 问题\n\n1. 为什么Redis需要自己实现字符串功能，而不直接使用c语言的传统字符串？\n   - 见第二节。\n2. 执行SET 与GET命令的过程。\n3. `char buf[]` 为什么没有指定大小？一个数组占用的内存大小\n   - 在各个header的定义中最后有一个char buf[]。我们注意到这是一个没有指明长度的字符数组，这是C语言中定义字符数组的一种特殊写法，称为柔性数组（[flexible array member](https://en.wikipedia.org/wiki/Flexible_array_member)），只能定义在一个结构体的最后一个字段上。它在这里只是起到一个标记的作用，表示在flags字段后面就是一个字符数组，或者说，它指明了紧跟在flags字段后面的这个字符数组在结构体中的偏移位置。而程序在为header分配的内存的时候，它并不占用内存空间。如果计算sizeof(struct sdshdr16)的值，那么结果是5个字节，其中没有buf字段。\n   - 数组内存大小为分配的的长度*数组类型的内存大小\n4. 为什么redis 在32位机器上不使用sdshdr32？ ","source":"_posts/2019-03-20-Redis设计与实现读书笔记.md","raw":"---\ntitle: Redis设计与实现读书笔记——第二章SDS\ndate: 2019-03-20 15:20:23\ncategories: 读书笔记\ntags:\n- redis\n- 源码阅读\ncopyright: true\n---\n\n# Redis设计与实现读书笔记——第二章 \n\n为了做Redis相关实验，在网上粗略看了Redis设计与实现的电子版，感觉收获很多，但是因为是旧版，所以买了第二版，重读第二次。\n\n<!--more-->\n\n## 第二章 简单动态字符串\n\n### 简介\n\n1. 字符串值的键值对在底层都是由SDS实现的。\n2. sds的功能：\n   1. 存储字符串值\n   2. 用作缓冲区\n      1. AOF模块缓冲区\n      2. 客户端状态的输入缓冲区\n\n### 2.1 SDS的定义\n\n文件：sds.h/sdshdr 结构体 \n\n书中的为3.0版本，4.0版本有较大改动。\n\nversion: redis-4.02 \n\n参考：https://www.cnblogs.com/chenpingzhao/p/7292182.html\n\nhttps://www.codesheep.cn/2018/08/09/Redis%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E5%86%85%E9%83%A8%E7%BC%96%E7%A0%81%E5%89%96%E6%9E%90/\n\n````c\ntypedef char *sds;  //注意，sds其实不是一个结构体类型，而是被typedef的char*\n\n/* Note: sdshdr5 is never used, we just access the flags byte directly.\n * However is here to document the layout of type 5 SDS strings. */\nstruct __attribute__ ((__packed__)) sdshdr5 {\n    unsigned char flags; /* 3 lsb of type, and 5 msb of string length */\n    char buf[];\n};\nstruct __attribute__ ((__packed__)) sdshdr8 {\n    uint8_t len; /* used */\n    uint8_t alloc; /* excluding the header and null terminator */\n    unsigned char flags; /* 3 lsb of type, 5 unused bits */\n    char buf[];\n};\nstruct __attribute__ ((__packed__)) sdshdr16 {\n    uint16_t len; /* used */\n    uint16_t alloc; /* excluding the header and null terminator */\n    unsigned char flags; /* 3 lsb of type, 5 unused bits */\n    char buf[];\n};\nstruct __attribute__ ((__packed__)) sdshdr32 {\n    uint32_t len; /* used */\n    uint32_t alloc; /* excluding the header and null terminator */\n    unsigned char flags; /* 3 lsb of type, 5 unused bits */\n    char buf[];\n};\nstruct __attribute__ ((__packed__)) sdshdr64 {\n    uint64_t len; /* used */\n    uint64_t alloc; /* excluding the header and null terminator */\n    unsigned char flags; /* 3 lsb of type, 5 unused bits */\n    char buf[];\n};\n\n````\n\n除了结构体字段对len和alloc的数据类型的不同(` unit8, unit16， unit32, unit64`)，  其字段含义相差无几。其中header记录`len, alloc, flags` 信息。不同的header的目的是节省内存。**header与buf数组在内存地址上前后相邻。**\n\n```\n+--------+-------------------------------+-----------+\n| Header | Binary safe C alike string... | Null term |\n+--------+-------------------------------+-----------+\n         |\n         `-> Pointer returned to the user.\n```\n\n```\nlen: 记录buf数组中已使用的字节数量 等于保存的字符串的长度 （不算结尾的\\0 标识符）\nalloc: 字符串最大的容量。（除开header和最后的null终止符） \nflags: 总是会占用一个字节 8bit，加上unsigned是因为flags都是非负数 ，其中的最低3个bit用来表示header的类型还有 5个bit没有使用。\nbuf: 字符数组，用于保存字符串。  柔性数组\n```\n\nbuf的大小=alloc+1；\n\nheader类型定义中，注意的地方：\n\n- 在各个header的定义中使用了__attribute__ ((packed))，是为了让**编译器以紧凑模式来分配内存**，取消字节对齐。\n\n  - 结构体的成员内存是'\"连续\"的，但是这个连续是以对齐的单位而言的。比如说A成员的内存是3个字节，假设对齐单位是4个字节，会给A成员多分配一个字节。A成员后面才又紧接B成员的内存。\n  - 如果没有这个属性，编译器可能会为struct的字段做优化对齐，在其中填充空字节。那样的话，就不能保证header和sds的数据部分紧紧前后相邻，也不能按照固定向低地址方向偏移1个字节的方式来获取flags字段了。\n\n- 在各个header的定义中最后有一个char buf[]。我们注意到这是一个没有指明长度的字符数组，这是C语言中定义字符数组的一种特殊写法，称为**柔性数组**（[flexible array member](https://en.wikipedia.org/wiki/Flexible_array_member)），只能定义在一个结构体的最后一个字段上。它在这里只是起到一个标记的作用，表示在flags字段后面就是一个字符数组，或者说，它指明了紧跟在flags字段后面的这个字符数组在结构体中的偏移位置。而程序在为header分配的内存的时候，它并不占用内存空间。如果计算sizeof(struct sdshdr16)的值，那么结果是5个字节，其中没有buf字段。\n\n- sdshdr5与其它几个header结构不同，它不包含alloc字段，而长度使用flags的高5位来存储。因此，它不能为字符串分配空余空间。如果字符串需要动态增长，那么它就必然要重新分配内存才行。所以说，这种类型的sds字符串更适合存储静态的短字符串（长度小于32）。 因为长度的范围是5个bit来存储的\n  $$\n  2^5-1 = 31\n  $$\n\n\n\n\nsds字符串的header，其实隐藏在真正的字符串数据的前面（低地址方向）。这样的一个定义，有如下几个好处\n\n- header和数据相邻，而不用分成两块内存空间来单独分配。这有利于减少内存碎片，提高存储效率（memory efficiency）。\n- 虽然header有多个类型，但sds可以用统一的char *来表达。且它与传统的C语言字符串保持类型兼容。如果一个sds里面存储的是可打印字符串，那么我们可以直接把它传给C函数，比如使用strcmp比较字符串大小，或者使用printf进行打印。\n### 2.2 SDS与C字符串的区别\n\nc语言使用N+1长度的字符数组来表示长度为N的字符串，因为需要增加一个`\\0` 字符终止\n\n#### 2.2.1  常数复杂度获取字符串长度\n\n因为c语言要知道字符串的长度只能遍历数组，所以复杂度为O(N)。 \n\n而获取sds的字符串长度，只需要返回len的值就可以了复杂度为O(1)。这样对一个非常长的字符串键反复执行STRLEN命令，也不会对系统性能造成任何影响。\n\n#### 2.2.2 杜绝缓冲区溢出\n\nC字符串不记录自身长度会带来易造成缓冲区溢出的问题。 比如使用strcat函数拼接两个字符串，被拼接的字符串要是没有提前分配空间，就会造成缓冲区溢出。（溢出的字节会导致这个字符串内存紧邻的其他字符串的内容被修改）\n\n而SDS的空间分配策略完全杜绝了发生缓冲区溢出的可能，SDS的API需要修改SDS时，会先检查空间alloc是否满足修改所需的要求。不满足的话会先将空间扩展至修改所需的大小，再执行修改。\n\n#### 2.2.3 减少修改字符串时带来的内存重分配次数\n\nC语言字符串用N+1个字节长的数组来保存N个字节的字符串，因为这个关联性所以每次每次增长或者缩短一个C字符串，都要对这个字符串进行一次内存重分配操作。\n\n- 执行增长操作 比如append，需要首先通过内存重分配来扩展底层数组的空间大小，否则产生缓冲区溢出\n- 执行所动操作比如截断操作trime，需要首先通过内存重分配来释放字符串不再使用的空间，否则造成内存泄漏。\n\n内存重分配涉及复杂的算法，并且可能需要执行系统调用，所以通常是一个比较耗时的操作。这对Redis经常用于速度要求严苛，数据被频繁修改的场合来说，是不可接受的。\n\n因此SDS通过未使用空间解除了字符串长度和底层数组长度之间的关联：buf的长度可以大于len的长度。 **（4.0版本的源码还未找到对应的函数，所以可能和书上说的有变化了）**\n\n1. 空间预分配 ——减少连续执行字符串增长操作所需的内存重分配次数。\n\n   - 用于优化字符串**增长**操作。\n\n     当需要对SDS的空间进行空间扩展时，不仅会对SDS分配修改所必需的空间，还会额外分配未使用空间。\n\n     当len < 1Mb时 alloc = 2*len; 当len >= 1 mb时 alloc= len +1Mb。\n\n   源码分析\n\n   ```c\n   /* Enlarge the free space at the end of the sds string so that the caller\n    * is sure that after calling this function can overwrite up to addlen\n    * bytes after the end of the string, plus one more byte for nul term.\n    *\n    * Note: this does not change the *length* of the sds string as returned\n    * by sdslen(), but only the free buffer space we have. */\n   sds sdsMakeRoomFor(sds s, size_t addlen) {\n       void *sh, *newsh;\n       size_t avail = sdsavail(s);\n       size_t len, newlen;\n       char type, oldtype = s[-1] & SDS_TYPE_MASK;\n       int hdrlen;\n   \n       /* Return ASAP if there is enough space left. */\n       if (avail >= addlen) return s;\n   \n       len = sdslen(s);\n       sh = (char*)s-sdsHdrSize(oldtype);\n       newlen = (len+addlen);  // 预分配\n       if (newlen < SDS_MAX_PREALLOC)\n           newlen *= 2;\n       else\n           newlen += SDS_MAX_PREALLOC;\n   \n       type = sdsReqType(newlen);\n   \n       /* Don't use type 5: the user is appending to the string and type 5 is\n        * not able to remember empty space, so sdsMakeRoomFor() must be called\n        * at every appending operation. */\n       if (type == SDS_TYPE_5) type = SDS_TYPE_8;\n   \n       hdrlen = sdsHdrSize(type);\n       if (oldtype==type) {\n           newsh = s_realloc(sh, hdrlen+newlen+1);\n           if (newsh == NULL) return NULL;\n           s = (char*)newsh+hdrlen;\n       } else {\n           /* Since the header size changes, need to move the string forward,\n            * and can't use realloc */\n           newsh = s_malloc(hdrlen+newlen+1);\n           if (newsh == NULL) return NULL;\n           memcpy((char*)newsh+hdrlen, s, len+1);\n           s_free(sh);\n           s = (char*)newsh+hdrlen;\n           s[-1] = type;\n           sdssetlen(s, len);\n       }\n       sdssetalloc(s, newlen);\n       return s;\n   }\n   ```\n\n   \n\n2. 惰性空间释放\n\n   - 用于优化SDS的字符串**缩短**操作\n\n     缩短SDS保存的字符串时，并不立即使用内存重分配来回收缩短后多出来的字节，而是使用free属性，将这些字节的数量记录起来，并等待将来使用。\n\n#### 2.2.4 二进制安全\n\nC字符串中的字符必须符合某种编码（如ASCII），除了末尾字符串中间不能有`\\0` 这个空字符，否则最先被程序读取的空字符将被认为是结尾，导致C字符串只能保存文本数据，而不能保存图片、音频、视频、压缩文件这样的二进制数据。\n\n所谓二进制安全：以处理二进制的方式来处理SDS存放在buf数组里的数据，程序不会对其中的数据做任何限制、过滤、或者假设，数据在写入时是什么样的，被读取是就是什么样的。因为SDS使用len来判断字符串是否结束。\n\n所以buf是字节数组，而不是字符数组。\n\n#### 2.2.5 兼容部分C字符串函数\n\n因为遵循C字符串以`\\0`结尾的惯例，所以可以兼容`<string.h>/strcasecmp ` ,`<stdio.h>/printf` 这些函数。但是是否是书上的使用结构体指针还是博客说的可以直接使用sds来调用？还需验证。\n\n书：`printf(\"%s\", sds->buf)`  sds是指向结构体的指针。\n\n博客：https://blog.csdn.net/yangbodong22011/article/details/78419966   :`printf(%s, sds)`\n\n源码中是直接使用sds\n\n#### 2.2.6 总结\n\n|                C字符串                 |              SDS               |\n| :------------------------------------: | :----------------------------: |\n|       获取字符串长度复杂度为O(N)       |   获取字符串长度复杂度为O(1)   |\n|     API不安全，可能造成缓冲区溢出      |  API安全，不会造成缓冲区溢出   |\n| 修改字符串长度N次必然执行N次内存重分配 |     最多执行N次内存重分配      |\n|            只能保存文本数据            | 二进制安全文本与二进制数据皆可 |\n|     可使用`<string.h>`库中所有函数     |  部分使用`<string.h>`库中函数  |\n\n### 2.3 SDSAPI\n\n\n\n|               函数                |                    作用                    |\n| :-------------------------------: | :----------------------------------------: |\n|        sdslen(const sds s)        |          获取sds字符串长度 O（1）          |\n|  sdssetlen(sds s, size_t newlen)  |             设置sds字符串长度              |\n|   sdsinclen(sds s, size_t inc)    |             增加sds字符串长度              |\n|       sdsalloc(const sds s)       |             获取sds字符串容量              |\n| sdssetalloc(sds s, size_t newlen) |            设置sds字符串容量。             |\n|       sdsavail(const sds s)       |   获取sds字符串空余空间（即alloc - len）   |\n|       sdsHdrSize(char type)       |        根据header类型得到header大小        |\n|  sdsReqType(size_t string_size)   | 根据字符串数据长度计算所需要的header类型。 |\n\n#### sdsReqType函数源码分析\n\n```c\nstatic inline char sdsReqType(size_t string_size) {\n    if (string_size < 1<<5) // string_size < 2^5\n        return SDS_TYPE_5;\n    if (string_size < 1<<8)  //string_size < 2^8\n        return SDS_TYPE_8;\n    if (string_size < 1<<16)\t//string_size < 2^16\n        return SDS_TYPE_16;\n#if (LONG_MAX == LLONG_MAX)\n    if (string_size < 1ll<<32)  //string_size < 2^32\n        return SDS_TYPE_32;\n#endif\n    return SDS_TYPE_64; \n}\n```\n\n采用左移来计算对应多少位的范围，而不是用2^5 这样的乘法。**直接移位比使用幂来计算快很多**。\n\n`1<<5`   计算出来就是2^5 次方。1是int型，4byte32位。最低8bit位的二进制为：00000001 左移5位后变成了：00100000 对应的十进制既是32。\n\n计算n个bit位的最大值：(1<<n) -1\n\n但是需要注意位数不够的情况。因为1是int型，只有32个bit。所以在左移32个bit时，需要使用long long int型。用1ll来表示，此时1ll为64个bit。\n\n还得考虑机器是否为64位机器，在32位机器上LONG_MAX = 2147483647L，64位机器上LONG_MAX = 9223372036854775807L 。不论32位机器还是64位机器上 LLONG_MAX 都是9223372036854775807L 。所以当LONG_MAX == LLONG_MAX 说明字长为64bit。加上条件编译，说明在32位机器上不使用sdshdr32而直接跳到了sdshdr64，仅仅在64位机器上使用sdshdr32。原因是什么？还没想通\n\n#### 问题\n\n1. 为什么Redis需要自己实现字符串功能，而不直接使用c语言的传统字符串？\n   - 见第二节。\n2. 执行SET 与GET命令的过程。\n3. `char buf[]` 为什么没有指定大小？一个数组占用的内存大小\n   - 在各个header的定义中最后有一个char buf[]。我们注意到这是一个没有指明长度的字符数组，这是C语言中定义字符数组的一种特殊写法，称为柔性数组（[flexible array member](https://en.wikipedia.org/wiki/Flexible_array_member)），只能定义在一个结构体的最后一个字段上。它在这里只是起到一个标记的作用，表示在flags字段后面就是一个字符数组，或者说，它指明了紧跟在flags字段后面的这个字符数组在结构体中的偏移位置。而程序在为header分配的内存的时候，它并不占用内存空间。如果计算sizeof(struct sdshdr16)的值，那么结果是5个字节，其中没有buf字段。\n   - 数组内存大小为分配的的长度*数组类型的内存大小\n4. 为什么redis 在32位机器上不使用sdshdr32？ ","slug":"2019-03-20-Redis设计与实现读书笔记","published":1,"updated":"2019-11-08T13:15:20.055Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2yelxgs0002m8tze8eh0xmf","content":"<h1 id=\"Redis设计与实现读书笔记——第二章\"><a href=\"#Redis设计与实现读书笔记——第二章\" class=\"headerlink\" title=\"Redis设计与实现读书笔记——第二章\"></a>Redis设计与实现读书笔记——第二章</h1><p>为了做Redis相关实验，在网上粗略看了Redis设计与实现的电子版，感觉收获很多，但是因为是旧版，所以买了第二版，重读第二次。</p>\n<a id=\"more\"></a>\n<h2 id=\"第二章-简单动态字符串\"><a href=\"#第二章-简单动态字符串\" class=\"headerlink\" title=\"第二章 简单动态字符串\"></a>第二章 简单动态字符串</h2><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><ol>\n<li>字符串值的键值对在底层都是由SDS实现的。</li>\n<li>sds的功能：<ol>\n<li>存储字符串值</li>\n<li>用作缓冲区<ol>\n<li>AOF模块缓冲区</li>\n<li>客户端状态的输入缓冲区</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"2-1-SDS的定义\"><a href=\"#2-1-SDS的定义\" class=\"headerlink\" title=\"2.1 SDS的定义\"></a>2.1 SDS的定义</h3><p>文件：sds.h/sdshdr 结构体 </p>\n<p>书中的为3.0版本，4.0版本有较大改动。</p>\n<p>version: redis-4.02 </p>\n<p>参考：<a href=\"https://www.cnblogs.com/chenpingzhao/p/7292182.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/chenpingzhao/p/7292182.html</a></p>\n<p><a href=\"https://www.codesheep.cn/2018/08/09/Redis%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E5%86%85%E9%83%A8%E7%BC%96%E7%A0%81%E5%89%96%E6%9E%90/\" target=\"_blank\" rel=\"noopener\">https://www.codesheep.cn/2018/08/09/Redis%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E5%86%85%E9%83%A8%E7%BC%96%E7%A0%81%E5%89%96%E6%9E%90/</a></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">char</span> *sds;  <span class=\"comment\">//注意，sds其实不是一个结构体类型，而是被typedef的char*</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Note: sdshdr5 is never used, we just access the flags byte directly.</span></span><br><span class=\"line\"><span class=\"comment\"> * However is here to document the layout of type 5 SDS strings. */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> __<span class=\"title\">attribute__</span> ((__<span class=\"title\">packed__</span>)) <span class=\"title\">sdshdr5</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> flags; <span class=\"comment\">/* 3 lsb of type, and 5 msb of string length */</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> buf[];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> __<span class=\"title\">attribute__</span> ((__<span class=\"title\">packed__</span>)) <span class=\"title\">sdshdr8</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">uint8_t</span> len; <span class=\"comment\">/* used */</span></span><br><span class=\"line\">    <span class=\"keyword\">uint8_t</span> alloc; <span class=\"comment\">/* excluding the header and null terminator */</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> flags; <span class=\"comment\">/* 3 lsb of type, 5 unused bits */</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> buf[];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> __<span class=\"title\">attribute__</span> ((__<span class=\"title\">packed__</span>)) <span class=\"title\">sdshdr16</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">uint16_t</span> len; <span class=\"comment\">/* used */</span></span><br><span class=\"line\">    <span class=\"keyword\">uint16_t</span> alloc; <span class=\"comment\">/* excluding the header and null terminator */</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> flags; <span class=\"comment\">/* 3 lsb of type, 5 unused bits */</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> buf[];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> __<span class=\"title\">attribute__</span> ((__<span class=\"title\">packed__</span>)) <span class=\"title\">sdshdr32</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> len; <span class=\"comment\">/* used */</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> alloc; <span class=\"comment\">/* excluding the header and null terminator */</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> flags; <span class=\"comment\">/* 3 lsb of type, 5 unused bits */</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> buf[];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> __<span class=\"title\">attribute__</span> ((__<span class=\"title\">packed__</span>)) <span class=\"title\">sdshdr64</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">uint64_t</span> len; <span class=\"comment\">/* used */</span></span><br><span class=\"line\">    <span class=\"keyword\">uint64_t</span> alloc; <span class=\"comment\">/* excluding the header and null terminator */</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> flags; <span class=\"comment\">/* 3 lsb of type, 5 unused bits */</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> buf[];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>除了结构体字段对len和alloc的数据类型的不同(<code>unit8, unit16， unit32, unit64</code>)，  其字段含义相差无几。其中header记录<code>len, alloc, flags</code> 信息。不同的header的目的是节省内存。<strong>header与buf数组在内存地址上前后相邻。</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+--------+-------------------------------+-----------+</span><br><span class=\"line\">| Header | Binary safe C alike string... | Null term |</span><br><span class=\"line\">+--------+-------------------------------+-----------+</span><br><span class=\"line\">         |</span><br><span class=\"line\">         `-&gt; Pointer returned to the user.</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">len: 记录buf数组中已使用的字节数量 等于保存的字符串的长度 （不算结尾的\\0 标识符）</span><br><span class=\"line\">alloc: 字符串最大的容量。（除开header和最后的null终止符） </span><br><span class=\"line\">flags: 总是会占用一个字节 8bit，加上unsigned是因为flags都是非负数 ，其中的最低3个bit用来表示header的类型还有 5个bit没有使用。</span><br><span class=\"line\">buf: 字符数组，用于保存字符串。  柔性数组</span><br></pre></td></tr></table></figure>\n<p>buf的大小=alloc+1；</p>\n<p>header类型定义中，注意的地方：</p>\n<ul>\n<li><p>在各个header的定义中使用了<strong>attribute</strong> ((packed))，是为了让<strong>编译器以紧凑模式来分配内存</strong>，取消字节对齐。</p>\n<ul>\n<li>结构体的成员内存是’”连续”的，但是这个连续是以对齐的单位而言的。比如说A成员的内存是3个字节，假设对齐单位是4个字节，会给A成员多分配一个字节。A成员后面才又紧接B成员的内存。</li>\n<li>如果没有这个属性，编译器可能会为struct的字段做优化对齐，在其中填充空字节。那样的话，就不能保证header和sds的数据部分紧紧前后相邻，也不能按照固定向低地址方向偏移1个字节的方式来获取flags字段了。</li>\n</ul>\n</li>\n<li><p>在各个header的定义中最后有一个char buf[]。我们注意到这是一个没有指明长度的字符数组，这是C语言中定义字符数组的一种特殊写法，称为<strong>柔性数组</strong>（<a href=\"https://en.wikipedia.org/wiki/Flexible_array_member\" target=\"_blank\" rel=\"noopener\">flexible array member</a>），只能定义在一个结构体的最后一个字段上。它在这里只是起到一个标记的作用，表示在flags字段后面就是一个字符数组，或者说，它指明了紧跟在flags字段后面的这个字符数组在结构体中的偏移位置。而程序在为header分配的内存的时候，它并不占用内存空间。如果计算sizeof(struct sdshdr16)的值，那么结果是5个字节，其中没有buf字段。</p>\n</li>\n<li><p>sdshdr5与其它几个header结构不同，它不包含alloc字段，而长度使用flags的高5位来存储。因此，它不能为字符串分配空余空间。如果字符串需要动态增长，那么它就必然要重新分配内存才行。所以说，这种类型的sds字符串更适合存储静态的短字符串（长度小于32）。 因为长度的范围是5个bit来存储的</p>\n<script type=\"math/tex; mode=display\">\n2^5-1 = 31</script></li>\n</ul>\n<p>sds字符串的header，其实隐藏在真正的字符串数据的前面（低地址方向）。这样的一个定义，有如下几个好处</p>\n<ul>\n<li>header和数据相邻，而不用分成两块内存空间来单独分配。这有利于减少内存碎片，提高存储效率（memory efficiency）。</li>\n<li>虽然header有多个类型，但sds可以用统一的char *来表达。且它与传统的C语言字符串保持类型兼容。如果一个sds里面存储的是可打印字符串，那么我们可以直接把它传给C函数，比如使用strcmp比较字符串大小，或者使用printf进行打印。<h3 id=\"2-2-SDS与C字符串的区别\"><a href=\"#2-2-SDS与C字符串的区别\" class=\"headerlink\" title=\"2.2 SDS与C字符串的区别\"></a>2.2 SDS与C字符串的区别</h3></li>\n</ul>\n<p>c语言使用N+1长度的字符数组来表示长度为N的字符串，因为需要增加一个<code>\\0</code> 字符终止</p>\n<h4 id=\"2-2-1-常数复杂度获取字符串长度\"><a href=\"#2-2-1-常数复杂度获取字符串长度\" class=\"headerlink\" title=\"2.2.1  常数复杂度获取字符串长度\"></a>2.2.1  常数复杂度获取字符串长度</h4><p>因为c语言要知道字符串的长度只能遍历数组，所以复杂度为O(N)。 </p>\n<p>而获取sds的字符串长度，只需要返回len的值就可以了复杂度为O(1)。这样对一个非常长的字符串键反复执行STRLEN命令，也不会对系统性能造成任何影响。</p>\n<h4 id=\"2-2-2-杜绝缓冲区溢出\"><a href=\"#2-2-2-杜绝缓冲区溢出\" class=\"headerlink\" title=\"2.2.2 杜绝缓冲区溢出\"></a>2.2.2 杜绝缓冲区溢出</h4><p>C字符串不记录自身长度会带来易造成缓冲区溢出的问题。 比如使用strcat函数拼接两个字符串，被拼接的字符串要是没有提前分配空间，就会造成缓冲区溢出。（溢出的字节会导致这个字符串内存紧邻的其他字符串的内容被修改）</p>\n<p>而SDS的空间分配策略完全杜绝了发生缓冲区溢出的可能，SDS的API需要修改SDS时，会先检查空间alloc是否满足修改所需的要求。不满足的话会先将空间扩展至修改所需的大小，再执行修改。</p>\n<h4 id=\"2-2-3-减少修改字符串时带来的内存重分配次数\"><a href=\"#2-2-3-减少修改字符串时带来的内存重分配次数\" class=\"headerlink\" title=\"2.2.3 减少修改字符串时带来的内存重分配次数\"></a>2.2.3 减少修改字符串时带来的内存重分配次数</h4><p>C语言字符串用N+1个字节长的数组来保存N个字节的字符串，因为这个关联性所以每次每次增长或者缩短一个C字符串，都要对这个字符串进行一次内存重分配操作。</p>\n<ul>\n<li>执行增长操作 比如append，需要首先通过内存重分配来扩展底层数组的空间大小，否则产生缓冲区溢出</li>\n<li>执行所动操作比如截断操作trime，需要首先通过内存重分配来释放字符串不再使用的空间，否则造成内存泄漏。</li>\n</ul>\n<p>内存重分配涉及复杂的算法，并且可能需要执行系统调用，所以通常是一个比较耗时的操作。这对Redis经常用于速度要求严苛，数据被频繁修改的场合来说，是不可接受的。</p>\n<p>因此SDS通过未使用空间解除了字符串长度和底层数组长度之间的关联：buf的长度可以大于len的长度。 <strong>（4.0版本的源码还未找到对应的函数，所以可能和书上说的有变化了）</strong></p>\n<ol>\n<li><p>空间预分配 ——减少连续执行字符串增长操作所需的内存重分配次数。</p>\n<ul>\n<li><p>用于优化字符串<strong>增长</strong>操作。</p>\n<p>当需要对SDS的空间进行空间扩展时，不仅会对SDS分配修改所必需的空间，还会额外分配未使用空间。</p>\n<p>当len &lt; 1Mb时 alloc = 2*len; 当len &gt;= 1 mb时 alloc= len +1Mb。</p>\n</li>\n</ul>\n<p>源码分析</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Enlarge the free space at the end of the sds string so that the caller</span></span><br><span class=\"line\"><span class=\"comment\"> * is sure that after calling this function can overwrite up to addlen</span></span><br><span class=\"line\"><span class=\"comment\"> * bytes after the end of the string, plus one more byte for nul term.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Note: this does not change the *length* of the sds string as returned</span></span><br><span class=\"line\"><span class=\"comment\"> * by sdslen(), but only the free buffer space we have. */</span></span><br><span class=\"line\"><span class=\"function\">sds <span class=\"title\">sdsMakeRoomFor</span><span class=\"params\">(sds s, <span class=\"keyword\">size_t</span> addlen)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> *sh, *newsh;</span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> avail = sdsavail(s);</span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> len, newlen;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> type, oldtype = s[<span class=\"number\">-1</span>] &amp; SDS_TYPE_MASK;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> hdrlen;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Return ASAP if there is enough space left. */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (avail &gt;= addlen) <span class=\"keyword\">return</span> s;</span><br><span class=\"line\"></span><br><span class=\"line\">    len = sdslen(s);</span><br><span class=\"line\">    sh = (<span class=\"keyword\">char</span>*)s-sdsHdrSize(oldtype);</span><br><span class=\"line\">    newlen = (len+addlen);  <span class=\"comment\">// 预分配</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newlen &lt; SDS_MAX_PREALLOC)</span><br><span class=\"line\">        newlen *= <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        newlen += SDS_MAX_PREALLOC;</span><br><span class=\"line\"></span><br><span class=\"line\">    type = sdsReqType(newlen);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Don't use type 5: the user is appending to the string and type 5 is</span></span><br><span class=\"line\"><span class=\"comment\">     * not able to remember empty space, so sdsMakeRoomFor() must be called</span></span><br><span class=\"line\"><span class=\"comment\">     * at every appending operation. */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type == SDS_TYPE_5) type = SDS_TYPE_8;</span><br><span class=\"line\"></span><br><span class=\"line\">    hdrlen = sdsHdrSize(type);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldtype==type) &#123;</span><br><span class=\"line\">        newsh = s_realloc(sh, hdrlen+newlen+<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newsh == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        s = (<span class=\"keyword\">char</span>*)newsh+hdrlen;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">/* Since the header size changes, need to move the string forward,</span></span><br><span class=\"line\"><span class=\"comment\">         * and can't use realloc */</span></span><br><span class=\"line\">        newsh = s_malloc(hdrlen+newlen+<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newsh == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        <span class=\"built_in\">memcpy</span>((<span class=\"keyword\">char</span>*)newsh+hdrlen, s, len+<span class=\"number\">1</span>);</span><br><span class=\"line\">        s_free(sh);</span><br><span class=\"line\">        s = (<span class=\"keyword\">char</span>*)newsh+hdrlen;</span><br><span class=\"line\">        s[<span class=\"number\">-1</span>] = type;</span><br><span class=\"line\">        sdssetlen(s, len);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sdssetalloc(s, newlen);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol>\n<li><p>惰性空间释放</p>\n<ul>\n<li><p>用于优化SDS的字符串<strong>缩短</strong>操作</p>\n<p>缩短SDS保存的字符串时，并不立即使用内存重分配来回收缩短后多出来的字节，而是使用free属性，将这些字节的数量记录起来，并等待将来使用。</p>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"2-2-4-二进制安全\"><a href=\"#2-2-4-二进制安全\" class=\"headerlink\" title=\"2.2.4 二进制安全\"></a>2.2.4 二进制安全</h4><p>C字符串中的字符必须符合某种编码（如ASCII），除了末尾字符串中间不能有<code>\\0</code> 这个空字符，否则最先被程序读取的空字符将被认为是结尾，导致C字符串只能保存文本数据，而不能保存图片、音频、视频、压缩文件这样的二进制数据。</p>\n<p>所谓二进制安全：以处理二进制的方式来处理SDS存放在buf数组里的数据，程序不会对其中的数据做任何限制、过滤、或者假设，数据在写入时是什么样的，被读取是就是什么样的。因为SDS使用len来判断字符串是否结束。</p>\n<p>所以buf是字节数组，而不是字符数组。</p>\n<h4 id=\"2-2-5-兼容部分C字符串函数\"><a href=\"#2-2-5-兼容部分C字符串函数\" class=\"headerlink\" title=\"2.2.5 兼容部分C字符串函数\"></a>2.2.5 兼容部分C字符串函数</h4><p>因为遵循C字符串以<code>\\0</code>结尾的惯例，所以可以兼容<code>&lt;string.h&gt;/strcasecmp</code> ,<code>&lt;stdio.h&gt;/printf</code> 这些函数。但是是否是书上的使用结构体指针还是博客说的可以直接使用sds来调用？还需验证。</p>\n<p>书：<code>printf(&quot;%s&quot;, sds-&gt;buf)</code>  sds是指向结构体的指针。</p>\n<p>博客：<a href=\"https://blog.csdn.net/yangbodong22011/article/details/78419966\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/yangbodong22011/article/details/78419966</a>   :<code>printf(%s, sds)</code></p>\n<p>源码中是直接使用sds</p>\n<h4 id=\"2-2-6-总结\"><a href=\"#2-2-6-总结\" class=\"headerlink\" title=\"2.2.6 总结\"></a>2.2.6 总结</h4><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">C字符串</th>\n<th style=\"text-align:center\">SDS</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">获取字符串长度复杂度为O(N)</td>\n<td style=\"text-align:center\">获取字符串长度复杂度为O(1)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">API不安全，可能造成缓冲区溢出</td>\n<td style=\"text-align:center\">API安全，不会造成缓冲区溢出</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">修改字符串长度N次必然执行N次内存重分配</td>\n<td style=\"text-align:center\">最多执行N次内存重分配</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">只能保存文本数据</td>\n<td style=\"text-align:center\">二进制安全文本与二进制数据皆可</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">可使用<code>&lt;string.h&gt;</code>库中所有函数</td>\n<td style=\"text-align:center\">部分使用<code>&lt;string.h&gt;</code>库中函数</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"2-3-SDSAPI\"><a href=\"#2-3-SDSAPI\" class=\"headerlink\" title=\"2.3 SDSAPI\"></a>2.3 SDSAPI</h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">函数</th>\n<th style=\"text-align:center\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">sdslen(const sds s)</td>\n<td style=\"text-align:center\">获取sds字符串长度 O（1）</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">sdssetlen(sds s, size_t newlen)</td>\n<td style=\"text-align:center\">设置sds字符串长度</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">sdsinclen(sds s, size_t inc)</td>\n<td style=\"text-align:center\">增加sds字符串长度</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">sdsalloc(const sds s)</td>\n<td style=\"text-align:center\">获取sds字符串容量</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">sdssetalloc(sds s, size_t newlen)</td>\n<td style=\"text-align:center\">设置sds字符串容量。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">sdsavail(const sds s)</td>\n<td style=\"text-align:center\">获取sds字符串空余空间（即alloc - len）</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">sdsHdrSize(char type)</td>\n<td style=\"text-align:center\">根据header类型得到header大小</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">sdsReqType(size_t string_size)</td>\n<td style=\"text-align:center\">根据字符串数据长度计算所需要的header类型。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h4 id=\"sdsReqType函数源码分析\"><a href=\"#sdsReqType函数源码分析\" class=\"headerlink\" title=\"sdsReqType函数源码分析\"></a>sdsReqType函数源码分析</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">char</span> <span class=\"title\">sdsReqType</span><span class=\"params\">(<span class=\"keyword\">size_t</span> string_size)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (string_size &lt; <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">5</span>) <span class=\"comment\">// string_size &lt; 2^5</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> SDS_TYPE_5;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (string_size &lt; <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">8</span>)  <span class=\"comment\">//string_size &lt; 2^8</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> SDS_TYPE_8;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (string_size &lt; <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">16</span>)\t<span class=\"comment\">//string_size &lt; 2^16</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> SDS_TYPE_16;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> (LONG_MAX == LLONG_MAX)</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (string_size &lt; <span class=\"number\">1l</span>l&lt;&lt;<span class=\"number\">32</span>)  <span class=\"comment\">//string_size &lt; 2^32</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> SDS_TYPE_32;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> SDS_TYPE_64; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>采用左移来计算对应多少位的范围，而不是用2^5 这样的乘法。<strong>直接移位比使用幂来计算快很多</strong>。</p>\n<p><code>1&lt;&lt;5</code>   计算出来就是2^5 次方。1是int型，4byte32位。最低8bit位的二进制为：00000001 左移5位后变成了：00100000 对应的十进制既是32。</p>\n<p>计算n个bit位的最大值：(1&lt;&lt;n) -1</p>\n<p>但是需要注意位数不够的情况。因为1是int型，只有32个bit。所以在左移32个bit时，需要使用long long int型。用1ll来表示，此时1ll为64个bit。</p>\n<p>还得考虑机器是否为64位机器，在32位机器上LONG_MAX = 2147483647L，64位机器上LONG_MAX = 9223372036854775807L 。不论32位机器还是64位机器上 LLONG_MAX 都是9223372036854775807L 。所以当LONG_MAX == LLONG_MAX 说明字长为64bit。加上条件编译，说明在32位机器上不使用sdshdr32而直接跳到了sdshdr64，仅仅在64位机器上使用sdshdr32。原因是什么？还没想通</p>\n<h4 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h4><ol>\n<li>为什么Redis需要自己实现字符串功能，而不直接使用c语言的传统字符串？<ul>\n<li>见第二节。</li>\n</ul>\n</li>\n<li>执行SET 与GET命令的过程。</li>\n<li><code>char buf[]</code> 为什么没有指定大小？一个数组占用的内存大小<ul>\n<li>在各个header的定义中最后有一个char buf[]。我们注意到这是一个没有指明长度的字符数组，这是C语言中定义字符数组的一种特殊写法，称为柔性数组（<a href=\"https://en.wikipedia.org/wiki/Flexible_array_member\" target=\"_blank\" rel=\"noopener\">flexible array member</a>），只能定义在一个结构体的最后一个字段上。它在这里只是起到一个标记的作用，表示在flags字段后面就是一个字符数组，或者说，它指明了紧跟在flags字段后面的这个字符数组在结构体中的偏移位置。而程序在为header分配的内存的时候，它并不占用内存空间。如果计算sizeof(struct sdshdr16)的值，那么结果是5个字节，其中没有buf字段。</li>\n<li>数组内存大小为分配的的长度*数组类型的内存大小</li>\n</ul>\n</li>\n<li>为什么redis 在32位机器上不使用sdshdr32？ </li>\n</ol>\n","site":{"data":{}},"length":7568,"excerpt":"<h1 id=\"Redis设计与实现读书笔记——第二章\"><a href=\"#Redis设计与实现读书笔记——第二章\" class=\"headerlink\" title=\"Redis设计与实现读书笔记——第二章\"></a>Redis设计与实现读书笔记——第二章</h1><p>为了做Redis相关实验，在网上粗略看了Redis设计与实现的电子版，感觉收获很多，但是因为是旧版，所以买了第二版，重读第二次。</p>","more":"<h2 id=\"第二章-简单动态字符串\"><a href=\"#第二章-简单动态字符串\" class=\"headerlink\" title=\"第二章 简单动态字符串\"></a>第二章 简单动态字符串</h2><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><ol>\n<li>字符串值的键值对在底层都是由SDS实现的。</li>\n<li>sds的功能：<ol>\n<li>存储字符串值</li>\n<li>用作缓冲区<ol>\n<li>AOF模块缓冲区</li>\n<li>客户端状态的输入缓冲区</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"2-1-SDS的定义\"><a href=\"#2-1-SDS的定义\" class=\"headerlink\" title=\"2.1 SDS的定义\"></a>2.1 SDS的定义</h3><p>文件：sds.h/sdshdr 结构体 </p>\n<p>书中的为3.0版本，4.0版本有较大改动。</p>\n<p>version: redis-4.02 </p>\n<p>参考：<a href=\"https://www.cnblogs.com/chenpingzhao/p/7292182.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/chenpingzhao/p/7292182.html</a></p>\n<p><a href=\"https://www.codesheep.cn/2018/08/09/Redis%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E5%86%85%E9%83%A8%E7%BC%96%E7%A0%81%E5%89%96%E6%9E%90/\" target=\"_blank\" rel=\"noopener\">https://www.codesheep.cn/2018/08/09/Redis%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E5%86%85%E9%83%A8%E7%BC%96%E7%A0%81%E5%89%96%E6%9E%90/</a></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">char</span> *sds;  <span class=\"comment\">//注意，sds其实不是一个结构体类型，而是被typedef的char*</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Note: sdshdr5 is never used, we just access the flags byte directly.</span></span><br><span class=\"line\"><span class=\"comment\"> * However is here to document the layout of type 5 SDS strings. */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> __<span class=\"title\">attribute__</span> ((__<span class=\"title\">packed__</span>)) <span class=\"title\">sdshdr5</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> flags; <span class=\"comment\">/* 3 lsb of type, and 5 msb of string length */</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> buf[];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> __<span class=\"title\">attribute__</span> ((__<span class=\"title\">packed__</span>)) <span class=\"title\">sdshdr8</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">uint8_t</span> len; <span class=\"comment\">/* used */</span></span><br><span class=\"line\">    <span class=\"keyword\">uint8_t</span> alloc; <span class=\"comment\">/* excluding the header and null terminator */</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> flags; <span class=\"comment\">/* 3 lsb of type, 5 unused bits */</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> buf[];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> __<span class=\"title\">attribute__</span> ((__<span class=\"title\">packed__</span>)) <span class=\"title\">sdshdr16</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">uint16_t</span> len; <span class=\"comment\">/* used */</span></span><br><span class=\"line\">    <span class=\"keyword\">uint16_t</span> alloc; <span class=\"comment\">/* excluding the header and null terminator */</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> flags; <span class=\"comment\">/* 3 lsb of type, 5 unused bits */</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> buf[];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> __<span class=\"title\">attribute__</span> ((__<span class=\"title\">packed__</span>)) <span class=\"title\">sdshdr32</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> len; <span class=\"comment\">/* used */</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> alloc; <span class=\"comment\">/* excluding the header and null terminator */</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> flags; <span class=\"comment\">/* 3 lsb of type, 5 unused bits */</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> buf[];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> __<span class=\"title\">attribute__</span> ((__<span class=\"title\">packed__</span>)) <span class=\"title\">sdshdr64</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">uint64_t</span> len; <span class=\"comment\">/* used */</span></span><br><span class=\"line\">    <span class=\"keyword\">uint64_t</span> alloc; <span class=\"comment\">/* excluding the header and null terminator */</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> flags; <span class=\"comment\">/* 3 lsb of type, 5 unused bits */</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> buf[];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>除了结构体字段对len和alloc的数据类型的不同(<code>unit8, unit16， unit32, unit64</code>)，  其字段含义相差无几。其中header记录<code>len, alloc, flags</code> 信息。不同的header的目的是节省内存。<strong>header与buf数组在内存地址上前后相邻。</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+--------+-------------------------------+-----------+</span><br><span class=\"line\">| Header | Binary safe C alike string... | Null term |</span><br><span class=\"line\">+--------+-------------------------------+-----------+</span><br><span class=\"line\">         |</span><br><span class=\"line\">         `-&gt; Pointer returned to the user.</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">len: 记录buf数组中已使用的字节数量 等于保存的字符串的长度 （不算结尾的\\0 标识符）</span><br><span class=\"line\">alloc: 字符串最大的容量。（除开header和最后的null终止符） </span><br><span class=\"line\">flags: 总是会占用一个字节 8bit，加上unsigned是因为flags都是非负数 ，其中的最低3个bit用来表示header的类型还有 5个bit没有使用。</span><br><span class=\"line\">buf: 字符数组，用于保存字符串。  柔性数组</span><br></pre></td></tr></table></figure>\n<p>buf的大小=alloc+1；</p>\n<p>header类型定义中，注意的地方：</p>\n<ul>\n<li><p>在各个header的定义中使用了<strong>attribute</strong> ((packed))，是为了让<strong>编译器以紧凑模式来分配内存</strong>，取消字节对齐。</p>\n<ul>\n<li>结构体的成员内存是’”连续”的，但是这个连续是以对齐的单位而言的。比如说A成员的内存是3个字节，假设对齐单位是4个字节，会给A成员多分配一个字节。A成员后面才又紧接B成员的内存。</li>\n<li>如果没有这个属性，编译器可能会为struct的字段做优化对齐，在其中填充空字节。那样的话，就不能保证header和sds的数据部分紧紧前后相邻，也不能按照固定向低地址方向偏移1个字节的方式来获取flags字段了。</li>\n</ul>\n</li>\n<li><p>在各个header的定义中最后有一个char buf[]。我们注意到这是一个没有指明长度的字符数组，这是C语言中定义字符数组的一种特殊写法，称为<strong>柔性数组</strong>（<a href=\"https://en.wikipedia.org/wiki/Flexible_array_member\" target=\"_blank\" rel=\"noopener\">flexible array member</a>），只能定义在一个结构体的最后一个字段上。它在这里只是起到一个标记的作用，表示在flags字段后面就是一个字符数组，或者说，它指明了紧跟在flags字段后面的这个字符数组在结构体中的偏移位置。而程序在为header分配的内存的时候，它并不占用内存空间。如果计算sizeof(struct sdshdr16)的值，那么结果是5个字节，其中没有buf字段。</p>\n</li>\n<li><p>sdshdr5与其它几个header结构不同，它不包含alloc字段，而长度使用flags的高5位来存储。因此，它不能为字符串分配空余空间。如果字符串需要动态增长，那么它就必然要重新分配内存才行。所以说，这种类型的sds字符串更适合存储静态的短字符串（长度小于32）。 因为长度的范围是5个bit来存储的</p>\n<script type=\"math/tex; mode=display\">\n2^5-1 = 31</script></li>\n</ul>\n<p>sds字符串的header，其实隐藏在真正的字符串数据的前面（低地址方向）。这样的一个定义，有如下几个好处</p>\n<ul>\n<li>header和数据相邻，而不用分成两块内存空间来单独分配。这有利于减少内存碎片，提高存储效率（memory efficiency）。</li>\n<li>虽然header有多个类型，但sds可以用统一的char *来表达。且它与传统的C语言字符串保持类型兼容。如果一个sds里面存储的是可打印字符串，那么我们可以直接把它传给C函数，比如使用strcmp比较字符串大小，或者使用printf进行打印。<h3 id=\"2-2-SDS与C字符串的区别\"><a href=\"#2-2-SDS与C字符串的区别\" class=\"headerlink\" title=\"2.2 SDS与C字符串的区别\"></a>2.2 SDS与C字符串的区别</h3></li>\n</ul>\n<p>c语言使用N+1长度的字符数组来表示长度为N的字符串，因为需要增加一个<code>\\0</code> 字符终止</p>\n<h4 id=\"2-2-1-常数复杂度获取字符串长度\"><a href=\"#2-2-1-常数复杂度获取字符串长度\" class=\"headerlink\" title=\"2.2.1  常数复杂度获取字符串长度\"></a>2.2.1  常数复杂度获取字符串长度</h4><p>因为c语言要知道字符串的长度只能遍历数组，所以复杂度为O(N)。 </p>\n<p>而获取sds的字符串长度，只需要返回len的值就可以了复杂度为O(1)。这样对一个非常长的字符串键反复执行STRLEN命令，也不会对系统性能造成任何影响。</p>\n<h4 id=\"2-2-2-杜绝缓冲区溢出\"><a href=\"#2-2-2-杜绝缓冲区溢出\" class=\"headerlink\" title=\"2.2.2 杜绝缓冲区溢出\"></a>2.2.2 杜绝缓冲区溢出</h4><p>C字符串不记录自身长度会带来易造成缓冲区溢出的问题。 比如使用strcat函数拼接两个字符串，被拼接的字符串要是没有提前分配空间，就会造成缓冲区溢出。（溢出的字节会导致这个字符串内存紧邻的其他字符串的内容被修改）</p>\n<p>而SDS的空间分配策略完全杜绝了发生缓冲区溢出的可能，SDS的API需要修改SDS时，会先检查空间alloc是否满足修改所需的要求。不满足的话会先将空间扩展至修改所需的大小，再执行修改。</p>\n<h4 id=\"2-2-3-减少修改字符串时带来的内存重分配次数\"><a href=\"#2-2-3-减少修改字符串时带来的内存重分配次数\" class=\"headerlink\" title=\"2.2.3 减少修改字符串时带来的内存重分配次数\"></a>2.2.3 减少修改字符串时带来的内存重分配次数</h4><p>C语言字符串用N+1个字节长的数组来保存N个字节的字符串，因为这个关联性所以每次每次增长或者缩短一个C字符串，都要对这个字符串进行一次内存重分配操作。</p>\n<ul>\n<li>执行增长操作 比如append，需要首先通过内存重分配来扩展底层数组的空间大小，否则产生缓冲区溢出</li>\n<li>执行所动操作比如截断操作trime，需要首先通过内存重分配来释放字符串不再使用的空间，否则造成内存泄漏。</li>\n</ul>\n<p>内存重分配涉及复杂的算法，并且可能需要执行系统调用，所以通常是一个比较耗时的操作。这对Redis经常用于速度要求严苛，数据被频繁修改的场合来说，是不可接受的。</p>\n<p>因此SDS通过未使用空间解除了字符串长度和底层数组长度之间的关联：buf的长度可以大于len的长度。 <strong>（4.0版本的源码还未找到对应的函数，所以可能和书上说的有变化了）</strong></p>\n<ol>\n<li><p>空间预分配 ——减少连续执行字符串增长操作所需的内存重分配次数。</p>\n<ul>\n<li><p>用于优化字符串<strong>增长</strong>操作。</p>\n<p>当需要对SDS的空间进行空间扩展时，不仅会对SDS分配修改所必需的空间，还会额外分配未使用空间。</p>\n<p>当len &lt; 1Mb时 alloc = 2*len; 当len &gt;= 1 mb时 alloc= len +1Mb。</p>\n</li>\n</ul>\n<p>源码分析</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Enlarge the free space at the end of the sds string so that the caller</span></span><br><span class=\"line\"><span class=\"comment\"> * is sure that after calling this function can overwrite up to addlen</span></span><br><span class=\"line\"><span class=\"comment\"> * bytes after the end of the string, plus one more byte for nul term.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Note: this does not change the *length* of the sds string as returned</span></span><br><span class=\"line\"><span class=\"comment\"> * by sdslen(), but only the free buffer space we have. */</span></span><br><span class=\"line\"><span class=\"function\">sds <span class=\"title\">sdsMakeRoomFor</span><span class=\"params\">(sds s, <span class=\"keyword\">size_t</span> addlen)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> *sh, *newsh;</span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> avail = sdsavail(s);</span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> len, newlen;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> type, oldtype = s[<span class=\"number\">-1</span>] &amp; SDS_TYPE_MASK;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> hdrlen;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Return ASAP if there is enough space left. */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (avail &gt;= addlen) <span class=\"keyword\">return</span> s;</span><br><span class=\"line\"></span><br><span class=\"line\">    len = sdslen(s);</span><br><span class=\"line\">    sh = (<span class=\"keyword\">char</span>*)s-sdsHdrSize(oldtype);</span><br><span class=\"line\">    newlen = (len+addlen);  <span class=\"comment\">// 预分配</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newlen &lt; SDS_MAX_PREALLOC)</span><br><span class=\"line\">        newlen *= <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        newlen += SDS_MAX_PREALLOC;</span><br><span class=\"line\"></span><br><span class=\"line\">    type = sdsReqType(newlen);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Don't use type 5: the user is appending to the string and type 5 is</span></span><br><span class=\"line\"><span class=\"comment\">     * not able to remember empty space, so sdsMakeRoomFor() must be called</span></span><br><span class=\"line\"><span class=\"comment\">     * at every appending operation. */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type == SDS_TYPE_5) type = SDS_TYPE_8;</span><br><span class=\"line\"></span><br><span class=\"line\">    hdrlen = sdsHdrSize(type);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldtype==type) &#123;</span><br><span class=\"line\">        newsh = s_realloc(sh, hdrlen+newlen+<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newsh == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        s = (<span class=\"keyword\">char</span>*)newsh+hdrlen;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">/* Since the header size changes, need to move the string forward,</span></span><br><span class=\"line\"><span class=\"comment\">         * and can't use realloc */</span></span><br><span class=\"line\">        newsh = s_malloc(hdrlen+newlen+<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newsh == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        <span class=\"built_in\">memcpy</span>((<span class=\"keyword\">char</span>*)newsh+hdrlen, s, len+<span class=\"number\">1</span>);</span><br><span class=\"line\">        s_free(sh);</span><br><span class=\"line\">        s = (<span class=\"keyword\">char</span>*)newsh+hdrlen;</span><br><span class=\"line\">        s[<span class=\"number\">-1</span>] = type;</span><br><span class=\"line\">        sdssetlen(s, len);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sdssetalloc(s, newlen);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol>\n<li><p>惰性空间释放</p>\n<ul>\n<li><p>用于优化SDS的字符串<strong>缩短</strong>操作</p>\n<p>缩短SDS保存的字符串时，并不立即使用内存重分配来回收缩短后多出来的字节，而是使用free属性，将这些字节的数量记录起来，并等待将来使用。</p>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"2-2-4-二进制安全\"><a href=\"#2-2-4-二进制安全\" class=\"headerlink\" title=\"2.2.4 二进制安全\"></a>2.2.4 二进制安全</h4><p>C字符串中的字符必须符合某种编码（如ASCII），除了末尾字符串中间不能有<code>\\0</code> 这个空字符，否则最先被程序读取的空字符将被认为是结尾，导致C字符串只能保存文本数据，而不能保存图片、音频、视频、压缩文件这样的二进制数据。</p>\n<p>所谓二进制安全：以处理二进制的方式来处理SDS存放在buf数组里的数据，程序不会对其中的数据做任何限制、过滤、或者假设，数据在写入时是什么样的，被读取是就是什么样的。因为SDS使用len来判断字符串是否结束。</p>\n<p>所以buf是字节数组，而不是字符数组。</p>\n<h4 id=\"2-2-5-兼容部分C字符串函数\"><a href=\"#2-2-5-兼容部分C字符串函数\" class=\"headerlink\" title=\"2.2.5 兼容部分C字符串函数\"></a>2.2.5 兼容部分C字符串函数</h4><p>因为遵循C字符串以<code>\\0</code>结尾的惯例，所以可以兼容<code>&lt;string.h&gt;/strcasecmp</code> ,<code>&lt;stdio.h&gt;/printf</code> 这些函数。但是是否是书上的使用结构体指针还是博客说的可以直接使用sds来调用？还需验证。</p>\n<p>书：<code>printf(&quot;%s&quot;, sds-&gt;buf)</code>  sds是指向结构体的指针。</p>\n<p>博客：<a href=\"https://blog.csdn.net/yangbodong22011/article/details/78419966\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/yangbodong22011/article/details/78419966</a>   :<code>printf(%s, sds)</code></p>\n<p>源码中是直接使用sds</p>\n<h4 id=\"2-2-6-总结\"><a href=\"#2-2-6-总结\" class=\"headerlink\" title=\"2.2.6 总结\"></a>2.2.6 总结</h4><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">C字符串</th>\n<th style=\"text-align:center\">SDS</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">获取字符串长度复杂度为O(N)</td>\n<td style=\"text-align:center\">获取字符串长度复杂度为O(1)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">API不安全，可能造成缓冲区溢出</td>\n<td style=\"text-align:center\">API安全，不会造成缓冲区溢出</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">修改字符串长度N次必然执行N次内存重分配</td>\n<td style=\"text-align:center\">最多执行N次内存重分配</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">只能保存文本数据</td>\n<td style=\"text-align:center\">二进制安全文本与二进制数据皆可</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">可使用<code>&lt;string.h&gt;</code>库中所有函数</td>\n<td style=\"text-align:center\">部分使用<code>&lt;string.h&gt;</code>库中函数</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"2-3-SDSAPI\"><a href=\"#2-3-SDSAPI\" class=\"headerlink\" title=\"2.3 SDSAPI\"></a>2.3 SDSAPI</h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">函数</th>\n<th style=\"text-align:center\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">sdslen(const sds s)</td>\n<td style=\"text-align:center\">获取sds字符串长度 O（1）</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">sdssetlen(sds s, size_t newlen)</td>\n<td style=\"text-align:center\">设置sds字符串长度</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">sdsinclen(sds s, size_t inc)</td>\n<td style=\"text-align:center\">增加sds字符串长度</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">sdsalloc(const sds s)</td>\n<td style=\"text-align:center\">获取sds字符串容量</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">sdssetalloc(sds s, size_t newlen)</td>\n<td style=\"text-align:center\">设置sds字符串容量。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">sdsavail(const sds s)</td>\n<td style=\"text-align:center\">获取sds字符串空余空间（即alloc - len）</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">sdsHdrSize(char type)</td>\n<td style=\"text-align:center\">根据header类型得到header大小</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">sdsReqType(size_t string_size)</td>\n<td style=\"text-align:center\">根据字符串数据长度计算所需要的header类型。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h4 id=\"sdsReqType函数源码分析\"><a href=\"#sdsReqType函数源码分析\" class=\"headerlink\" title=\"sdsReqType函数源码分析\"></a>sdsReqType函数源码分析</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">char</span> <span class=\"title\">sdsReqType</span><span class=\"params\">(<span class=\"keyword\">size_t</span> string_size)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (string_size &lt; <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">5</span>) <span class=\"comment\">// string_size &lt; 2^5</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> SDS_TYPE_5;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (string_size &lt; <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">8</span>)  <span class=\"comment\">//string_size &lt; 2^8</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> SDS_TYPE_8;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (string_size &lt; <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">16</span>)\t<span class=\"comment\">//string_size &lt; 2^16</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> SDS_TYPE_16;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> (LONG_MAX == LLONG_MAX)</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (string_size &lt; <span class=\"number\">1l</span>l&lt;&lt;<span class=\"number\">32</span>)  <span class=\"comment\">//string_size &lt; 2^32</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> SDS_TYPE_32;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> SDS_TYPE_64; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>采用左移来计算对应多少位的范围，而不是用2^5 这样的乘法。<strong>直接移位比使用幂来计算快很多</strong>。</p>\n<p><code>1&lt;&lt;5</code>   计算出来就是2^5 次方。1是int型，4byte32位。最低8bit位的二进制为：00000001 左移5位后变成了：00100000 对应的十进制既是32。</p>\n<p>计算n个bit位的最大值：(1&lt;&lt;n) -1</p>\n<p>但是需要注意位数不够的情况。因为1是int型，只有32个bit。所以在左移32个bit时，需要使用long long int型。用1ll来表示，此时1ll为64个bit。</p>\n<p>还得考虑机器是否为64位机器，在32位机器上LONG_MAX = 2147483647L，64位机器上LONG_MAX = 9223372036854775807L 。不论32位机器还是64位机器上 LLONG_MAX 都是9223372036854775807L 。所以当LONG_MAX == LLONG_MAX 说明字长为64bit。加上条件编译，说明在32位机器上不使用sdshdr32而直接跳到了sdshdr64，仅仅在64位机器上使用sdshdr32。原因是什么？还没想通</p>\n<h4 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h4><ol>\n<li>为什么Redis需要自己实现字符串功能，而不直接使用c语言的传统字符串？<ul>\n<li>见第二节。</li>\n</ul>\n</li>\n<li>执行SET 与GET命令的过程。</li>\n<li><code>char buf[]</code> 为什么没有指定大小？一个数组占用的内存大小<ul>\n<li>在各个header的定义中最后有一个char buf[]。我们注意到这是一个没有指明长度的字符数组，这是C语言中定义字符数组的一种特殊写法，称为柔性数组（<a href=\"https://en.wikipedia.org/wiki/Flexible_array_member\" target=\"_blank\" rel=\"noopener\">flexible array member</a>），只能定义在一个结构体的最后一个字段上。它在这里只是起到一个标记的作用，表示在flags字段后面就是一个字符数组，或者说，它指明了紧跟在flags字段后面的这个字符数组在结构体中的偏移位置。而程序在为header分配的内存的时候，它并不占用内存空间。如果计算sizeof(struct sdshdr16)的值，那么结果是5个字节，其中没有buf字段。</li>\n<li>数组内存大小为分配的的长度*数组类型的内存大小</li>\n</ul>\n</li>\n<li>为什么redis 在32位机器上不使用sdshdr32？ </li>\n</ol>"},{"title":"Redis 设计与实现读书笔记——第四章 字典","date":"2019-03-27T02:34:14.000Z","copyright":true,"_content":"\n# Redis 设计与实现读书笔记——第四章 字典\n\n字典在Redis中应用很广泛，Redis的数据库就是用字典作为底层实现的，对数据库的增删改查操作也是构建在对字典的操作之上的。\n\n<!--more-->\n\n## 简介\n\n作用：\n\n- 数据库底层实现\n- 哈希键底层实现\n  - 哈希键包含的键值对比较多，或者键值对中的元素都是比较长的字符串时，使用字典来实现。\n- 其他功能\n\n## 4.1 字典的实现\n\n字典使用哈希表实现，一个哈希表里面可以有多个哈希表节点，一个哈希表节点就保存了字典中的一个键值对。（python的dict也是使用哈希表实现的）。\n\n哈希的本质就是预留内存空间，将需要存储的元素计算索引值(通过哈希函数)来确定对应的存储位置。当需要访问的时候可以通过哈希函数直接获得对应的地址。（编译器将变量名与地址做了映射，变量名是地址的别名，哈希则是将键与地址做了映射（通过哈希函数），大大提高了访问的效率。访问任何元素都是O（1），感觉是两个层面的映射，有点相似的感觉）。\n\n### 4.1.1 哈希表\n\nRedis使用的哈希表由dict.h/dictht 结构定义。\n\n```c\ntypedef struct dictht {\n    //哈希表数组\n    dictEntry **table;\n    // 哈希表大小\n    unsigned long size;\n    //哈希表大小掩码，用于计算索引值\n    //总是等于size-1\n    unsigned long sizemask;\n    //该哈希表已有节点的数量\n    unsigned long used;\n} dictht;\n```\n\n`typedef Oldname newname` 所以这里是`typedef struct dictht dictht` 将struct dictht 取了个别名dictht。\n\n`dictEntry **table;` 书上解释的是table是数组，但是最直接的说法是table是一个指向（指向dictEntry类型的指针）的指针，是指向指针的指针。   \n\n数组获得内存是连续的，而指针不是，所以书中说是table数组，应该是分配内存的时候给指针分配了连续的内存，但是代码没找到。\n\n关于指针和数组的异同《C专家编程》一书有讲解（第四章、第九章、第十章）。\n\n- 主要的不同：指针存放的是地址，所以需要经过两次取地址的内容。（取指针的地址中的数据（变量的地址），取变量地址的数据）。而数组是直接存储数组的首元素的数据，所以只用一次取地址中的数据\n- 数组与指针相同\n  - 表达式中的数组名就是指针\n  - C语言把数组下标作为指针的偏移量。a是数组，a[6]就是首地址偏移6。b是指针，b[6]也是指针存储的地址向后偏移6.\n  - 作为函数参数的数组名等同于指针。只是把首地址传入给了参数，并没有把数组所有的内存区域都传入。所以传入数组，就是传入指针。\n\nsizemask和哈希值一起决定一个键应该被放到table数组的那个索引上面。\n\n![一个空的哈希表](http://redisbook.com/_images/graphviz-bd3eecd927a4d8fc33b4a1c7f5957c52d67c5021.png)\n\n### 4.1.2 哈希表节点\n\n使用dictEntry结构体表示节点，每一个dictEntry结构都保存着一个键值对。\n\n```c\ntypedef struct dictEntry {\n    // 键\n    void *key;\t\n    // 值\n    union {\n        void *val;\n        uint64_t u64;\n        int64_t s64;\n        double d;\n    } v;\n    //指向下一个哈希表节点   \n    struct dictEntry *next;\n} dictEntry;\n```\n\nkey指向键值对中的键，而v则保存键值对中的值，值可以是一个指针，或者uint64_t整数，或者有符号的int64_t整数,或者是double类型（double也占8byte无论32还是64位）。\n\n`union` 是c中的共用体（联合体），和结构体非常类似。和结构体的区别是\n\n- 结构体的各个成员会占用不同的内存，互相之间没有影响；而共用体的所有成员占用同一段内存，修改一个成员会影响其余所有成员。\n- 结构体占用的内存大于等于所有成员占用的内存的总和（成员之间可能会存在缝隙），共用体占用的内存等于最长的成员占用的内存。共用体使用了内存覆盖技术，同一时刻只能保存一个成员的值，如果对新的成员赋值，就会把原来成员的值覆盖掉。 所以这里面v占用8byte内存，但是属性却可以有4中。\n\nnext指针可以将多个哈希值相同的键值对链接在一起，用来解决哈希键冲突(索引相同)的问题。链式的方法。\n\n![](http://redisbook.com/_images/graphviz-d2641d962325fd58bf15d9fffb4208f70251a999.png)\n\n### 4.1.3 字典\n\nRedis中字典由dict.h/dict 结构体表示。\n\n```C\ntypedef struct dict {\n    //类型特定函数\n    dictType *type;\n    // 私有数据\n    void *privdata;\n    // 哈希表\n    dictht ht[2];\n    //rehash 索引\n    //当rehash不在进行是值为-1。用来记录是否在rehash\n    long rehashidx; /* rehashing not in progress if rehashidx == -1 */\n    //当前迭代的个数\n    unsigned long iterators; /* number of iterators currently running */\n} dict;\n```\n\ntype 和private属性是针对不同类型的键值对（redis支持5中数据类型），为创建多态字典而设置的。\n\n- type指向dictType结构，dictType结构保存了一簇用于操作特定类型键值对的函数，Redis为不同用途的字典设置了不同的类型的特定函数。（多态的表现。）\n- privadata属性保存了需要传给哪些类型特点函数的可选参数。\n\n```c\ntypedef struct dictType {\n    // 计算哈希值的函数\n    uint64_t (*hashFunction)(const void *key);\n    // 复制键的函数\n    void *(*keyDup)(void *privdata, const void *key);\n    // 复制值的函数\n    void *(*valDup)(void *privdata, const void *obj);\n    // 对比键的函数\n    int (*keyCompare)(void *privdata, const void *key1, const void *key2);\n    // 销毁键的函数\n    void (*keyDestructor)(void *privdata, void *key);\n    // 销毁值的函数\n    void (*valDestructor)(void *privdata, void *obj);\n} dictType;\n```\n\nht是长度为2的数组，而数组的元素就是哈希表dictht。一般情况只会使用ht[0],ht[1]只会在ht[0]空间不够的时候进行rehash的时候使用。\n\nrehashidx 用来标识是否在 rehash，没有的话值为-1,有的话rehasidx用来记录rehash的进度。\n\n![](http://redisbook.com/_images/graphviz-e73003b166b90094c8c4b7abbc8d59f691f91e27.png)\n\n## 4.2 哈希算法\n\n添加一个新的键值对的时候，\n\n \t1. 需要先根据键值使用hash函数计算哈希值\n\t\t2. 哈希值和sizemask并运算求得索引值\n\t\t3. 再根据索引值将包含键值对的哈希表节点放到哈希表数组table上的对应索引值上。\n\nRedis 计算哈希值和索引值的方法为\n\n```\n# 使用字典设置的哈希函数，计算键 key 的哈希值\nhash = dict->type->hashFunction(key);\n\n# 使用哈希表的 sizemask 属性和哈希值，计算出索引值\n# 根据情况不同， ht[x] 可以是 ht[0] 或者 ht[1]\nindex = hash & dict->ht[x].sizemask;\n```\n\n哈希值用hashFunction计算，index用hash值和sizemask进行并操作。\n\n对应在源码中为：\n\n```c\n//dict.h 中：\n#define dictHashKey(d, key) (d)->type->hashFunction(key) //计算哈希值\n//dict.c 中\nidx = hash & d->ht[table].sizemask;\nh = dictHashKey(d, de->key) & d->ht[1].sizemask;\n```\n\n插入一个键值对<k0,v0>到字典中的过程为：\n\n![](http://redisbook.com/_images/graphviz-ca9c88ba1713cb595c4e0e4a17ef2042b0008621.png)\n\n先使用语句\n\n```\nhash = dict->type->hashFunction(k0);\n```\n\n计算键 `k0` 的哈希值。\n\n假设计算得出的哈希值为 `8` ， 那么程序会继续使用语句\n\n```\nindex = hash & dict->ht[0].sizemask = 8 & 3 = 0;\n```\n\n计算出键 `k0` 的索引值 `0` ， 这表示包含键值对 `k0` 和 `v0` 的节点应该被放置到哈希表数组的索引 `0` 位置上。\n\n![](http://redisbook.com/_images/graphviz-2369cb08288f5e59548355042c4c40cc4339e339.png)\n\n当字典被用作数据库的底层实现， 或者哈希键的底层实现时， Redis 使用 MurmurHash2 算法来计算键的哈希值。算法的优点\n\n-  即使输入的键是有规律的， 算法仍能给出一个很好的随机分布性， 并且算法的计算速度也非常快。\n\nMurmurHash 算法目前的最新版本为 MurmurHash3 ， 而 Redis 使用的是 MurmurHash2 ， 关于 MurmurHash 算法的更多信息可以参考该算法的主页： <http://code.google.com/p/smhasher/> 。\n\n暂时没有找到hashFunction的源码。\n\n### 4.3 键冲突\n\n两个以上的键分配到了同一个索引就产生了冲突。\n\n使用链地址法解决，相同索引上面的节点可以用next指针来链接，这样同一个索引就可以存放多个哈希表节点了。\n\n哈希表节点没有指向链表链尾的节点，所以不能迅速的知道哪个节点是尾节点，（只能通过遍历才能找到指向null的尾节点O(N)）,所以为了速度考虑总是将新节点插入到最前面（dictht->table指针指向的第一个节点就是最前面的节点。）\n\n直接使用书上的图：\n\n还未发生键冲突\n\n![](http://redisbook.com/_images/graphviz-db40aa6d0f1265d74f1c1d12b8fa074c0bcda12a.png)\n\n键冲突发生后：新键值对<k2,v2> 插入到<k1,v1>前面。\n\n![](http://redisbook.com/_images/graphviz-4b52dcf6eb0768750e1c15480be3326ca37e05b3.png)\n\n## 4.4  rehash\n\n哈希表保存的键值对会增多或者减少，需要让负载因子（负载因子(load factor)，它用来衡量哈希表的 **空/满** 程度，一定程度上也可以体现查询的效率）维持在合理的范围，所以哈希节点太多的时候需要扩容（不然冲突太多，降低效率），这些哈希表的空间动态扩容或者缩容通过rehash操作来实现。\n\n步骤为：\n\n1. 为ht[1]分配空间\n   1. 扩容时ht[1].size = 大于等于ht[0].used*2的第一个2^n。\n   2. 收缩时ht[1].size = 大于等于ht[0].used的第一个2^n。\n2. 迁移：将ht[0]上面的哈希节点重新计算哈希值与索引值并放到ht[1]哈希表上面。\n3. 迁移完成后释放ht[0],把ht[1]设置成ht[0],并在ht[1]新创建一个空白哈希表，等待下一次rehash。\n\n注意：不管是扩容还是收缩，新分配的空间都会比原来用到的(used)大。设置ht[1]为ht[0] 的时候只需要简单的将原来ht[0]上面的指针指向ht[1]就好，但是需要把原来指向的哈希表的内存给释放掉。（指针是真的强，每次指针变换指向的地址的时候，都需要考虑下之前指向的地址是否还需要，不需要就要释放，不然会造成内存泄漏）。ht[1]则重新新建个哈希表结构体，然后把ht[1]的指针指过来就好了。\n\nrehash的过程图解参考书中的图讲的很详细。\n\n![](http://redisbook.com/_images/graphviz-93608325578e8e45848938ef420115bf2227639e.png)\n\n假设程序要对图 4-8 所示字典的 `ht[0]` 进行扩展操作。\n\n1. `ht[0].used` 当前的值为 `4` ， `4 * 2 = 8` ， 而 `8` （2^3）恰好是第一个大于等于 `4` 的 `2` 的 `n` 次方， 所以程序会将 `ht[1]` 哈希表的大小设置为 `8` 。图 4-9 展示了 `ht[1]` 在分配空间之后， 字典的样子：\n\n![](http://redisbook.com/_images/graphviz-b68acb4d868ec7d79a44935ce08a159746ca58da.png)\n\n2. 将 `ht[0]` 包含的四个键值对都 rehash 到 `ht[1]` ， 如图 4-10 所示。\n\n![](http://redisbook.com/_images/graphviz-92dc47e4329eabae941cddfd727b736ef738e8cf.png)\n\n3. 释放 `ht[0]` ，并将 `ht[1]` 设置为 `ht[0]` ，然后为 `ht[1]` 分配一个空白哈希表，如图 4-11 所示。\n\n![](http://redisbook.com/_images/graphviz-fa28d986a72f1f48b83c7f959ea217b1f9527d3c.png)\n\n哈希表的扩展与收缩（源码还没找到）\n\n当以下条件中的任意一个被满足时， 程序会自动开始对哈希表执行扩展操作：\n\n1. 服务器目前没有在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 `1` ；\n2. 服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 `5` ；\n\n其中哈希表的负载因子可以通过公式得到。\n\n```\n# 负载因子 = 哈希表已保存节点数量 / 哈希表大小\nload_factor = ht[0].used / ht[0].size\n```\n\n## 4.5 渐进式rehash\n\n考虑到redis数据库中存储的键值对很多的情况，如果一次性就rehash完，庞大的计算量可能会导致服务器性能急剧下降，甚至一段时间的停止服务，（经济学中的休克时疗法？）所以rehash这个过程需要渐进式的（软着陆）。\n\n步骤：\n\n1. 为 `ht[1]` 分配空间， 让字典同时持有 `ht[0]` 和 `ht[1]` 两个哈希表。\n2. 在dict中维持一个索引计数器变量 `rehashidx` ， 并将它的值设置为 `0` ， 表示 rehash 工作正式开始。\n3. 在 rehash 进行期间， 每次对字典执行添加、删除、查找或者更新操作时， 程序除了执行指定的操作以外， 还会顺带将 `ht[0]` 哈希表在 `rehashidx` 索引上的所有键值对 rehash 到 `ht[1]` ， 当 rehash 工作完成之后， 程序将 `rehashidx` 属性的值增一。\n4. 随着字典操作的不断执行， 最终在某个时间点上， `ht[0]` 的所有键值对都会被 rehash 至 `ht[1]` ， 这时程序将 `rehashidx` 属性的值设为 `-1` ， 表示 rehash 操作已完成。\n\n注意：\n\n - rehashidx的范围是从-1到ht[0].size-1 ，也就是对应的哈希表的索引，不是之前理解的记录哈希节点的个数。\n - 迁移的过程不是拷贝，而是哈希表存储的哈希指针重新指向哈希节点的过程（指针对地址的操作）。\n\nrehash 键值对所需的计算工作均滩到对字典的每个添加、删除、查找和更新操作上， 从而避免了集中式 rehash 而带来的庞大计算量。\n\n过程图解依然copy自redis设计与实现的电子书。\n\n![](http://redisbook.com/_images/graphviz-4c43eaf38cbca10d8d368a5144db6f3c69ab3d84.png)\n\n![](http://redisbook.com/_images/graphviz-b91705b0d7a6c7fd5e37332a930534e0e136ae73.png)\n\n![](http://redisbook.com/_images/graphviz-9e2996e6ca9665776062470cdac346e8fc255374.png)\n\n![](http://redisbook.com/_images/graphviz-c871b5de1a7910aea237ca9dc86508b48da94769.png)\n\n![](http://redisbook.com/_images/graphviz-3b31e4e08cc3e212f986039eb08ae77224cdeec9.png)\n\n![](http://redisbook.com/_images/graphviz-86f810ac65c4e6ee58b17105dfeaa06973d8dd16.png)\n\n### 渐进式rehash期间的哈希表操作\n\n增删改查在两个表上操作，但是添加的新键只添加到ht[1]上，确保ht[0]最终变成空表。\n\n## 4.6 字典API\n\n\n\n## 疑惑\n\n- 为什么不直接用`dictEntry *table[]` 来表示，却要用指针？应该是指针更加灵活些？\n\n  - 因为dict有两个哈希表，而其中有个哈希表ht[1] 是只有在rehash的时候才会使用的，因此使用指针的的话，在不需要的时候将table直接指向null就可以简单的完成释放空间的操作，如果用数组的话,在分配内存的时候，就必须要为两个dictht都分配size个byte的内存存储空间，当rehash的时候size会变化，结构体中的数组就需要重新分配内存空间，而结构体的内存是相邻连续的，所以这时候要变化空间，只能重新再给这个结构体分配空间，这样效率肯定就很低了。所以使用指针的原因就是rehash的时候数组的大小会变化，如果用数组来记录就很麻烦和效率低了。\n  - 所以在dict中可以使用数组来存储dictht,因为ht这个数组是不会变化的。\n\n- 既然在rehash过程中会有增删改查的操作，那么这些操作是在哪个哈希表上进行的呢？\n\n  - 两个哈希表上面都会进行，但是增加的键值对会在ht[1] 上，不然ht[0]在减少的时候又新增键值对，不是在做无用之功吗。\n\n  \n\n  \n\n## 参考\n\n<http://redisbook.com/preview/dict/hash_algorithm.html>\n\n<https://blog.csdn.net/yangbodong22011/article/details/78467583>\n","source":"_posts/2019-03-27-Redis-设计与实现读书笔记——第四章-字典.md","raw":"---\ntitle: Redis 设计与实现读书笔记——第四章 字典\ndate: 2019-03-27 10:34:14\ncategories: 读书笔记\ntags:\n- redis\n- dict\ncopyright: true\n---\n\n# Redis 设计与实现读书笔记——第四章 字典\n\n字典在Redis中应用很广泛，Redis的数据库就是用字典作为底层实现的，对数据库的增删改查操作也是构建在对字典的操作之上的。\n\n<!--more-->\n\n## 简介\n\n作用：\n\n- 数据库底层实现\n- 哈希键底层实现\n  - 哈希键包含的键值对比较多，或者键值对中的元素都是比较长的字符串时，使用字典来实现。\n- 其他功能\n\n## 4.1 字典的实现\n\n字典使用哈希表实现，一个哈希表里面可以有多个哈希表节点，一个哈希表节点就保存了字典中的一个键值对。（python的dict也是使用哈希表实现的）。\n\n哈希的本质就是预留内存空间，将需要存储的元素计算索引值(通过哈希函数)来确定对应的存储位置。当需要访问的时候可以通过哈希函数直接获得对应的地址。（编译器将变量名与地址做了映射，变量名是地址的别名，哈希则是将键与地址做了映射（通过哈希函数），大大提高了访问的效率。访问任何元素都是O（1），感觉是两个层面的映射，有点相似的感觉）。\n\n### 4.1.1 哈希表\n\nRedis使用的哈希表由dict.h/dictht 结构定义。\n\n```c\ntypedef struct dictht {\n    //哈希表数组\n    dictEntry **table;\n    // 哈希表大小\n    unsigned long size;\n    //哈希表大小掩码，用于计算索引值\n    //总是等于size-1\n    unsigned long sizemask;\n    //该哈希表已有节点的数量\n    unsigned long used;\n} dictht;\n```\n\n`typedef Oldname newname` 所以这里是`typedef struct dictht dictht` 将struct dictht 取了个别名dictht。\n\n`dictEntry **table;` 书上解释的是table是数组，但是最直接的说法是table是一个指向（指向dictEntry类型的指针）的指针，是指向指针的指针。   \n\n数组获得内存是连续的，而指针不是，所以书中说是table数组，应该是分配内存的时候给指针分配了连续的内存，但是代码没找到。\n\n关于指针和数组的异同《C专家编程》一书有讲解（第四章、第九章、第十章）。\n\n- 主要的不同：指针存放的是地址，所以需要经过两次取地址的内容。（取指针的地址中的数据（变量的地址），取变量地址的数据）。而数组是直接存储数组的首元素的数据，所以只用一次取地址中的数据\n- 数组与指针相同\n  - 表达式中的数组名就是指针\n  - C语言把数组下标作为指针的偏移量。a是数组，a[6]就是首地址偏移6。b是指针，b[6]也是指针存储的地址向后偏移6.\n  - 作为函数参数的数组名等同于指针。只是把首地址传入给了参数，并没有把数组所有的内存区域都传入。所以传入数组，就是传入指针。\n\nsizemask和哈希值一起决定一个键应该被放到table数组的那个索引上面。\n\n![一个空的哈希表](http://redisbook.com/_images/graphviz-bd3eecd927a4d8fc33b4a1c7f5957c52d67c5021.png)\n\n### 4.1.2 哈希表节点\n\n使用dictEntry结构体表示节点，每一个dictEntry结构都保存着一个键值对。\n\n```c\ntypedef struct dictEntry {\n    // 键\n    void *key;\t\n    // 值\n    union {\n        void *val;\n        uint64_t u64;\n        int64_t s64;\n        double d;\n    } v;\n    //指向下一个哈希表节点   \n    struct dictEntry *next;\n} dictEntry;\n```\n\nkey指向键值对中的键，而v则保存键值对中的值，值可以是一个指针，或者uint64_t整数，或者有符号的int64_t整数,或者是double类型（double也占8byte无论32还是64位）。\n\n`union` 是c中的共用体（联合体），和结构体非常类似。和结构体的区别是\n\n- 结构体的各个成员会占用不同的内存，互相之间没有影响；而共用体的所有成员占用同一段内存，修改一个成员会影响其余所有成员。\n- 结构体占用的内存大于等于所有成员占用的内存的总和（成员之间可能会存在缝隙），共用体占用的内存等于最长的成员占用的内存。共用体使用了内存覆盖技术，同一时刻只能保存一个成员的值，如果对新的成员赋值，就会把原来成员的值覆盖掉。 所以这里面v占用8byte内存，但是属性却可以有4中。\n\nnext指针可以将多个哈希值相同的键值对链接在一起，用来解决哈希键冲突(索引相同)的问题。链式的方法。\n\n![](http://redisbook.com/_images/graphviz-d2641d962325fd58bf15d9fffb4208f70251a999.png)\n\n### 4.1.3 字典\n\nRedis中字典由dict.h/dict 结构体表示。\n\n```C\ntypedef struct dict {\n    //类型特定函数\n    dictType *type;\n    // 私有数据\n    void *privdata;\n    // 哈希表\n    dictht ht[2];\n    //rehash 索引\n    //当rehash不在进行是值为-1。用来记录是否在rehash\n    long rehashidx; /* rehashing not in progress if rehashidx == -1 */\n    //当前迭代的个数\n    unsigned long iterators; /* number of iterators currently running */\n} dict;\n```\n\ntype 和private属性是针对不同类型的键值对（redis支持5中数据类型），为创建多态字典而设置的。\n\n- type指向dictType结构，dictType结构保存了一簇用于操作特定类型键值对的函数，Redis为不同用途的字典设置了不同的类型的特定函数。（多态的表现。）\n- privadata属性保存了需要传给哪些类型特点函数的可选参数。\n\n```c\ntypedef struct dictType {\n    // 计算哈希值的函数\n    uint64_t (*hashFunction)(const void *key);\n    // 复制键的函数\n    void *(*keyDup)(void *privdata, const void *key);\n    // 复制值的函数\n    void *(*valDup)(void *privdata, const void *obj);\n    // 对比键的函数\n    int (*keyCompare)(void *privdata, const void *key1, const void *key2);\n    // 销毁键的函数\n    void (*keyDestructor)(void *privdata, void *key);\n    // 销毁值的函数\n    void (*valDestructor)(void *privdata, void *obj);\n} dictType;\n```\n\nht是长度为2的数组，而数组的元素就是哈希表dictht。一般情况只会使用ht[0],ht[1]只会在ht[0]空间不够的时候进行rehash的时候使用。\n\nrehashidx 用来标识是否在 rehash，没有的话值为-1,有的话rehasidx用来记录rehash的进度。\n\n![](http://redisbook.com/_images/graphviz-e73003b166b90094c8c4b7abbc8d59f691f91e27.png)\n\n## 4.2 哈希算法\n\n添加一个新的键值对的时候，\n\n \t1. 需要先根据键值使用hash函数计算哈希值\n\t\t2. 哈希值和sizemask并运算求得索引值\n\t\t3. 再根据索引值将包含键值对的哈希表节点放到哈希表数组table上的对应索引值上。\n\nRedis 计算哈希值和索引值的方法为\n\n```\n# 使用字典设置的哈希函数，计算键 key 的哈希值\nhash = dict->type->hashFunction(key);\n\n# 使用哈希表的 sizemask 属性和哈希值，计算出索引值\n# 根据情况不同， ht[x] 可以是 ht[0] 或者 ht[1]\nindex = hash & dict->ht[x].sizemask;\n```\n\n哈希值用hashFunction计算，index用hash值和sizemask进行并操作。\n\n对应在源码中为：\n\n```c\n//dict.h 中：\n#define dictHashKey(d, key) (d)->type->hashFunction(key) //计算哈希值\n//dict.c 中\nidx = hash & d->ht[table].sizemask;\nh = dictHashKey(d, de->key) & d->ht[1].sizemask;\n```\n\n插入一个键值对<k0,v0>到字典中的过程为：\n\n![](http://redisbook.com/_images/graphviz-ca9c88ba1713cb595c4e0e4a17ef2042b0008621.png)\n\n先使用语句\n\n```\nhash = dict->type->hashFunction(k0);\n```\n\n计算键 `k0` 的哈希值。\n\n假设计算得出的哈希值为 `8` ， 那么程序会继续使用语句\n\n```\nindex = hash & dict->ht[0].sizemask = 8 & 3 = 0;\n```\n\n计算出键 `k0` 的索引值 `0` ， 这表示包含键值对 `k0` 和 `v0` 的节点应该被放置到哈希表数组的索引 `0` 位置上。\n\n![](http://redisbook.com/_images/graphviz-2369cb08288f5e59548355042c4c40cc4339e339.png)\n\n当字典被用作数据库的底层实现， 或者哈希键的底层实现时， Redis 使用 MurmurHash2 算法来计算键的哈希值。算法的优点\n\n-  即使输入的键是有规律的， 算法仍能给出一个很好的随机分布性， 并且算法的计算速度也非常快。\n\nMurmurHash 算法目前的最新版本为 MurmurHash3 ， 而 Redis 使用的是 MurmurHash2 ， 关于 MurmurHash 算法的更多信息可以参考该算法的主页： <http://code.google.com/p/smhasher/> 。\n\n暂时没有找到hashFunction的源码。\n\n### 4.3 键冲突\n\n两个以上的键分配到了同一个索引就产生了冲突。\n\n使用链地址法解决，相同索引上面的节点可以用next指针来链接，这样同一个索引就可以存放多个哈希表节点了。\n\n哈希表节点没有指向链表链尾的节点，所以不能迅速的知道哪个节点是尾节点，（只能通过遍历才能找到指向null的尾节点O(N)）,所以为了速度考虑总是将新节点插入到最前面（dictht->table指针指向的第一个节点就是最前面的节点。）\n\n直接使用书上的图：\n\n还未发生键冲突\n\n![](http://redisbook.com/_images/graphviz-db40aa6d0f1265d74f1c1d12b8fa074c0bcda12a.png)\n\n键冲突发生后：新键值对<k2,v2> 插入到<k1,v1>前面。\n\n![](http://redisbook.com/_images/graphviz-4b52dcf6eb0768750e1c15480be3326ca37e05b3.png)\n\n## 4.4  rehash\n\n哈希表保存的键值对会增多或者减少，需要让负载因子（负载因子(load factor)，它用来衡量哈希表的 **空/满** 程度，一定程度上也可以体现查询的效率）维持在合理的范围，所以哈希节点太多的时候需要扩容（不然冲突太多，降低效率），这些哈希表的空间动态扩容或者缩容通过rehash操作来实现。\n\n步骤为：\n\n1. 为ht[1]分配空间\n   1. 扩容时ht[1].size = 大于等于ht[0].used*2的第一个2^n。\n   2. 收缩时ht[1].size = 大于等于ht[0].used的第一个2^n。\n2. 迁移：将ht[0]上面的哈希节点重新计算哈希值与索引值并放到ht[1]哈希表上面。\n3. 迁移完成后释放ht[0],把ht[1]设置成ht[0],并在ht[1]新创建一个空白哈希表，等待下一次rehash。\n\n注意：不管是扩容还是收缩，新分配的空间都会比原来用到的(used)大。设置ht[1]为ht[0] 的时候只需要简单的将原来ht[0]上面的指针指向ht[1]就好，但是需要把原来指向的哈希表的内存给释放掉。（指针是真的强，每次指针变换指向的地址的时候，都需要考虑下之前指向的地址是否还需要，不需要就要释放，不然会造成内存泄漏）。ht[1]则重新新建个哈希表结构体，然后把ht[1]的指针指过来就好了。\n\nrehash的过程图解参考书中的图讲的很详细。\n\n![](http://redisbook.com/_images/graphviz-93608325578e8e45848938ef420115bf2227639e.png)\n\n假设程序要对图 4-8 所示字典的 `ht[0]` 进行扩展操作。\n\n1. `ht[0].used` 当前的值为 `4` ， `4 * 2 = 8` ， 而 `8` （2^3）恰好是第一个大于等于 `4` 的 `2` 的 `n` 次方， 所以程序会将 `ht[1]` 哈希表的大小设置为 `8` 。图 4-9 展示了 `ht[1]` 在分配空间之后， 字典的样子：\n\n![](http://redisbook.com/_images/graphviz-b68acb4d868ec7d79a44935ce08a159746ca58da.png)\n\n2. 将 `ht[0]` 包含的四个键值对都 rehash 到 `ht[1]` ， 如图 4-10 所示。\n\n![](http://redisbook.com/_images/graphviz-92dc47e4329eabae941cddfd727b736ef738e8cf.png)\n\n3. 释放 `ht[0]` ，并将 `ht[1]` 设置为 `ht[0]` ，然后为 `ht[1]` 分配一个空白哈希表，如图 4-11 所示。\n\n![](http://redisbook.com/_images/graphviz-fa28d986a72f1f48b83c7f959ea217b1f9527d3c.png)\n\n哈希表的扩展与收缩（源码还没找到）\n\n当以下条件中的任意一个被满足时， 程序会自动开始对哈希表执行扩展操作：\n\n1. 服务器目前没有在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 `1` ；\n2. 服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 `5` ；\n\n其中哈希表的负载因子可以通过公式得到。\n\n```\n# 负载因子 = 哈希表已保存节点数量 / 哈希表大小\nload_factor = ht[0].used / ht[0].size\n```\n\n## 4.5 渐进式rehash\n\n考虑到redis数据库中存储的键值对很多的情况，如果一次性就rehash完，庞大的计算量可能会导致服务器性能急剧下降，甚至一段时间的停止服务，（经济学中的休克时疗法？）所以rehash这个过程需要渐进式的（软着陆）。\n\n步骤：\n\n1. 为 `ht[1]` 分配空间， 让字典同时持有 `ht[0]` 和 `ht[1]` 两个哈希表。\n2. 在dict中维持一个索引计数器变量 `rehashidx` ， 并将它的值设置为 `0` ， 表示 rehash 工作正式开始。\n3. 在 rehash 进行期间， 每次对字典执行添加、删除、查找或者更新操作时， 程序除了执行指定的操作以外， 还会顺带将 `ht[0]` 哈希表在 `rehashidx` 索引上的所有键值对 rehash 到 `ht[1]` ， 当 rehash 工作完成之后， 程序将 `rehashidx` 属性的值增一。\n4. 随着字典操作的不断执行， 最终在某个时间点上， `ht[0]` 的所有键值对都会被 rehash 至 `ht[1]` ， 这时程序将 `rehashidx` 属性的值设为 `-1` ， 表示 rehash 操作已完成。\n\n注意：\n\n - rehashidx的范围是从-1到ht[0].size-1 ，也就是对应的哈希表的索引，不是之前理解的记录哈希节点的个数。\n - 迁移的过程不是拷贝，而是哈希表存储的哈希指针重新指向哈希节点的过程（指针对地址的操作）。\n\nrehash 键值对所需的计算工作均滩到对字典的每个添加、删除、查找和更新操作上， 从而避免了集中式 rehash 而带来的庞大计算量。\n\n过程图解依然copy自redis设计与实现的电子书。\n\n![](http://redisbook.com/_images/graphviz-4c43eaf38cbca10d8d368a5144db6f3c69ab3d84.png)\n\n![](http://redisbook.com/_images/graphviz-b91705b0d7a6c7fd5e37332a930534e0e136ae73.png)\n\n![](http://redisbook.com/_images/graphviz-9e2996e6ca9665776062470cdac346e8fc255374.png)\n\n![](http://redisbook.com/_images/graphviz-c871b5de1a7910aea237ca9dc86508b48da94769.png)\n\n![](http://redisbook.com/_images/graphviz-3b31e4e08cc3e212f986039eb08ae77224cdeec9.png)\n\n![](http://redisbook.com/_images/graphviz-86f810ac65c4e6ee58b17105dfeaa06973d8dd16.png)\n\n### 渐进式rehash期间的哈希表操作\n\n增删改查在两个表上操作，但是添加的新键只添加到ht[1]上，确保ht[0]最终变成空表。\n\n## 4.6 字典API\n\n\n\n## 疑惑\n\n- 为什么不直接用`dictEntry *table[]` 来表示，却要用指针？应该是指针更加灵活些？\n\n  - 因为dict有两个哈希表，而其中有个哈希表ht[1] 是只有在rehash的时候才会使用的，因此使用指针的的话，在不需要的时候将table直接指向null就可以简单的完成释放空间的操作，如果用数组的话,在分配内存的时候，就必须要为两个dictht都分配size个byte的内存存储空间，当rehash的时候size会变化，结构体中的数组就需要重新分配内存空间，而结构体的内存是相邻连续的，所以这时候要变化空间，只能重新再给这个结构体分配空间，这样效率肯定就很低了。所以使用指针的原因就是rehash的时候数组的大小会变化，如果用数组来记录就很麻烦和效率低了。\n  - 所以在dict中可以使用数组来存储dictht,因为ht这个数组是不会变化的。\n\n- 既然在rehash过程中会有增删改查的操作，那么这些操作是在哪个哈希表上进行的呢？\n\n  - 两个哈希表上面都会进行，但是增加的键值对会在ht[1] 上，不然ht[0]在减少的时候又新增键值对，不是在做无用之功吗。\n\n  \n\n  \n\n## 参考\n\n<http://redisbook.com/preview/dict/hash_algorithm.html>\n\n<https://blog.csdn.net/yangbodong22011/article/details/78467583>\n","slug":"2019-03-27-Redis-设计与实现读书笔记——第四章-字典","published":1,"updated":"2019-11-08T13:13:42.256Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2yelxgy0006m8tzvlupb8ja","content":"<h1 id=\"Redis-设计与实现读书笔记——第四章-字典\"><a href=\"#Redis-设计与实现读书笔记——第四章-字典\" class=\"headerlink\" title=\"Redis 设计与实现读书笔记——第四章 字典\"></a>Redis 设计与实现读书笔记——第四章 字典</h1><p>字典在Redis中应用很广泛，Redis的数据库就是用字典作为底层实现的，对数据库的增删改查操作也是构建在对字典的操作之上的。</p>\n<a id=\"more\"></a>\n<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>作用：</p>\n<ul>\n<li>数据库底层实现</li>\n<li>哈希键底层实现<ul>\n<li>哈希键包含的键值对比较多，或者键值对中的元素都是比较长的字符串时，使用字典来实现。</li>\n</ul>\n</li>\n<li>其他功能</li>\n</ul>\n<h2 id=\"4-1-字典的实现\"><a href=\"#4-1-字典的实现\" class=\"headerlink\" title=\"4.1 字典的实现\"></a>4.1 字典的实现</h2><p>字典使用哈希表实现，一个哈希表里面可以有多个哈希表节点，一个哈希表节点就保存了字典中的一个键值对。（python的dict也是使用哈希表实现的）。</p>\n<p>哈希的本质就是预留内存空间，将需要存储的元素计算索引值(通过哈希函数)来确定对应的存储位置。当需要访问的时候可以通过哈希函数直接获得对应的地址。（编译器将变量名与地址做了映射，变量名是地址的别名，哈希则是将键与地址做了映射（通过哈希函数），大大提高了访问的效率。访问任何元素都是O（1），感觉是两个层面的映射，有点相似的感觉）。</p>\n<h3 id=\"4-1-1-哈希表\"><a href=\"#4-1-1-哈希表\" class=\"headerlink\" title=\"4.1.1 哈希表\"></a>4.1.1 哈希表</h3><p>Redis使用的哈希表由dict.h/dictht 结构定义。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictht</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//哈希表数组</span></span><br><span class=\"line\">    dictEntry **table;</span><br><span class=\"line\">    <span class=\"comment\">// 哈希表大小</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> size;</span><br><span class=\"line\">    <span class=\"comment\">//哈希表大小掩码，用于计算索引值</span></span><br><span class=\"line\">    <span class=\"comment\">//总是等于size-1</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> sizemask;</span><br><span class=\"line\">    <span class=\"comment\">//该哈希表已有节点的数量</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> used;</span><br><span class=\"line\">&#125; dictht;</span><br></pre></td></tr></table></figure>\n<p><code>typedef Oldname newname</code> 所以这里是<code>typedef struct dictht dictht</code> 将struct dictht 取了个别名dictht。</p>\n<p><code>dictEntry **table;</code> 书上解释的是table是数组，但是最直接的说法是table是一个指向（指向dictEntry类型的指针）的指针，是指向指针的指针。   </p>\n<p>数组获得内存是连续的，而指针不是，所以书中说是table数组，应该是分配内存的时候给指针分配了连续的内存，但是代码没找到。</p>\n<p>关于指针和数组的异同《C专家编程》一书有讲解（第四章、第九章、第十章）。</p>\n<ul>\n<li>主要的不同：指针存放的是地址，所以需要经过两次取地址的内容。（取指针的地址中的数据（变量的地址），取变量地址的数据）。而数组是直接存储数组的首元素的数据，所以只用一次取地址中的数据</li>\n<li>数组与指针相同<ul>\n<li>表达式中的数组名就是指针</li>\n<li>C语言把数组下标作为指针的偏移量。a是数组，a[6]就是首地址偏移6。b是指针，b[6]也是指针存储的地址向后偏移6.</li>\n<li>作为函数参数的数组名等同于指针。只是把首地址传入给了参数，并没有把数组所有的内存区域都传入。所以传入数组，就是传入指针。</li>\n</ul>\n</li>\n</ul>\n<p>sizemask和哈希值一起决定一个键应该被放到table数组的那个索引上面。</p>\n<p><img src=\"http://redisbook.com/_images/graphviz-bd3eecd927a4d8fc33b4a1c7f5957c52d67c5021.png\" alt=\"一个空的哈希表\"></p>\n<h3 id=\"4-1-2-哈希表节点\"><a href=\"#4-1-2-哈希表节点\" class=\"headerlink\" title=\"4.1.2 哈希表节点\"></a>4.1.2 哈希表节点</h3><p>使用dictEntry结构体表示节点，每一个dictEntry结构都保存着一个键值对。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictEntry</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 键</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *key;\t</span><br><span class=\"line\">    <span class=\"comment\">// 值</span></span><br><span class=\"line\">    <span class=\"keyword\">union</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">void</span> *val;</span><br><span class=\"line\">        <span class=\"keyword\">uint64_t</span> u64;</span><br><span class=\"line\">        <span class=\"keyword\">int64_t</span> s64;</span><br><span class=\"line\">        <span class=\"keyword\">double</span> d;</span><br><span class=\"line\">    &#125; v;</span><br><span class=\"line\">    <span class=\"comment\">//指向下一个哈希表节点   </span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictEntry</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125; dictEntry;</span><br></pre></td></tr></table></figure>\n<p>key指向键值对中的键，而v则保存键值对中的值，值可以是一个指针，或者uint64_t整数，或者有符号的int64_t整数,或者是double类型（double也占8byte无论32还是64位）。</p>\n<p><code>union</code> 是c中的共用体（联合体），和结构体非常类似。和结构体的区别是</p>\n<ul>\n<li>结构体的各个成员会占用不同的内存，互相之间没有影响；而共用体的所有成员占用同一段内存，修改一个成员会影响其余所有成员。</li>\n<li>结构体占用的内存大于等于所有成员占用的内存的总和（成员之间可能会存在缝隙），共用体占用的内存等于最长的成员占用的内存。共用体使用了内存覆盖技术，同一时刻只能保存一个成员的值，如果对新的成员赋值，就会把原来成员的值覆盖掉。 所以这里面v占用8byte内存，但是属性却可以有4中。</li>\n</ul>\n<p>next指针可以将多个哈希值相同的键值对链接在一起，用来解决哈希键冲突(索引相同)的问题。链式的方法。</p>\n<p><img src=\"http://redisbook.com/_images/graphviz-d2641d962325fd58bf15d9fffb4208f70251a999.png\" alt=\"\"></p>\n<h3 id=\"4-1-3-字典\"><a href=\"#4-1-3-字典\" class=\"headerlink\" title=\"4.1.3 字典\"></a>4.1.3 字典</h3><p>Redis中字典由dict.h/dict 结构体表示。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dict</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//类型特定函数</span></span><br><span class=\"line\">    dictType *type;</span><br><span class=\"line\">    <span class=\"comment\">// 私有数据</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *privdata;</span><br><span class=\"line\">    <span class=\"comment\">// 哈希表</span></span><br><span class=\"line\">    dictht ht[<span class=\"number\">2</span>];</span><br><span class=\"line\">    <span class=\"comment\">//rehash 索引</span></span><br><span class=\"line\">    <span class=\"comment\">//当rehash不在进行是值为-1。用来记录是否在rehash</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> rehashidx; <span class=\"comment\">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class=\"line\">    <span class=\"comment\">//当前迭代的个数</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> iterators; <span class=\"comment\">/* number of iterators currently running */</span></span><br><span class=\"line\">&#125; dict;</span><br></pre></td></tr></table></figure>\n<p>type 和private属性是针对不同类型的键值对（redis支持5中数据类型），为创建多态字典而设置的。</p>\n<ul>\n<li>type指向dictType结构，dictType结构保存了一簇用于操作特定类型键值对的函数，Redis为不同用途的字典设置了不同的类型的特定函数。（多态的表现。）</li>\n<li>privadata属性保存了需要传给哪些类型特点函数的可选参数。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictType</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 计算哈希值的函数</span></span><br><span class=\"line\">    <span class=\"keyword\">uint64_t</span> (*hashFunction)(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *key);</span><br><span class=\"line\">    <span class=\"comment\">// 复制键的函数</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *(*keyDup)(<span class=\"keyword\">void</span> *privdata, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *key);</span><br><span class=\"line\">    <span class=\"comment\">// 复制值的函数</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *(*valDup)(<span class=\"keyword\">void</span> *privdata, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *obj);</span><br><span class=\"line\">    <span class=\"comment\">// 对比键的函数</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*keyCompare)(<span class=\"keyword\">void</span> *privdata, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *key1, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *key2);</span><br><span class=\"line\">    <span class=\"comment\">// 销毁键的函数</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*keyDestructor)(<span class=\"keyword\">void</span> *privdata, <span class=\"keyword\">void</span> *key);</span><br><span class=\"line\">    <span class=\"comment\">// 销毁值的函数</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*valDestructor)(<span class=\"keyword\">void</span> *privdata, <span class=\"keyword\">void</span> *obj);</span><br><span class=\"line\">&#125; dictType;</span><br></pre></td></tr></table></figure>\n<p>ht是长度为2的数组，而数组的元素就是哈希表dictht。一般情况只会使用ht[0],ht[1]只会在ht[0]空间不够的时候进行rehash的时候使用。</p>\n<p>rehashidx 用来标识是否在 rehash，没有的话值为-1,有的话rehasidx用来记录rehash的进度。</p>\n<p><img src=\"http://redisbook.com/_images/graphviz-e73003b166b90094c8c4b7abbc8d59f691f91e27.png\" alt=\"\"></p>\n<h2 id=\"4-2-哈希算法\"><a href=\"#4-2-哈希算法\" class=\"headerlink\" title=\"4.2 哈希算法\"></a>4.2 哈希算法</h2><p>添加一个新的键值对的时候，</p>\n<pre><code> 1. 需要先根据键值使用hash函数计算哈希值\n    2. 哈希值和sizemask并运算求得索引值\n    3. 再根据索引值将包含键值对的哈希表节点放到哈希表数组table上的对应索引值上。\n</code></pre><p>Redis 计算哈希值和索引值的方法为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 使用字典设置的哈希函数，计算键 key 的哈希值</span><br><span class=\"line\">hash = dict-&gt;type-&gt;hashFunction(key);</span><br><span class=\"line\"></span><br><span class=\"line\"># 使用哈希表的 sizemask 属性和哈希值，计算出索引值</span><br><span class=\"line\"># 根据情况不同， ht[x] 可以是 ht[0] 或者 ht[1]</span><br><span class=\"line\">index = hash &amp; dict-&gt;ht[x].sizemask;</span><br></pre></td></tr></table></figure>\n<p>哈希值用hashFunction计算，index用hash值和sizemask进行并操作。</p>\n<p>对应在源码中为：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//dict.h 中：</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> dictHashKey(d, key) (d)-&gt;type-&gt;hashFunction(key) <span class=\"comment\">//计算哈希值</span></span></span><br><span class=\"line\"><span class=\"comment\">//dict.c 中</span></span><br><span class=\"line\">idx = hash &amp; d-&gt;ht[table].sizemask;</span><br><span class=\"line\">h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[<span class=\"number\">1</span>].sizemask;</span><br></pre></td></tr></table></figure>\n<p>插入一个键值对<k0,v0>到字典中的过程为：</k0,v0></p>\n<p><img src=\"http://redisbook.com/_images/graphviz-ca9c88ba1713cb595c4e0e4a17ef2042b0008621.png\" alt=\"\"></p>\n<p>先使用语句</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hash = dict-&gt;type-&gt;hashFunction(k0);</span><br></pre></td></tr></table></figure>\n<p>计算键 <code>k0</code> 的哈希值。</p>\n<p>假设计算得出的哈希值为 <code>8</code> ， 那么程序会继续使用语句</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">index = hash &amp; dict-&gt;ht[0].sizemask = 8 &amp; 3 = 0;</span><br></pre></td></tr></table></figure>\n<p>计算出键 <code>k0</code> 的索引值 <code>0</code> ， 这表示包含键值对 <code>k0</code> 和 <code>v0</code> 的节点应该被放置到哈希表数组的索引 <code>0</code> 位置上。</p>\n<p><img src=\"http://redisbook.com/_images/graphviz-2369cb08288f5e59548355042c4c40cc4339e339.png\" alt=\"\"></p>\n<p>当字典被用作数据库的底层实现， 或者哈希键的底层实现时， Redis 使用 MurmurHash2 算法来计算键的哈希值。算法的优点</p>\n<ul>\n<li>即使输入的键是有规律的， 算法仍能给出一个很好的随机分布性， 并且算法的计算速度也非常快。</li>\n</ul>\n<p>MurmurHash 算法目前的最新版本为 MurmurHash3 ， 而 Redis 使用的是 MurmurHash2 ， 关于 MurmurHash 算法的更多信息可以参考该算法的主页： <a href=\"http://code.google.com/p/smhasher/\" target=\"_blank\" rel=\"noopener\">http://code.google.com/p/smhasher/</a> 。</p>\n<p>暂时没有找到hashFunction的源码。</p>\n<h3 id=\"4-3-键冲突\"><a href=\"#4-3-键冲突\" class=\"headerlink\" title=\"4.3 键冲突\"></a>4.3 键冲突</h3><p>两个以上的键分配到了同一个索引就产生了冲突。</p>\n<p>使用链地址法解决，相同索引上面的节点可以用next指针来链接，这样同一个索引就可以存放多个哈希表节点了。</p>\n<p>哈希表节点没有指向链表链尾的节点，所以不能迅速的知道哪个节点是尾节点，（只能通过遍历才能找到指向null的尾节点O(N)）,所以为了速度考虑总是将新节点插入到最前面（dictht-&gt;table指针指向的第一个节点就是最前面的节点。）</p>\n<p>直接使用书上的图：</p>\n<p>还未发生键冲突</p>\n<p><img src=\"http://redisbook.com/_images/graphviz-db40aa6d0f1265d74f1c1d12b8fa074c0bcda12a.png\" alt=\"\"></p>\n<p>键冲突发生后：新键值对<k2,v2> 插入到<k1,v1>前面。</k1,v1></k2,v2></p>\n<p><img src=\"http://redisbook.com/_images/graphviz-4b52dcf6eb0768750e1c15480be3326ca37e05b3.png\" alt=\"\"></p>\n<h2 id=\"4-4-rehash\"><a href=\"#4-4-rehash\" class=\"headerlink\" title=\"4.4  rehash\"></a>4.4  rehash</h2><p>哈希表保存的键值对会增多或者减少，需要让负载因子（负载因子(load factor)，它用来衡量哈希表的 <strong>空/满</strong> 程度，一定程度上也可以体现查询的效率）维持在合理的范围，所以哈希节点太多的时候需要扩容（不然冲突太多，降低效率），这些哈希表的空间动态扩容或者缩容通过rehash操作来实现。</p>\n<p>步骤为：</p>\n<ol>\n<li>为ht[1]分配空间<ol>\n<li>扩容时ht[1].size = 大于等于ht[0].used*2的第一个2^n。</li>\n<li>收缩时ht[1].size = 大于等于ht[0].used的第一个2^n。</li>\n</ol>\n</li>\n<li>迁移：将ht[0]上面的哈希节点重新计算哈希值与索引值并放到ht[1]哈希表上面。</li>\n<li>迁移完成后释放ht[0],把ht[1]设置成ht[0],并在ht[1]新创建一个空白哈希表，等待下一次rehash。</li>\n</ol>\n<p>注意：不管是扩容还是收缩，新分配的空间都会比原来用到的(used)大。设置ht[1]为ht[0] 的时候只需要简单的将原来ht[0]上面的指针指向ht[1]就好，但是需要把原来指向的哈希表的内存给释放掉。（指针是真的强，每次指针变换指向的地址的时候，都需要考虑下之前指向的地址是否还需要，不需要就要释放，不然会造成内存泄漏）。ht[1]则重新新建个哈希表结构体，然后把ht[1]的指针指过来就好了。</p>\n<p>rehash的过程图解参考书中的图讲的很详细。</p>\n<p><img src=\"http://redisbook.com/_images/graphviz-93608325578e8e45848938ef420115bf2227639e.png\" alt=\"\"></p>\n<p>假设程序要对图 4-8 所示字典的 <code>ht[0]</code> 进行扩展操作。</p>\n<ol>\n<li><code>ht[0].used</code> 当前的值为 <code>4</code> ， <code>4 * 2 = 8</code> ， 而 <code>8</code> （2^3）恰好是第一个大于等于 <code>4</code> 的 <code>2</code> 的 <code>n</code> 次方， 所以程序会将 <code>ht[1]</code> 哈希表的大小设置为 <code>8</code> 。图 4-9 展示了 <code>ht[1]</code> 在分配空间之后， 字典的样子：</li>\n</ol>\n<p><img src=\"http://redisbook.com/_images/graphviz-b68acb4d868ec7d79a44935ce08a159746ca58da.png\" alt=\"\"></p>\n<ol>\n<li>将 <code>ht[0]</code> 包含的四个键值对都 rehash 到 <code>ht[1]</code> ， 如图 4-10 所示。</li>\n</ol>\n<p><img src=\"http://redisbook.com/_images/graphviz-92dc47e4329eabae941cddfd727b736ef738e8cf.png\" alt=\"\"></p>\n<ol>\n<li>释放 <code>ht[0]</code> ，并将 <code>ht[1]</code> 设置为 <code>ht[0]</code> ，然后为 <code>ht[1]</code> 分配一个空白哈希表，如图 4-11 所示。</li>\n</ol>\n<p><img src=\"http://redisbook.com/_images/graphviz-fa28d986a72f1f48b83c7f959ea217b1f9527d3c.png\" alt=\"\"></p>\n<p>哈希表的扩展与收缩（源码还没找到）</p>\n<p>当以下条件中的任意一个被满足时， 程序会自动开始对哈希表执行扩展操作：</p>\n<ol>\n<li>服务器目前没有在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 <code>1</code> ；</li>\n<li>服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 <code>5</code> ；</li>\n</ol>\n<p>其中哈希表的负载因子可以通过公式得到。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 负载因子 = 哈希表已保存节点数量 / 哈希表大小</span><br><span class=\"line\">load_factor = ht[0].used / ht[0].size</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-5-渐进式rehash\"><a href=\"#4-5-渐进式rehash\" class=\"headerlink\" title=\"4.5 渐进式rehash\"></a>4.5 渐进式rehash</h2><p>考虑到redis数据库中存储的键值对很多的情况，如果一次性就rehash完，庞大的计算量可能会导致服务器性能急剧下降，甚至一段时间的停止服务，（经济学中的休克时疗法？）所以rehash这个过程需要渐进式的（软着陆）。</p>\n<p>步骤：</p>\n<ol>\n<li>为 <code>ht[1]</code> 分配空间， 让字典同时持有 <code>ht[0]</code> 和 <code>ht[1]</code> 两个哈希表。</li>\n<li>在dict中维持一个索引计数器变量 <code>rehashidx</code> ， 并将它的值设置为 <code>0</code> ， 表示 rehash 工作正式开始。</li>\n<li>在 rehash 进行期间， 每次对字典执行添加、删除、查找或者更新操作时， 程序除了执行指定的操作以外， 还会顺带将 <code>ht[0]</code> 哈希表在 <code>rehashidx</code> 索引上的所有键值对 rehash 到 <code>ht[1]</code> ， 当 rehash 工作完成之后， 程序将 <code>rehashidx</code> 属性的值增一。</li>\n<li>随着字典操作的不断执行， 最终在某个时间点上， <code>ht[0]</code> 的所有键值对都会被 rehash 至 <code>ht[1]</code> ， 这时程序将 <code>rehashidx</code> 属性的值设为 <code>-1</code> ， 表示 rehash 操作已完成。</li>\n</ol>\n<p>注意：</p>\n<ul>\n<li>rehashidx的范围是从-1到ht[0].size-1 ，也就是对应的哈希表的索引，不是之前理解的记录哈希节点的个数。</li>\n<li>迁移的过程不是拷贝，而是哈希表存储的哈希指针重新指向哈希节点的过程（指针对地址的操作）。</li>\n</ul>\n<p>rehash 键值对所需的计算工作均滩到对字典的每个添加、删除、查找和更新操作上， 从而避免了集中式 rehash 而带来的庞大计算量。</p>\n<p>过程图解依然copy自redis设计与实现的电子书。</p>\n<p><img src=\"http://redisbook.com/_images/graphviz-4c43eaf38cbca10d8d368a5144db6f3c69ab3d84.png\" alt=\"\"></p>\n<p><img src=\"http://redisbook.com/_images/graphviz-b91705b0d7a6c7fd5e37332a930534e0e136ae73.png\" alt=\"\"></p>\n<p><img src=\"http://redisbook.com/_images/graphviz-9e2996e6ca9665776062470cdac346e8fc255374.png\" alt=\"\"></p>\n<p><img src=\"http://redisbook.com/_images/graphviz-c871b5de1a7910aea237ca9dc86508b48da94769.png\" alt=\"\"></p>\n<p><img src=\"http://redisbook.com/_images/graphviz-3b31e4e08cc3e212f986039eb08ae77224cdeec9.png\" alt=\"\"></p>\n<p><img src=\"http://redisbook.com/_images/graphviz-86f810ac65c4e6ee58b17105dfeaa06973d8dd16.png\" alt=\"\"></p>\n<h3 id=\"渐进式rehash期间的哈希表操作\"><a href=\"#渐进式rehash期间的哈希表操作\" class=\"headerlink\" title=\"渐进式rehash期间的哈希表操作\"></a>渐进式rehash期间的哈希表操作</h3><p>增删改查在两个表上操作，但是添加的新键只添加到ht[1]上，确保ht[0]最终变成空表。</p>\n<h2 id=\"4-6-字典API\"><a href=\"#4-6-字典API\" class=\"headerlink\" title=\"4.6 字典API\"></a>4.6 字典API</h2><h2 id=\"疑惑\"><a href=\"#疑惑\" class=\"headerlink\" title=\"疑惑\"></a>疑惑</h2><ul>\n<li><p>为什么不直接用<code>dictEntry *table[]</code> 来表示，却要用指针？应该是指针更加灵活些？</p>\n<ul>\n<li>因为dict有两个哈希表，而其中有个哈希表ht[1] 是只有在rehash的时候才会使用的，因此使用指针的的话，在不需要的时候将table直接指向null就可以简单的完成释放空间的操作，如果用数组的话,在分配内存的时候，就必须要为两个dictht都分配size个byte的内存存储空间，当rehash的时候size会变化，结构体中的数组就需要重新分配内存空间，而结构体的内存是相邻连续的，所以这时候要变化空间，只能重新再给这个结构体分配空间，这样效率肯定就很低了。所以使用指针的原因就是rehash的时候数组的大小会变化，如果用数组来记录就很麻烦和效率低了。</li>\n<li>所以在dict中可以使用数组来存储dictht,因为ht这个数组是不会变化的。</li>\n</ul>\n</li>\n<li><p>既然在rehash过程中会有增删改查的操作，那么这些操作是在哪个哈希表上进行的呢？</p>\n<ul>\n<li>两个哈希表上面都会进行，但是增加的键值对会在ht[1] 上，不然ht[0]在减少的时候又新增键值对，不是在做无用之功吗。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://redisbook.com/preview/dict/hash_algorithm.html\" target=\"_blank\" rel=\"noopener\">http://redisbook.com/preview/dict/hash_algorithm.html</a></p>\n<p><a href=\"https://blog.csdn.net/yangbodong22011/article/details/78467583\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/yangbodong22011/article/details/78467583</a></p>\n","site":{"data":{}},"length":6191,"excerpt":"<h1 id=\"Redis-设计与实现读书笔记——第四章-字典\"><a href=\"#Redis-设计与实现读书笔记——第四章-字典\" class=\"headerlink\" title=\"Redis 设计与实现读书笔记——第四章 字典\"></a>Redis 设计与实现读书笔记——第四章 字典</h1><p>字典在Redis中应用很广泛，Redis的数据库就是用字典作为底层实现的，对数据库的增删改查操作也是构建在对字典的操作之上的。</p>","more":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>作用：</p>\n<ul>\n<li>数据库底层实现</li>\n<li>哈希键底层实现<ul>\n<li>哈希键包含的键值对比较多，或者键值对中的元素都是比较长的字符串时，使用字典来实现。</li>\n</ul>\n</li>\n<li>其他功能</li>\n</ul>\n<h2 id=\"4-1-字典的实现\"><a href=\"#4-1-字典的实现\" class=\"headerlink\" title=\"4.1 字典的实现\"></a>4.1 字典的实现</h2><p>字典使用哈希表实现，一个哈希表里面可以有多个哈希表节点，一个哈希表节点就保存了字典中的一个键值对。（python的dict也是使用哈希表实现的）。</p>\n<p>哈希的本质就是预留内存空间，将需要存储的元素计算索引值(通过哈希函数)来确定对应的存储位置。当需要访问的时候可以通过哈希函数直接获得对应的地址。（编译器将变量名与地址做了映射，变量名是地址的别名，哈希则是将键与地址做了映射（通过哈希函数），大大提高了访问的效率。访问任何元素都是O（1），感觉是两个层面的映射，有点相似的感觉）。</p>\n<h3 id=\"4-1-1-哈希表\"><a href=\"#4-1-1-哈希表\" class=\"headerlink\" title=\"4.1.1 哈希表\"></a>4.1.1 哈希表</h3><p>Redis使用的哈希表由dict.h/dictht 结构定义。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictht</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//哈希表数组</span></span><br><span class=\"line\">    dictEntry **table;</span><br><span class=\"line\">    <span class=\"comment\">// 哈希表大小</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> size;</span><br><span class=\"line\">    <span class=\"comment\">//哈希表大小掩码，用于计算索引值</span></span><br><span class=\"line\">    <span class=\"comment\">//总是等于size-1</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> sizemask;</span><br><span class=\"line\">    <span class=\"comment\">//该哈希表已有节点的数量</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> used;</span><br><span class=\"line\">&#125; dictht;</span><br></pre></td></tr></table></figure>\n<p><code>typedef Oldname newname</code> 所以这里是<code>typedef struct dictht dictht</code> 将struct dictht 取了个别名dictht。</p>\n<p><code>dictEntry **table;</code> 书上解释的是table是数组，但是最直接的说法是table是一个指向（指向dictEntry类型的指针）的指针，是指向指针的指针。   </p>\n<p>数组获得内存是连续的，而指针不是，所以书中说是table数组，应该是分配内存的时候给指针分配了连续的内存，但是代码没找到。</p>\n<p>关于指针和数组的异同《C专家编程》一书有讲解（第四章、第九章、第十章）。</p>\n<ul>\n<li>主要的不同：指针存放的是地址，所以需要经过两次取地址的内容。（取指针的地址中的数据（变量的地址），取变量地址的数据）。而数组是直接存储数组的首元素的数据，所以只用一次取地址中的数据</li>\n<li>数组与指针相同<ul>\n<li>表达式中的数组名就是指针</li>\n<li>C语言把数组下标作为指针的偏移量。a是数组，a[6]就是首地址偏移6。b是指针，b[6]也是指针存储的地址向后偏移6.</li>\n<li>作为函数参数的数组名等同于指针。只是把首地址传入给了参数，并没有把数组所有的内存区域都传入。所以传入数组，就是传入指针。</li>\n</ul>\n</li>\n</ul>\n<p>sizemask和哈希值一起决定一个键应该被放到table数组的那个索引上面。</p>\n<p><img src=\"http://redisbook.com/_images/graphviz-bd3eecd927a4d8fc33b4a1c7f5957c52d67c5021.png\" alt=\"一个空的哈希表\"></p>\n<h3 id=\"4-1-2-哈希表节点\"><a href=\"#4-1-2-哈希表节点\" class=\"headerlink\" title=\"4.1.2 哈希表节点\"></a>4.1.2 哈希表节点</h3><p>使用dictEntry结构体表示节点，每一个dictEntry结构都保存着一个键值对。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictEntry</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 键</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *key;\t</span><br><span class=\"line\">    <span class=\"comment\">// 值</span></span><br><span class=\"line\">    <span class=\"keyword\">union</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">void</span> *val;</span><br><span class=\"line\">        <span class=\"keyword\">uint64_t</span> u64;</span><br><span class=\"line\">        <span class=\"keyword\">int64_t</span> s64;</span><br><span class=\"line\">        <span class=\"keyword\">double</span> d;</span><br><span class=\"line\">    &#125; v;</span><br><span class=\"line\">    <span class=\"comment\">//指向下一个哈希表节点   </span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictEntry</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125; dictEntry;</span><br></pre></td></tr></table></figure>\n<p>key指向键值对中的键，而v则保存键值对中的值，值可以是一个指针，或者uint64_t整数，或者有符号的int64_t整数,或者是double类型（double也占8byte无论32还是64位）。</p>\n<p><code>union</code> 是c中的共用体（联合体），和结构体非常类似。和结构体的区别是</p>\n<ul>\n<li>结构体的各个成员会占用不同的内存，互相之间没有影响；而共用体的所有成员占用同一段内存，修改一个成员会影响其余所有成员。</li>\n<li>结构体占用的内存大于等于所有成员占用的内存的总和（成员之间可能会存在缝隙），共用体占用的内存等于最长的成员占用的内存。共用体使用了内存覆盖技术，同一时刻只能保存一个成员的值，如果对新的成员赋值，就会把原来成员的值覆盖掉。 所以这里面v占用8byte内存，但是属性却可以有4中。</li>\n</ul>\n<p>next指针可以将多个哈希值相同的键值对链接在一起，用来解决哈希键冲突(索引相同)的问题。链式的方法。</p>\n<p><img src=\"http://redisbook.com/_images/graphviz-d2641d962325fd58bf15d9fffb4208f70251a999.png\" alt=\"\"></p>\n<h3 id=\"4-1-3-字典\"><a href=\"#4-1-3-字典\" class=\"headerlink\" title=\"4.1.3 字典\"></a>4.1.3 字典</h3><p>Redis中字典由dict.h/dict 结构体表示。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dict</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//类型特定函数</span></span><br><span class=\"line\">    dictType *type;</span><br><span class=\"line\">    <span class=\"comment\">// 私有数据</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *privdata;</span><br><span class=\"line\">    <span class=\"comment\">// 哈希表</span></span><br><span class=\"line\">    dictht ht[<span class=\"number\">2</span>];</span><br><span class=\"line\">    <span class=\"comment\">//rehash 索引</span></span><br><span class=\"line\">    <span class=\"comment\">//当rehash不在进行是值为-1。用来记录是否在rehash</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> rehashidx; <span class=\"comment\">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class=\"line\">    <span class=\"comment\">//当前迭代的个数</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> iterators; <span class=\"comment\">/* number of iterators currently running */</span></span><br><span class=\"line\">&#125; dict;</span><br></pre></td></tr></table></figure>\n<p>type 和private属性是针对不同类型的键值对（redis支持5中数据类型），为创建多态字典而设置的。</p>\n<ul>\n<li>type指向dictType结构，dictType结构保存了一簇用于操作特定类型键值对的函数，Redis为不同用途的字典设置了不同的类型的特定函数。（多态的表现。）</li>\n<li>privadata属性保存了需要传给哪些类型特点函数的可选参数。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictType</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 计算哈希值的函数</span></span><br><span class=\"line\">    <span class=\"keyword\">uint64_t</span> (*hashFunction)(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *key);</span><br><span class=\"line\">    <span class=\"comment\">// 复制键的函数</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *(*keyDup)(<span class=\"keyword\">void</span> *privdata, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *key);</span><br><span class=\"line\">    <span class=\"comment\">// 复制值的函数</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *(*valDup)(<span class=\"keyword\">void</span> *privdata, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *obj);</span><br><span class=\"line\">    <span class=\"comment\">// 对比键的函数</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*keyCompare)(<span class=\"keyword\">void</span> *privdata, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *key1, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *key2);</span><br><span class=\"line\">    <span class=\"comment\">// 销毁键的函数</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*keyDestructor)(<span class=\"keyword\">void</span> *privdata, <span class=\"keyword\">void</span> *key);</span><br><span class=\"line\">    <span class=\"comment\">// 销毁值的函数</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*valDestructor)(<span class=\"keyword\">void</span> *privdata, <span class=\"keyword\">void</span> *obj);</span><br><span class=\"line\">&#125; dictType;</span><br></pre></td></tr></table></figure>\n<p>ht是长度为2的数组，而数组的元素就是哈希表dictht。一般情况只会使用ht[0],ht[1]只会在ht[0]空间不够的时候进行rehash的时候使用。</p>\n<p>rehashidx 用来标识是否在 rehash，没有的话值为-1,有的话rehasidx用来记录rehash的进度。</p>\n<p><img src=\"http://redisbook.com/_images/graphviz-e73003b166b90094c8c4b7abbc8d59f691f91e27.png\" alt=\"\"></p>\n<h2 id=\"4-2-哈希算法\"><a href=\"#4-2-哈希算法\" class=\"headerlink\" title=\"4.2 哈希算法\"></a>4.2 哈希算法</h2><p>添加一个新的键值对的时候，</p>\n<pre><code> 1. 需要先根据键值使用hash函数计算哈希值\n    2. 哈希值和sizemask并运算求得索引值\n    3. 再根据索引值将包含键值对的哈希表节点放到哈希表数组table上的对应索引值上。\n</code></pre><p>Redis 计算哈希值和索引值的方法为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 使用字典设置的哈希函数，计算键 key 的哈希值</span><br><span class=\"line\">hash = dict-&gt;type-&gt;hashFunction(key);</span><br><span class=\"line\"></span><br><span class=\"line\"># 使用哈希表的 sizemask 属性和哈希值，计算出索引值</span><br><span class=\"line\"># 根据情况不同， ht[x] 可以是 ht[0] 或者 ht[1]</span><br><span class=\"line\">index = hash &amp; dict-&gt;ht[x].sizemask;</span><br></pre></td></tr></table></figure>\n<p>哈希值用hashFunction计算，index用hash值和sizemask进行并操作。</p>\n<p>对应在源码中为：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//dict.h 中：</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> dictHashKey(d, key) (d)-&gt;type-&gt;hashFunction(key) <span class=\"comment\">//计算哈希值</span></span></span><br><span class=\"line\"><span class=\"comment\">//dict.c 中</span></span><br><span class=\"line\">idx = hash &amp; d-&gt;ht[table].sizemask;</span><br><span class=\"line\">h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[<span class=\"number\">1</span>].sizemask;</span><br></pre></td></tr></table></figure>\n<p>插入一个键值对<k0,v0>到字典中的过程为：</k0,v0></p>\n<p><img src=\"http://redisbook.com/_images/graphviz-ca9c88ba1713cb595c4e0e4a17ef2042b0008621.png\" alt=\"\"></p>\n<p>先使用语句</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hash = dict-&gt;type-&gt;hashFunction(k0);</span><br></pre></td></tr></table></figure>\n<p>计算键 <code>k0</code> 的哈希值。</p>\n<p>假设计算得出的哈希值为 <code>8</code> ， 那么程序会继续使用语句</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">index = hash &amp; dict-&gt;ht[0].sizemask = 8 &amp; 3 = 0;</span><br></pre></td></tr></table></figure>\n<p>计算出键 <code>k0</code> 的索引值 <code>0</code> ， 这表示包含键值对 <code>k0</code> 和 <code>v0</code> 的节点应该被放置到哈希表数组的索引 <code>0</code> 位置上。</p>\n<p><img src=\"http://redisbook.com/_images/graphviz-2369cb08288f5e59548355042c4c40cc4339e339.png\" alt=\"\"></p>\n<p>当字典被用作数据库的底层实现， 或者哈希键的底层实现时， Redis 使用 MurmurHash2 算法来计算键的哈希值。算法的优点</p>\n<ul>\n<li>即使输入的键是有规律的， 算法仍能给出一个很好的随机分布性， 并且算法的计算速度也非常快。</li>\n</ul>\n<p>MurmurHash 算法目前的最新版本为 MurmurHash3 ， 而 Redis 使用的是 MurmurHash2 ， 关于 MurmurHash 算法的更多信息可以参考该算法的主页： <a href=\"http://code.google.com/p/smhasher/\" target=\"_blank\" rel=\"noopener\">http://code.google.com/p/smhasher/</a> 。</p>\n<p>暂时没有找到hashFunction的源码。</p>\n<h3 id=\"4-3-键冲突\"><a href=\"#4-3-键冲突\" class=\"headerlink\" title=\"4.3 键冲突\"></a>4.3 键冲突</h3><p>两个以上的键分配到了同一个索引就产生了冲突。</p>\n<p>使用链地址法解决，相同索引上面的节点可以用next指针来链接，这样同一个索引就可以存放多个哈希表节点了。</p>\n<p>哈希表节点没有指向链表链尾的节点，所以不能迅速的知道哪个节点是尾节点，（只能通过遍历才能找到指向null的尾节点O(N)）,所以为了速度考虑总是将新节点插入到最前面（dictht-&gt;table指针指向的第一个节点就是最前面的节点。）</p>\n<p>直接使用书上的图：</p>\n<p>还未发生键冲突</p>\n<p><img src=\"http://redisbook.com/_images/graphviz-db40aa6d0f1265d74f1c1d12b8fa074c0bcda12a.png\" alt=\"\"></p>\n<p>键冲突发生后：新键值对<k2,v2> 插入到<k1,v1>前面。</k1,v1></k2,v2></p>\n<p><img src=\"http://redisbook.com/_images/graphviz-4b52dcf6eb0768750e1c15480be3326ca37e05b3.png\" alt=\"\"></p>\n<h2 id=\"4-4-rehash\"><a href=\"#4-4-rehash\" class=\"headerlink\" title=\"4.4  rehash\"></a>4.4  rehash</h2><p>哈希表保存的键值对会增多或者减少，需要让负载因子（负载因子(load factor)，它用来衡量哈希表的 <strong>空/满</strong> 程度，一定程度上也可以体现查询的效率）维持在合理的范围，所以哈希节点太多的时候需要扩容（不然冲突太多，降低效率），这些哈希表的空间动态扩容或者缩容通过rehash操作来实现。</p>\n<p>步骤为：</p>\n<ol>\n<li>为ht[1]分配空间<ol>\n<li>扩容时ht[1].size = 大于等于ht[0].used*2的第一个2^n。</li>\n<li>收缩时ht[1].size = 大于等于ht[0].used的第一个2^n。</li>\n</ol>\n</li>\n<li>迁移：将ht[0]上面的哈希节点重新计算哈希值与索引值并放到ht[1]哈希表上面。</li>\n<li>迁移完成后释放ht[0],把ht[1]设置成ht[0],并在ht[1]新创建一个空白哈希表，等待下一次rehash。</li>\n</ol>\n<p>注意：不管是扩容还是收缩，新分配的空间都会比原来用到的(used)大。设置ht[1]为ht[0] 的时候只需要简单的将原来ht[0]上面的指针指向ht[1]就好，但是需要把原来指向的哈希表的内存给释放掉。（指针是真的强，每次指针变换指向的地址的时候，都需要考虑下之前指向的地址是否还需要，不需要就要释放，不然会造成内存泄漏）。ht[1]则重新新建个哈希表结构体，然后把ht[1]的指针指过来就好了。</p>\n<p>rehash的过程图解参考书中的图讲的很详细。</p>\n<p><img src=\"http://redisbook.com/_images/graphviz-93608325578e8e45848938ef420115bf2227639e.png\" alt=\"\"></p>\n<p>假设程序要对图 4-8 所示字典的 <code>ht[0]</code> 进行扩展操作。</p>\n<ol>\n<li><code>ht[0].used</code> 当前的值为 <code>4</code> ， <code>4 * 2 = 8</code> ， 而 <code>8</code> （2^3）恰好是第一个大于等于 <code>4</code> 的 <code>2</code> 的 <code>n</code> 次方， 所以程序会将 <code>ht[1]</code> 哈希表的大小设置为 <code>8</code> 。图 4-9 展示了 <code>ht[1]</code> 在分配空间之后， 字典的样子：</li>\n</ol>\n<p><img src=\"http://redisbook.com/_images/graphviz-b68acb4d868ec7d79a44935ce08a159746ca58da.png\" alt=\"\"></p>\n<ol>\n<li>将 <code>ht[0]</code> 包含的四个键值对都 rehash 到 <code>ht[1]</code> ， 如图 4-10 所示。</li>\n</ol>\n<p><img src=\"http://redisbook.com/_images/graphviz-92dc47e4329eabae941cddfd727b736ef738e8cf.png\" alt=\"\"></p>\n<ol>\n<li>释放 <code>ht[0]</code> ，并将 <code>ht[1]</code> 设置为 <code>ht[0]</code> ，然后为 <code>ht[1]</code> 分配一个空白哈希表，如图 4-11 所示。</li>\n</ol>\n<p><img src=\"http://redisbook.com/_images/graphviz-fa28d986a72f1f48b83c7f959ea217b1f9527d3c.png\" alt=\"\"></p>\n<p>哈希表的扩展与收缩（源码还没找到）</p>\n<p>当以下条件中的任意一个被满足时， 程序会自动开始对哈希表执行扩展操作：</p>\n<ol>\n<li>服务器目前没有在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 <code>1</code> ；</li>\n<li>服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 <code>5</code> ；</li>\n</ol>\n<p>其中哈希表的负载因子可以通过公式得到。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 负载因子 = 哈希表已保存节点数量 / 哈希表大小</span><br><span class=\"line\">load_factor = ht[0].used / ht[0].size</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-5-渐进式rehash\"><a href=\"#4-5-渐进式rehash\" class=\"headerlink\" title=\"4.5 渐进式rehash\"></a>4.5 渐进式rehash</h2><p>考虑到redis数据库中存储的键值对很多的情况，如果一次性就rehash完，庞大的计算量可能会导致服务器性能急剧下降，甚至一段时间的停止服务，（经济学中的休克时疗法？）所以rehash这个过程需要渐进式的（软着陆）。</p>\n<p>步骤：</p>\n<ol>\n<li>为 <code>ht[1]</code> 分配空间， 让字典同时持有 <code>ht[0]</code> 和 <code>ht[1]</code> 两个哈希表。</li>\n<li>在dict中维持一个索引计数器变量 <code>rehashidx</code> ， 并将它的值设置为 <code>0</code> ， 表示 rehash 工作正式开始。</li>\n<li>在 rehash 进行期间， 每次对字典执行添加、删除、查找或者更新操作时， 程序除了执行指定的操作以外， 还会顺带将 <code>ht[0]</code> 哈希表在 <code>rehashidx</code> 索引上的所有键值对 rehash 到 <code>ht[1]</code> ， 当 rehash 工作完成之后， 程序将 <code>rehashidx</code> 属性的值增一。</li>\n<li>随着字典操作的不断执行， 最终在某个时间点上， <code>ht[0]</code> 的所有键值对都会被 rehash 至 <code>ht[1]</code> ， 这时程序将 <code>rehashidx</code> 属性的值设为 <code>-1</code> ， 表示 rehash 操作已完成。</li>\n</ol>\n<p>注意：</p>\n<ul>\n<li>rehashidx的范围是从-1到ht[0].size-1 ，也就是对应的哈希表的索引，不是之前理解的记录哈希节点的个数。</li>\n<li>迁移的过程不是拷贝，而是哈希表存储的哈希指针重新指向哈希节点的过程（指针对地址的操作）。</li>\n</ul>\n<p>rehash 键值对所需的计算工作均滩到对字典的每个添加、删除、查找和更新操作上， 从而避免了集中式 rehash 而带来的庞大计算量。</p>\n<p>过程图解依然copy自redis设计与实现的电子书。</p>\n<p><img src=\"http://redisbook.com/_images/graphviz-4c43eaf38cbca10d8d368a5144db6f3c69ab3d84.png\" alt=\"\"></p>\n<p><img src=\"http://redisbook.com/_images/graphviz-b91705b0d7a6c7fd5e37332a930534e0e136ae73.png\" alt=\"\"></p>\n<p><img src=\"http://redisbook.com/_images/graphviz-9e2996e6ca9665776062470cdac346e8fc255374.png\" alt=\"\"></p>\n<p><img src=\"http://redisbook.com/_images/graphviz-c871b5de1a7910aea237ca9dc86508b48da94769.png\" alt=\"\"></p>\n<p><img src=\"http://redisbook.com/_images/graphviz-3b31e4e08cc3e212f986039eb08ae77224cdeec9.png\" alt=\"\"></p>\n<p><img src=\"http://redisbook.com/_images/graphviz-86f810ac65c4e6ee58b17105dfeaa06973d8dd16.png\" alt=\"\"></p>\n<h3 id=\"渐进式rehash期间的哈希表操作\"><a href=\"#渐进式rehash期间的哈希表操作\" class=\"headerlink\" title=\"渐进式rehash期间的哈希表操作\"></a>渐进式rehash期间的哈希表操作</h3><p>增删改查在两个表上操作，但是添加的新键只添加到ht[1]上，确保ht[0]最终变成空表。</p>\n<h2 id=\"4-6-字典API\"><a href=\"#4-6-字典API\" class=\"headerlink\" title=\"4.6 字典API\"></a>4.6 字典API</h2><h2 id=\"疑惑\"><a href=\"#疑惑\" class=\"headerlink\" title=\"疑惑\"></a>疑惑</h2><ul>\n<li><p>为什么不直接用<code>dictEntry *table[]</code> 来表示，却要用指针？应该是指针更加灵活些？</p>\n<ul>\n<li>因为dict有两个哈希表，而其中有个哈希表ht[1] 是只有在rehash的时候才会使用的，因此使用指针的的话，在不需要的时候将table直接指向null就可以简单的完成释放空间的操作，如果用数组的话,在分配内存的时候，就必须要为两个dictht都分配size个byte的内存存储空间，当rehash的时候size会变化，结构体中的数组就需要重新分配内存空间，而结构体的内存是相邻连续的，所以这时候要变化空间，只能重新再给这个结构体分配空间，这样效率肯定就很低了。所以使用指针的原因就是rehash的时候数组的大小会变化，如果用数组来记录就很麻烦和效率低了。</li>\n<li>所以在dict中可以使用数组来存储dictht,因为ht这个数组是不会变化的。</li>\n</ul>\n</li>\n<li><p>既然在rehash过程中会有增删改查的操作，那么这些操作是在哪个哈希表上进行的呢？</p>\n<ul>\n<li>两个哈希表上面都会进行，但是增加的键值对会在ht[1] 上，不然ht[0]在减少的时候又新增键值对，不是在做无用之功吗。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://redisbook.com/preview/dict/hash_algorithm.html\" target=\"_blank\" rel=\"noopener\">http://redisbook.com/preview/dict/hash_algorithm.html</a></p>\n<p><a href=\"https://blog.csdn.net/yangbodong22011/article/details/78467583\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/yangbodong22011/article/details/78467583</a></p>"},{"title":"计算Linux系统的CPU利用率","date":"2019-03-31T03:44:01.000Z","copyright":true,"_content":"\n# 计算Linux系统的CPU利用率\n\n通过读取系统的/proc/stat 信息来计算CPU的利用率\n\n<!--more-->\n\n## cpu 信息的读取\n\n摘自参考博客：https://blog.csdn.net/x_i_y_u_e/article/details/50684508\n\n在Linux/Unix下，CPU利用率分为用户态，系统态和空闲态，分别表示CPU处于用户态执行的时间，系统内核执行的时间，和空闲系统进程执行的时间。平时所说的CPU利用率是指：CPU执行非系统空闲进程的时间 / CPU总的执行时间。\n\n在Linux的内核中，有一个全局变量：Jiffies。 Jiffies代表时间。它的单位随硬件平台的不同而不同。系统里定义了一个常数HZ，代表每秒种最小时间间隔的数目。这样jiffies的单位就是1/HZ。Intel平台jiffies的单位是1/100秒，这就是系统所能分辨的最小时间间隔了。每个CPU时间片，Jiffies都要加1。 CPU的利用率就是用执行用户态+系统态的Jiffies除以总的Jifffies来表示。\n\n在Linux系统中，可以用/proc/stat文件来计算cpu的利用率(详细的解释可参考：<http://www.linuxhowtos.org/System/procstat.htm>)。这个文件包含了所有CPU活动的信息，该文件中的所有值都是从系统启动开始累计到当前时刻。\n\n在本机上的信息如下：\n\n```\n root@hw103:/home/yky# cat/proc/stat \ncpu  7283854 35392 293546 204419077 75835 0 8385 0 0 0\ncpu0 365010 48 18204 8453603 767 0 4306 0 0 0\ncpu1 292817 9 14990 8526563 1358 0 2114 0 0 0\ncpu2 286689 0 11880 8538662 1033 0 752 0 0 0\ncpu3 287106 14624 12945 8523209 641 0 320 0 0 0\ncpu4 293293 0 11784 8532282 604 0 147 0 0 0\ncpu5 371312 2824 13669 8408187 40794 0 406 0 0 0\ncpu6 358116 10934 14014 8453775 1230 0 68 0 0 0\ncpu7 313971 6281 12243 8504303 1575 0 28 0 0 0\ncpu8 318084 0 11598 8506770 2036 0 15 0 0 0\ncpu9 294503 0 11137 8530318 2185 0 10 0 0 0\ncpu10 307922 144 12434 8516570 1177 0 15 0 0 0\ncpu11 291752 0 11502 8533957 1128 0 4 0 0 0\ncpu12 315096 0 15927 8503001 3528 0 3 0 0 0\ncpu13 375976 0 17927 8442873 2041 0 1 0 0 0\ncpu14 299344 0 10140 8523716 2818 0 1 0 0 0\ncpu15 288470 3 10146 8538685 1240 0 0 0 0 0\ncpu16 301148 0 10681 8523612 2185 0 0 0 0 0\ncpu17 263183 4 9149 8565345 771 0 0 0 0 0\ncpu18 262518 370 10343 8562955 2105 0 11 0 0 0\ncpu19 280230 3 10399 8546414 1227 0 6 0 0 0\ncpu20 278962 0 10346 8547585 1221 0 9 0 0 0\ncpu21 277042 143 11502 8547940 1048 0 2 0 0 0\ncpu22 275560 0 9458 8549093 1271 0 153 0 0 0\ncpu23 285740 0 11118 8539648 1838 0 6 0 0 0\nintr 91288599 43 2 0 0 0 0 0 0 1 0 0 0 4 0 0 0 41 0 2 0 0 0 0 0 0 0 334158 0 1 2473208 45518 96917 44876 138077 45263 45258 54441 0 0 44198 44198 44198 44198 44198 44198 441\n98 44198 0 0 44198 44198 44198 44198 44198 44198 44198 44198 0 0 44199 44199 44199 44199 44199 44199 44199 44199 0 0 44199 44199 44199 44199 44199 44199 44199 44199 0 0 44198 44198 44198 44198 44198 44198 44198 44198 0 0 44198 44198 44198 44198 44198 44198 44198 44198 0 0 44199 44199 44199 44199 44199 44199 44199 44199 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0ctxt 42731429\nbtime 1553933982\nprocesses 190449\nprocs_running 5\nprocs_blocked 0\nsoftirq 57291816 8 26401645 17536 5419485 334063 0 1044 10019160 0 15098875\n\n```\n\n第一行cpu是总的cpu信息，其他的cpu0-cpu23 是24个核的信息。\n\n计算cpu利用率只用到前7个参数， 对应的参数解释为：\n\n```\n\t user\t nice  system idle      iowait   irq  softirq\ncpu  7283854 35392 293546 204419077 75835    0    8385     \n```\n\nuser (7283854) 从系统启动开始累计到当前时刻，用户态的CPU时间（单位：jiffies） ，不包含 nice值为负进程。1jiffies=0.01秒\nnice (35392) 从系统启动开始累计到当前时刻，nice值为负的进程所占用的CPU时间（单位：jiffies）\nsystem (293546) 从系统启动开始累计到当前时刻，核心时间（单位：jiffies）\nidle (204419077) 从系统启动开始累计到当前时刻，除硬盘IO等待时间以外其它等待时间（单位：jiffies）\niowait (75835) 从系统启动开始累计到当前时刻，硬盘IO等待时间（单位：jiffies） ，\nirq (0) 从系统启动开始累计到当前时刻，硬中断时间（单位：jiffies）\nsoftirq (8385) 从系统启动开始累计到当前时刻，软中断时间（单位：jiffies）\n\nCPU时间=user+system+nice+idle+iowait+irq+softirq\n\n“intr”这行给出中断的信息，第一个为自系统启动以来，发生的所有的中断的次数；然后每个数对应一个特定的中断自系统启动以来所发生的次数。\n“ctxt”给出了自系统启动以来CPU发生的上下文交换的次数。\n“btime”给出了从系统启动到现在为止的时间，单位为秒。\n“processes (total_forks) 自系统启动以来所创建的任务的个数目。\n“procs_running”：当前运行队列的任务的数目。\n“procs_blocked”：当前被阻塞的任务的数目。\n\n\n\n计算cpu利用率的方法就是计算出在一段时间里面，cpu工作的时间/总得时间\n\n```\ncpu usage=(idle2-idle1)/(cpu2-cpu1)*100\ncpu usage=[(user_2 +sys_2+nice_2) - (user_1 + sys_1+nice_1)]/(total_2 - total_1)*100\n```\n\n第二中方法只把user+sys+nice 这三个时间看作cpu的工作时间，因为其他的几个比较小。\n\n## shell脚本\n\n```shell\n#!/bin/bash\n\n##echo user nice system idle iowait irq softirq\n\ncpulog_start=$(cat /proc/stat | grep 'cpu'| awk 'NR==1{print $2 \"\\t\" $3 \"\\t\" $4 \"\\t\" $5 \"\\t\" $6 \"\\t\" $7 \"\\t\" $8}' )\ncpu_use_start=$(echo $cpulog_start | awk '{print $1+$2+$3}')\ncpu_iowait_start=$(echo $cpulog_start | awk '{print $5}')\ncpu_total_start=$(echo $cpulog_start | awk '{print $1+$2+$3+$4+$5+$6+$7}')\n\nsleep 10\n\ncpulog_end=$(cat /proc/stat | grep 'cpu'| awk 'NR==1{print $2 \"\\t\" $3 \"\\t\" $4 \"\\t\" $5 \"\\t\" $6 \"\\t\" $7 \"\\t\" $8}' )\ncpu_use_end=$(echo $cpulog_end | awk '{print $1+$2+$3}')\ncpu_iowait_end=$(echo $cpulog_end | awk '{print $5}')\ncpu_total_end=$(echo $cpulog_end | awk '{print $1+$2+$3+$4+$5+$6+$7}')\n\ncpu_use_diff=`expr $cpu_use_end - $cpu_use_start`\ncpu_iowait_diff=`expr $cpu_iowait_end - $cpu_iowait_start`\ncpu_total_diff=`expr $cpu_total_end - $cpu_total_start`\n\ncpu_use_rate=`expr $cpu_use_diff/$cpu_total_diff*100 | bc -l`\ncpu_iowait_rate=`expr $cpu_iowait_diff/$cpu_total_diff*100 | bc -l`\n\necho \"---------------cpuinfo----------------------\"\necho \"cpu_usage_rate (%) : $cpu_use_rate\"\necho \"cpu_iowait_rate (%): $cpu_iowait_rate\"\n\n```\n\n主要的知识点讲解：\n\n```shell\ncpulog_start=$(cat /proc/stat | grep 'cpu'| awk 'NR==1{print $2 \"\\t\" $3 \"\\t\" $4 \"\\t\" $5 \"\\t\" $6 \"\\t\" $7 \"\\t\" $8}' )\n```\n\n这一句先将/proc/stat文件的信息读取出来然后用管道| 传递给grep 命令 ,grep 将包含cpu的信息给提取出来\n\n`cat /proc/stat | grep 'cpu'` 输出为：\n\n```bash\nroot@hw103:/home/yky# cat /proc/stat | grep 'cpu'\ncpu  7645369 35392 318219 206250476 80895 0 9870 0 0 0\ncpu0 365256 48 18792 8544685 767 0 5678 0 0 0\ncpu1 292983 9 15427 8618292 1389 0 2206 0 0 0\ncpu2 287020 0 12884 8629895 1033 0 760 0 0 0\ncpu3 288372 14624 13910 8613386 681 0 320 0 0 0\ncpu4 293707 0 13074 8623117 646 0 147 0 0 0\ncpu5 390012 2824 15130 8477387 44027 0 418 0 0 0\ncpu6 362140 10934 15217 8541127 1233 0 69 0 0 0\ncpu7 377620 6281 12915 8532734 1700 0 28 0 0 0\ncpu8 333520 0 12524 8582987 2100 0 15 0 0 0\ncpu9 348913 0 12619 8567005 2453 0 10 0 0 0\ncpu10 333584 144 14002 8581939 1297 0 15 0 0 0\ncpu11 292980 0 12966 8623861 1137 0 4 0 0 0\ncpu12 350188 0 16793 8559301 4017 0 3 0 0 0\ncpu13 430200 0 19278 8479849 2344 0 1 0 0 0\ncpu14 312421 0 11483 8601843 2906 0 1 0 0 0\ncpu15 343656 3 10768 8575706 1268 0 0 0 0 0\ncpu16 302673 0 12190 8613170 2190 0 0 0 0 0\ncpu17 263473 4 9906 8656857 771 0 0 0 0 0\ncpu18 263094 370 11278 8653940 2165 0 11 0 0 0\ncpu19 281216 3 11166 8637253 1280 0 6 0 0 0\ncpu20 280412 0 11645 8637433 1221 0 9 0 0 0\ncpu21 277219 143 11967 8639929 1048 0 2 0 0 0\ncpu22 275894 0 10291 8640508 1271 0 153 0 0 0\ncpu23 298806 0 11985 8618261 1939 0 6 0 0 0\n```\n\n### awk 命令\n\n之后使用awk命令再次进行操作。这个命令之前用的很少，参考《鸟哥的Linux私房菜》介绍：\n\nsed常用于一整行的处理，awk则倾向于将一行分成数个“字段”来处理，awk适合处理小型的数据。\n\n用法为：\n\n`awk '条件类型1{操作1} 条件类型1{操作2}...'  filename`\n\n| 变量名称 | 意义                        |\n| -------- | --------------------------- |\n| NF       | 每一行（$0） 拥有的字段总数 |\n| NR       | awk当前处理的第几行数据     |\n| FS       | 目前的分割符，默认空格键    |\n\n\n\n```shell\ncpulog_start=$(cat /proc/stat | grep 'cpu'| awk 'NR==1{print $2 \"\\t\" $3 \"\\t\" $4 \"\\t\" $5 \"\\t\" $6 \"\\t\" $7 \"\\t\" $8}' )\n```\n\n`NR==1 ` 限定条件为第一行，因为第一行的数据才是cpu的总信息，{}里面的操作是输出字段，$N 就是第N个字段。\n\n```\n $1\t$2\t\t$3\t\t$4\t  $5\t\t$6\t\t $7\t  $8\n     user\t nice  system idle      iowait   irq  softirq\ncpu  7283854 35392 293546 204419077 75835    0    8385    \n```\n\n### expr\n\n```bash\ncpu_use_diff=`expr $cpu_use_end - $cpu_use_start`\n```\n\n\n\n使用expr 执行变量计算，然后是`` 进行反引用将值赋值给cpu_use_diff\n\n注意shell 脚本中= 不能用空格分开 需要直接相邻\n\n### bc 命令\n\nbc 命令是任意精度计算器语言，通常在linux下当计算器用。\n\n简单的描述参考：<http://www.runoob.com/linux/linux-comm-bc.html>\n\n而expr命令不支持小数运算，所以需要使用bc进行计算。\n\n语法为：\n\n```\nbc(选项)(参数)\n```\n\n**选项值**\n\n- -i：强制进入交互式模式；\n- -l：定义使用的标准数学库\n- ； -w：对POSIX bc的扩展给出警告信息；\n- -q：不打印正常的GNU bc环境信息；\n- -v：显示指令版本信息；\n- -h：显示指令的帮助信息。\n\n**参数**\n\n文件：指定包含计算任务的文件。\n\n## 参考\n\n<https://blog.csdn.net/x_i_y_u_e/article/details/50684508>","source":"_posts/2019-03-31-计算Linux系统的CPU利用率.md","raw":"---\ntitle: 计算Linux系统的CPU利用率\ndate: 2019-03-31 11:44:01\ncategories: Linux\ntags:\n- Linux\n- shell\ncopyright: true\n---\n\n# 计算Linux系统的CPU利用率\n\n通过读取系统的/proc/stat 信息来计算CPU的利用率\n\n<!--more-->\n\n## cpu 信息的读取\n\n摘自参考博客：https://blog.csdn.net/x_i_y_u_e/article/details/50684508\n\n在Linux/Unix下，CPU利用率分为用户态，系统态和空闲态，分别表示CPU处于用户态执行的时间，系统内核执行的时间，和空闲系统进程执行的时间。平时所说的CPU利用率是指：CPU执行非系统空闲进程的时间 / CPU总的执行时间。\n\n在Linux的内核中，有一个全局变量：Jiffies。 Jiffies代表时间。它的单位随硬件平台的不同而不同。系统里定义了一个常数HZ，代表每秒种最小时间间隔的数目。这样jiffies的单位就是1/HZ。Intel平台jiffies的单位是1/100秒，这就是系统所能分辨的最小时间间隔了。每个CPU时间片，Jiffies都要加1。 CPU的利用率就是用执行用户态+系统态的Jiffies除以总的Jifffies来表示。\n\n在Linux系统中，可以用/proc/stat文件来计算cpu的利用率(详细的解释可参考：<http://www.linuxhowtos.org/System/procstat.htm>)。这个文件包含了所有CPU活动的信息，该文件中的所有值都是从系统启动开始累计到当前时刻。\n\n在本机上的信息如下：\n\n```\n root@hw103:/home/yky# cat/proc/stat \ncpu  7283854 35392 293546 204419077 75835 0 8385 0 0 0\ncpu0 365010 48 18204 8453603 767 0 4306 0 0 0\ncpu1 292817 9 14990 8526563 1358 0 2114 0 0 0\ncpu2 286689 0 11880 8538662 1033 0 752 0 0 0\ncpu3 287106 14624 12945 8523209 641 0 320 0 0 0\ncpu4 293293 0 11784 8532282 604 0 147 0 0 0\ncpu5 371312 2824 13669 8408187 40794 0 406 0 0 0\ncpu6 358116 10934 14014 8453775 1230 0 68 0 0 0\ncpu7 313971 6281 12243 8504303 1575 0 28 0 0 0\ncpu8 318084 0 11598 8506770 2036 0 15 0 0 0\ncpu9 294503 0 11137 8530318 2185 0 10 0 0 0\ncpu10 307922 144 12434 8516570 1177 0 15 0 0 0\ncpu11 291752 0 11502 8533957 1128 0 4 0 0 0\ncpu12 315096 0 15927 8503001 3528 0 3 0 0 0\ncpu13 375976 0 17927 8442873 2041 0 1 0 0 0\ncpu14 299344 0 10140 8523716 2818 0 1 0 0 0\ncpu15 288470 3 10146 8538685 1240 0 0 0 0 0\ncpu16 301148 0 10681 8523612 2185 0 0 0 0 0\ncpu17 263183 4 9149 8565345 771 0 0 0 0 0\ncpu18 262518 370 10343 8562955 2105 0 11 0 0 0\ncpu19 280230 3 10399 8546414 1227 0 6 0 0 0\ncpu20 278962 0 10346 8547585 1221 0 9 0 0 0\ncpu21 277042 143 11502 8547940 1048 0 2 0 0 0\ncpu22 275560 0 9458 8549093 1271 0 153 0 0 0\ncpu23 285740 0 11118 8539648 1838 0 6 0 0 0\nintr 91288599 43 2 0 0 0 0 0 0 1 0 0 0 4 0 0 0 41 0 2 0 0 0 0 0 0 0 334158 0 1 2473208 45518 96917 44876 138077 45263 45258 54441 0 0 44198 44198 44198 44198 44198 44198 441\n98 44198 0 0 44198 44198 44198 44198 44198 44198 44198 44198 0 0 44199 44199 44199 44199 44199 44199 44199 44199 0 0 44199 44199 44199 44199 44199 44199 44199 44199 0 0 44198 44198 44198 44198 44198 44198 44198 44198 0 0 44198 44198 44198 44198 44198 44198 44198 44198 0 0 44199 44199 44199 44199 44199 44199 44199 44199 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0ctxt 42731429\nbtime 1553933982\nprocesses 190449\nprocs_running 5\nprocs_blocked 0\nsoftirq 57291816 8 26401645 17536 5419485 334063 0 1044 10019160 0 15098875\n\n```\n\n第一行cpu是总的cpu信息，其他的cpu0-cpu23 是24个核的信息。\n\n计算cpu利用率只用到前7个参数， 对应的参数解释为：\n\n```\n\t user\t nice  system idle      iowait   irq  softirq\ncpu  7283854 35392 293546 204419077 75835    0    8385     \n```\n\nuser (7283854) 从系统启动开始累计到当前时刻，用户态的CPU时间（单位：jiffies） ，不包含 nice值为负进程。1jiffies=0.01秒\nnice (35392) 从系统启动开始累计到当前时刻，nice值为负的进程所占用的CPU时间（单位：jiffies）\nsystem (293546) 从系统启动开始累计到当前时刻，核心时间（单位：jiffies）\nidle (204419077) 从系统启动开始累计到当前时刻，除硬盘IO等待时间以外其它等待时间（单位：jiffies）\niowait (75835) 从系统启动开始累计到当前时刻，硬盘IO等待时间（单位：jiffies） ，\nirq (0) 从系统启动开始累计到当前时刻，硬中断时间（单位：jiffies）\nsoftirq (8385) 从系统启动开始累计到当前时刻，软中断时间（单位：jiffies）\n\nCPU时间=user+system+nice+idle+iowait+irq+softirq\n\n“intr”这行给出中断的信息，第一个为自系统启动以来，发生的所有的中断的次数；然后每个数对应一个特定的中断自系统启动以来所发生的次数。\n“ctxt”给出了自系统启动以来CPU发生的上下文交换的次数。\n“btime”给出了从系统启动到现在为止的时间，单位为秒。\n“processes (total_forks) 自系统启动以来所创建的任务的个数目。\n“procs_running”：当前运行队列的任务的数目。\n“procs_blocked”：当前被阻塞的任务的数目。\n\n\n\n计算cpu利用率的方法就是计算出在一段时间里面，cpu工作的时间/总得时间\n\n```\ncpu usage=(idle2-idle1)/(cpu2-cpu1)*100\ncpu usage=[(user_2 +sys_2+nice_2) - (user_1 + sys_1+nice_1)]/(total_2 - total_1)*100\n```\n\n第二中方法只把user+sys+nice 这三个时间看作cpu的工作时间，因为其他的几个比较小。\n\n## shell脚本\n\n```shell\n#!/bin/bash\n\n##echo user nice system idle iowait irq softirq\n\ncpulog_start=$(cat /proc/stat | grep 'cpu'| awk 'NR==1{print $2 \"\\t\" $3 \"\\t\" $4 \"\\t\" $5 \"\\t\" $6 \"\\t\" $7 \"\\t\" $8}' )\ncpu_use_start=$(echo $cpulog_start | awk '{print $1+$2+$3}')\ncpu_iowait_start=$(echo $cpulog_start | awk '{print $5}')\ncpu_total_start=$(echo $cpulog_start | awk '{print $1+$2+$3+$4+$5+$6+$7}')\n\nsleep 10\n\ncpulog_end=$(cat /proc/stat | grep 'cpu'| awk 'NR==1{print $2 \"\\t\" $3 \"\\t\" $4 \"\\t\" $5 \"\\t\" $6 \"\\t\" $7 \"\\t\" $8}' )\ncpu_use_end=$(echo $cpulog_end | awk '{print $1+$2+$3}')\ncpu_iowait_end=$(echo $cpulog_end | awk '{print $5}')\ncpu_total_end=$(echo $cpulog_end | awk '{print $1+$2+$3+$4+$5+$6+$7}')\n\ncpu_use_diff=`expr $cpu_use_end - $cpu_use_start`\ncpu_iowait_diff=`expr $cpu_iowait_end - $cpu_iowait_start`\ncpu_total_diff=`expr $cpu_total_end - $cpu_total_start`\n\ncpu_use_rate=`expr $cpu_use_diff/$cpu_total_diff*100 | bc -l`\ncpu_iowait_rate=`expr $cpu_iowait_diff/$cpu_total_diff*100 | bc -l`\n\necho \"---------------cpuinfo----------------------\"\necho \"cpu_usage_rate (%) : $cpu_use_rate\"\necho \"cpu_iowait_rate (%): $cpu_iowait_rate\"\n\n```\n\n主要的知识点讲解：\n\n```shell\ncpulog_start=$(cat /proc/stat | grep 'cpu'| awk 'NR==1{print $2 \"\\t\" $3 \"\\t\" $4 \"\\t\" $5 \"\\t\" $6 \"\\t\" $7 \"\\t\" $8}' )\n```\n\n这一句先将/proc/stat文件的信息读取出来然后用管道| 传递给grep 命令 ,grep 将包含cpu的信息给提取出来\n\n`cat /proc/stat | grep 'cpu'` 输出为：\n\n```bash\nroot@hw103:/home/yky# cat /proc/stat | grep 'cpu'\ncpu  7645369 35392 318219 206250476 80895 0 9870 0 0 0\ncpu0 365256 48 18792 8544685 767 0 5678 0 0 0\ncpu1 292983 9 15427 8618292 1389 0 2206 0 0 0\ncpu2 287020 0 12884 8629895 1033 0 760 0 0 0\ncpu3 288372 14624 13910 8613386 681 0 320 0 0 0\ncpu4 293707 0 13074 8623117 646 0 147 0 0 0\ncpu5 390012 2824 15130 8477387 44027 0 418 0 0 0\ncpu6 362140 10934 15217 8541127 1233 0 69 0 0 0\ncpu7 377620 6281 12915 8532734 1700 0 28 0 0 0\ncpu8 333520 0 12524 8582987 2100 0 15 0 0 0\ncpu9 348913 0 12619 8567005 2453 0 10 0 0 0\ncpu10 333584 144 14002 8581939 1297 0 15 0 0 0\ncpu11 292980 0 12966 8623861 1137 0 4 0 0 0\ncpu12 350188 0 16793 8559301 4017 0 3 0 0 0\ncpu13 430200 0 19278 8479849 2344 0 1 0 0 0\ncpu14 312421 0 11483 8601843 2906 0 1 0 0 0\ncpu15 343656 3 10768 8575706 1268 0 0 0 0 0\ncpu16 302673 0 12190 8613170 2190 0 0 0 0 0\ncpu17 263473 4 9906 8656857 771 0 0 0 0 0\ncpu18 263094 370 11278 8653940 2165 0 11 0 0 0\ncpu19 281216 3 11166 8637253 1280 0 6 0 0 0\ncpu20 280412 0 11645 8637433 1221 0 9 0 0 0\ncpu21 277219 143 11967 8639929 1048 0 2 0 0 0\ncpu22 275894 0 10291 8640508 1271 0 153 0 0 0\ncpu23 298806 0 11985 8618261 1939 0 6 0 0 0\n```\n\n### awk 命令\n\n之后使用awk命令再次进行操作。这个命令之前用的很少，参考《鸟哥的Linux私房菜》介绍：\n\nsed常用于一整行的处理，awk则倾向于将一行分成数个“字段”来处理，awk适合处理小型的数据。\n\n用法为：\n\n`awk '条件类型1{操作1} 条件类型1{操作2}...'  filename`\n\n| 变量名称 | 意义                        |\n| -------- | --------------------------- |\n| NF       | 每一行（$0） 拥有的字段总数 |\n| NR       | awk当前处理的第几行数据     |\n| FS       | 目前的分割符，默认空格键    |\n\n\n\n```shell\ncpulog_start=$(cat /proc/stat | grep 'cpu'| awk 'NR==1{print $2 \"\\t\" $3 \"\\t\" $4 \"\\t\" $5 \"\\t\" $6 \"\\t\" $7 \"\\t\" $8}' )\n```\n\n`NR==1 ` 限定条件为第一行，因为第一行的数据才是cpu的总信息，{}里面的操作是输出字段，$N 就是第N个字段。\n\n```\n $1\t$2\t\t$3\t\t$4\t  $5\t\t$6\t\t $7\t  $8\n     user\t nice  system idle      iowait   irq  softirq\ncpu  7283854 35392 293546 204419077 75835    0    8385    \n```\n\n### expr\n\n```bash\ncpu_use_diff=`expr $cpu_use_end - $cpu_use_start`\n```\n\n\n\n使用expr 执行变量计算，然后是`` 进行反引用将值赋值给cpu_use_diff\n\n注意shell 脚本中= 不能用空格分开 需要直接相邻\n\n### bc 命令\n\nbc 命令是任意精度计算器语言，通常在linux下当计算器用。\n\n简单的描述参考：<http://www.runoob.com/linux/linux-comm-bc.html>\n\n而expr命令不支持小数运算，所以需要使用bc进行计算。\n\n语法为：\n\n```\nbc(选项)(参数)\n```\n\n**选项值**\n\n- -i：强制进入交互式模式；\n- -l：定义使用的标准数学库\n- ； -w：对POSIX bc的扩展给出警告信息；\n- -q：不打印正常的GNU bc环境信息；\n- -v：显示指令版本信息；\n- -h：显示指令的帮助信息。\n\n**参数**\n\n文件：指定包含计算任务的文件。\n\n## 参考\n\n<https://blog.csdn.net/x_i_y_u_e/article/details/50684508>","slug":"2019-03-31-计算Linux系统的CPU利用率","published":1,"updated":"2019-11-08T13:14:53.661Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2yelxgz0007m8tzox9bcmlg","content":"<h1 id=\"计算Linux系统的CPU利用率\"><a href=\"#计算Linux系统的CPU利用率\" class=\"headerlink\" title=\"计算Linux系统的CPU利用率\"></a>计算Linux系统的CPU利用率</h1><p>通过读取系统的/proc/stat 信息来计算CPU的利用率</p>\n<a id=\"more\"></a>\n<h2 id=\"cpu-信息的读取\"><a href=\"#cpu-信息的读取\" class=\"headerlink\" title=\"cpu 信息的读取\"></a>cpu 信息的读取</h2><p>摘自参考博客：<a href=\"https://blog.csdn.net/x_i_y_u_e/article/details/50684508\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/x_i_y_u_e/article/details/50684508</a></p>\n<p>在Linux/Unix下，CPU利用率分为用户态，系统态和空闲态，分别表示CPU处于用户态执行的时间，系统内核执行的时间，和空闲系统进程执行的时间。平时所说的CPU利用率是指：CPU执行非系统空闲进程的时间 / CPU总的执行时间。</p>\n<p>在Linux的内核中，有一个全局变量：Jiffies。 Jiffies代表时间。它的单位随硬件平台的不同而不同。系统里定义了一个常数HZ，代表每秒种最小时间间隔的数目。这样jiffies的单位就是1/HZ。Intel平台jiffies的单位是1/100秒，这就是系统所能分辨的最小时间间隔了。每个CPU时间片，Jiffies都要加1。 CPU的利用率就是用执行用户态+系统态的Jiffies除以总的Jifffies来表示。</p>\n<p>在Linux系统中，可以用/proc/stat文件来计算cpu的利用率(详细的解释可参考：<a href=\"http://www.linuxhowtos.org/System/procstat.htm\" target=\"_blank\" rel=\"noopener\">http://www.linuxhowtos.org/System/procstat.htm</a>)。这个文件包含了所有CPU活动的信息，该文件中的所有值都是从系统启动开始累计到当前时刻。</p>\n<p>在本机上的信息如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> root@hw103:/home/yky# cat/proc/stat </span><br><span class=\"line\">cpu  7283854 35392 293546 204419077 75835 0 8385 0 0 0</span><br><span class=\"line\">cpu0 365010 48 18204 8453603 767 0 4306 0 0 0</span><br><span class=\"line\">cpu1 292817 9 14990 8526563 1358 0 2114 0 0 0</span><br><span class=\"line\">cpu2 286689 0 11880 8538662 1033 0 752 0 0 0</span><br><span class=\"line\">cpu3 287106 14624 12945 8523209 641 0 320 0 0 0</span><br><span class=\"line\">cpu4 293293 0 11784 8532282 604 0 147 0 0 0</span><br><span class=\"line\">cpu5 371312 2824 13669 8408187 40794 0 406 0 0 0</span><br><span class=\"line\">cpu6 358116 10934 14014 8453775 1230 0 68 0 0 0</span><br><span class=\"line\">cpu7 313971 6281 12243 8504303 1575 0 28 0 0 0</span><br><span class=\"line\">cpu8 318084 0 11598 8506770 2036 0 15 0 0 0</span><br><span class=\"line\">cpu9 294503 0 11137 8530318 2185 0 10 0 0 0</span><br><span class=\"line\">cpu10 307922 144 12434 8516570 1177 0 15 0 0 0</span><br><span class=\"line\">cpu11 291752 0 11502 8533957 1128 0 4 0 0 0</span><br><span class=\"line\">cpu12 315096 0 15927 8503001 3528 0 3 0 0 0</span><br><span class=\"line\">cpu13 375976 0 17927 8442873 2041 0 1 0 0 0</span><br><span class=\"line\">cpu14 299344 0 10140 8523716 2818 0 1 0 0 0</span><br><span class=\"line\">cpu15 288470 3 10146 8538685 1240 0 0 0 0 0</span><br><span class=\"line\">cpu16 301148 0 10681 8523612 2185 0 0 0 0 0</span><br><span class=\"line\">cpu17 263183 4 9149 8565345 771 0 0 0 0 0</span><br><span class=\"line\">cpu18 262518 370 10343 8562955 2105 0 11 0 0 0</span><br><span class=\"line\">cpu19 280230 3 10399 8546414 1227 0 6 0 0 0</span><br><span class=\"line\">cpu20 278962 0 10346 8547585 1221 0 9 0 0 0</span><br><span class=\"line\">cpu21 277042 143 11502 8547940 1048 0 2 0 0 0</span><br><span class=\"line\">cpu22 275560 0 9458 8549093 1271 0 153 0 0 0</span><br><span class=\"line\">cpu23 285740 0 11118 8539648 1838 0 6 0 0 0</span><br><span class=\"line\">intr 91288599 43 2 0 0 0 0 0 0 1 0 0 0 4 0 0 0 41 0 2 0 0 0 0 0 0 0 334158 0 1 2473208 45518 96917 44876 138077 45263 45258 54441 0 0 44198 44198 44198 44198 44198 44198 441</span><br><span class=\"line\">98 44198 0 0 44198 44198 44198 44198 44198 44198 44198 44198 0 0 44199 44199 44199 44199 44199 44199 44199 44199 0 0 44199 44199 44199 44199 44199 44199 44199 44199 0 0 44198 44198 44198 44198 44198 44198 44198 44198 0 0 44198 44198 44198 44198 44198 44198 44198 44198 0 0 44199 44199 44199 44199 44199 44199 44199 44199 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0ctxt 42731429</span><br><span class=\"line\">btime 1553933982</span><br><span class=\"line\">processes 190449</span><br><span class=\"line\">procs_running 5</span><br><span class=\"line\">procs_blocked 0</span><br><span class=\"line\">softirq 57291816 8 26401645 17536 5419485 334063 0 1044 10019160 0 15098875</span><br></pre></td></tr></table></figure>\n<p>第一行cpu是总的cpu信息，其他的cpu0-cpu23 是24个核的信息。</p>\n<p>计算cpu利用率只用到前7个参数， 对应的参数解释为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t user\t nice  system idle      iowait   irq  softirq</span><br><span class=\"line\">cpu  7283854 35392 293546 204419077 75835    0    8385</span><br></pre></td></tr></table></figure>\n<p>user (7283854) 从系统启动开始累计到当前时刻，用户态的CPU时间（单位：jiffies） ，不包含 nice值为负进程。1jiffies=0.01秒<br>nice (35392) 从系统启动开始累计到当前时刻，nice值为负的进程所占用的CPU时间（单位：jiffies）<br>system (293546) 从系统启动开始累计到当前时刻，核心时间（单位：jiffies）<br>idle (204419077) 从系统启动开始累计到当前时刻，除硬盘IO等待时间以外其它等待时间（单位：jiffies）<br>iowait (75835) 从系统启动开始累计到当前时刻，硬盘IO等待时间（单位：jiffies） ，<br>irq (0) 从系统启动开始累计到当前时刻，硬中断时间（单位：jiffies）<br>softirq (8385) 从系统启动开始累计到当前时刻，软中断时间（单位：jiffies）</p>\n<p>CPU时间=user+system+nice+idle+iowait+irq+softirq</p>\n<p>“intr”这行给出中断的信息，第一个为自系统启动以来，发生的所有的中断的次数；然后每个数对应一个特定的中断自系统启动以来所发生的次数。<br>“ctxt”给出了自系统启动以来CPU发生的上下文交换的次数。<br>“btime”给出了从系统启动到现在为止的时间，单位为秒。<br>“processes (total_forks) 自系统启动以来所创建的任务的个数目。<br>“procs_running”：当前运行队列的任务的数目。<br>“procs_blocked”：当前被阻塞的任务的数目。</p>\n<p>计算cpu利用率的方法就是计算出在一段时间里面，cpu工作的时间/总得时间</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cpu usage=(idle2-idle1)/(cpu2-cpu1)*100</span><br><span class=\"line\">cpu usage=[(user_2 +sys_2+nice_2) - (user_1 + sys_1+nice_1)]/(total_2 - total_1)*100</span><br></pre></td></tr></table></figure>\n<p>第二中方法只把user+sys+nice 这三个时间看作cpu的工作时间，因为其他的几个比较小。</p>\n<h2 id=\"shell脚本\"><a href=\"#shell脚本\" class=\"headerlink\" title=\"shell脚本\"></a>shell脚本</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span>!/bin/bash</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span>#echo user nice system idle iowait irq softirq</span><br><span class=\"line\"></span><br><span class=\"line\">cpulog_start=$(cat /proc/stat | grep 'cpu'| awk 'NR==1&#123;print $2 \"\\t\" $3 \"\\t\" $4 \"\\t\" $5 \"\\t\" $6 \"\\t\" $7 \"\\t\" $8&#125;' )</span><br><span class=\"line\">cpu_use_start=$(echo $cpulog_start | awk '&#123;print $1+$2+$3&#125;')</span><br><span class=\"line\">cpu_iowait_start=$(echo $cpulog_start | awk '&#123;print $5&#125;')</span><br><span class=\"line\">cpu_total_start=$(echo $cpulog_start | awk '&#123;print $1+$2+$3+$4+$5+$6+$7&#125;')</span><br><span class=\"line\"></span><br><span class=\"line\">sleep 10</span><br><span class=\"line\"></span><br><span class=\"line\">cpulog_end=$(cat /proc/stat | grep 'cpu'| awk 'NR==1&#123;print $2 \"\\t\" $3 \"\\t\" $4 \"\\t\" $5 \"\\t\" $6 \"\\t\" $7 \"\\t\" $8&#125;' )</span><br><span class=\"line\">cpu_use_end=$(echo $cpulog_end | awk '&#123;print $1+$2+$3&#125;')</span><br><span class=\"line\">cpu_iowait_end=$(echo $cpulog_end | awk '&#123;print $5&#125;')</span><br><span class=\"line\">cpu_total_end=$(echo $cpulog_end | awk '&#123;print $1+$2+$3+$4+$5+$6+$7&#125;')</span><br><span class=\"line\"></span><br><span class=\"line\">cpu_use_diff=`expr $cpu_use_end - $cpu_use_start`</span><br><span class=\"line\">cpu_iowait_diff=`expr $cpu_iowait_end - $cpu_iowait_start`</span><br><span class=\"line\">cpu_total_diff=`expr $cpu_total_end - $cpu_total_start`</span><br><span class=\"line\"></span><br><span class=\"line\">cpu_use_rate=`expr $cpu_use_diff/$cpu_total_diff*100 | bc -l`</span><br><span class=\"line\">cpu_iowait_rate=`expr $cpu_iowait_diff/$cpu_total_diff*100 | bc -l`</span><br><span class=\"line\"></span><br><span class=\"line\">echo \"---------------cpuinfo----------------------\"</span><br><span class=\"line\">echo \"cpu_usage_rate (%) : $cpu_use_rate\"</span><br><span class=\"line\">echo \"cpu_iowait_rate (%): $cpu_iowait_rate\"</span><br></pre></td></tr></table></figure>\n<p>主要的知识点讲解：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cpulog_start=$(cat /proc/stat | grep 'cpu'| awk 'NR==1&#123;print $2 \"\\t\" $3 \"\\t\" $4 \"\\t\" $5 \"\\t\" $6 \"\\t\" $7 \"\\t\" $8&#125;' )</span><br></pre></td></tr></table></figure>\n<p>这一句先将/proc/stat文件的信息读取出来然后用管道| 传递给grep 命令 ,grep 将包含cpu的信息给提取出来</p>\n<p><code>cat /proc/stat | grep &#39;cpu&#39;</code> 输出为：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@hw103:/home/yky<span class=\"comment\"># cat /proc/stat | grep 'cpu'</span></span><br><span class=\"line\">cpu  7645369 35392 318219 206250476 80895 0 9870 0 0 0</span><br><span class=\"line\">cpu0 365256 48 18792 8544685 767 0 5678 0 0 0</span><br><span class=\"line\">cpu1 292983 9 15427 8618292 1389 0 2206 0 0 0</span><br><span class=\"line\">cpu2 287020 0 12884 8629895 1033 0 760 0 0 0</span><br><span class=\"line\">cpu3 288372 14624 13910 8613386 681 0 320 0 0 0</span><br><span class=\"line\">cpu4 293707 0 13074 8623117 646 0 147 0 0 0</span><br><span class=\"line\">cpu5 390012 2824 15130 8477387 44027 0 418 0 0 0</span><br><span class=\"line\">cpu6 362140 10934 15217 8541127 1233 0 69 0 0 0</span><br><span class=\"line\">cpu7 377620 6281 12915 8532734 1700 0 28 0 0 0</span><br><span class=\"line\">cpu8 333520 0 12524 8582987 2100 0 15 0 0 0</span><br><span class=\"line\">cpu9 348913 0 12619 8567005 2453 0 10 0 0 0</span><br><span class=\"line\">cpu10 333584 144 14002 8581939 1297 0 15 0 0 0</span><br><span class=\"line\">cpu11 292980 0 12966 8623861 1137 0 4 0 0 0</span><br><span class=\"line\">cpu12 350188 0 16793 8559301 4017 0 3 0 0 0</span><br><span class=\"line\">cpu13 430200 0 19278 8479849 2344 0 1 0 0 0</span><br><span class=\"line\">cpu14 312421 0 11483 8601843 2906 0 1 0 0 0</span><br><span class=\"line\">cpu15 343656 3 10768 8575706 1268 0 0 0 0 0</span><br><span class=\"line\">cpu16 302673 0 12190 8613170 2190 0 0 0 0 0</span><br><span class=\"line\">cpu17 263473 4 9906 8656857 771 0 0 0 0 0</span><br><span class=\"line\">cpu18 263094 370 11278 8653940 2165 0 11 0 0 0</span><br><span class=\"line\">cpu19 281216 3 11166 8637253 1280 0 6 0 0 0</span><br><span class=\"line\">cpu20 280412 0 11645 8637433 1221 0 9 0 0 0</span><br><span class=\"line\">cpu21 277219 143 11967 8639929 1048 0 2 0 0 0</span><br><span class=\"line\">cpu22 275894 0 10291 8640508 1271 0 153 0 0 0</span><br><span class=\"line\">cpu23 298806 0 11985 8618261 1939 0 6 0 0 0</span><br></pre></td></tr></table></figure>\n<h3 id=\"awk-命令\"><a href=\"#awk-命令\" class=\"headerlink\" title=\"awk 命令\"></a>awk 命令</h3><p>之后使用awk命令再次进行操作。这个命令之前用的很少，参考《鸟哥的Linux私房菜》介绍：</p>\n<p>sed常用于一整行的处理，awk则倾向于将一行分成数个“字段”来处理，awk适合处理小型的数据。</p>\n<p>用法为：</p>\n<p><code>awk &#39;条件类型1{操作1} 条件类型1{操作2}...&#39;  filename</code></p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>变量名称</th>\n<th>意义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>NF</td>\n<td>每一行（$0） 拥有的字段总数</td>\n</tr>\n<tr>\n<td>NR</td>\n<td>awk当前处理的第几行数据</td>\n</tr>\n<tr>\n<td>FS</td>\n<td>目前的分割符，默认空格键</td>\n</tr>\n</tbody>\n</table>\n</div>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cpulog_start=$(cat /proc/stat | grep 'cpu'| awk 'NR==1&#123;print $2 \"\\t\" $3 \"\\t\" $4 \"\\t\" $5 \"\\t\" $6 \"\\t\" $7 \"\\t\" $8&#125;' )</span><br></pre></td></tr></table></figure>\n<p><code>NR==1</code> 限定条件为第一行，因为第一行的数据才是cpu的总信息，{}里面的操作是输出字段，$N 就是第N个字段。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> $1\t$2\t\t$3\t\t$4\t  $5\t\t$6\t\t $7\t  $8</span><br><span class=\"line\">     user\t nice  system idle      iowait   irq  softirq</span><br><span class=\"line\">cpu  7283854 35392 293546 204419077 75835    0    8385</span><br></pre></td></tr></table></figure>\n<h3 id=\"expr\"><a href=\"#expr\" class=\"headerlink\" title=\"expr\"></a>expr</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cpu_use_diff=`expr <span class=\"variable\">$cpu_use_end</span> - <span class=\"variable\">$cpu_use_start</span>`</span><br></pre></td></tr></table></figure>\n<p>使用expr 执行变量计算，然后是`` 进行反引用将值赋值给cpu_use_diff</p>\n<p>注意shell 脚本中= 不能用空格分开 需要直接相邻</p>\n<h3 id=\"bc-命令\"><a href=\"#bc-命令\" class=\"headerlink\" title=\"bc 命令\"></a>bc 命令</h3><p>bc 命令是任意精度计算器语言，通常在linux下当计算器用。</p>\n<p>简单的描述参考：<a href=\"http://www.runoob.com/linux/linux-comm-bc.html\" target=\"_blank\" rel=\"noopener\">http://www.runoob.com/linux/linux-comm-bc.html</a></p>\n<p>而expr命令不支持小数运算，所以需要使用bc进行计算。</p>\n<p>语法为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bc(选项)(参数)</span><br></pre></td></tr></table></figure>\n<p><strong>选项值</strong></p>\n<ul>\n<li>-i：强制进入交互式模式；</li>\n<li>-l：定义使用的标准数学库</li>\n<li>； -w：对POSIX bc的扩展给出警告信息；</li>\n<li>-q：不打印正常的GNU bc环境信息；</li>\n<li>-v：显示指令版本信息；</li>\n<li>-h：显示指令的帮助信息。</li>\n</ul>\n<p><strong>参数</strong></p>\n<p>文件：指定包含计算任务的文件。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://blog.csdn.net/x_i_y_u_e/article/details/50684508\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/x_i_y_u_e/article/details/50684508</a></p>\n","site":{"data":{}},"length":7099,"excerpt":"<h1 id=\"计算Linux系统的CPU利用率\"><a href=\"#计算Linux系统的CPU利用率\" class=\"headerlink\" title=\"计算Linux系统的CPU利用率\"></a>计算Linux系统的CPU利用率</h1><p>通过读取系统的/proc/stat 信息来计算CPU的利用率</p>","more":"<h2 id=\"cpu-信息的读取\"><a href=\"#cpu-信息的读取\" class=\"headerlink\" title=\"cpu 信息的读取\"></a>cpu 信息的读取</h2><p>摘自参考博客：<a href=\"https://blog.csdn.net/x_i_y_u_e/article/details/50684508\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/x_i_y_u_e/article/details/50684508</a></p>\n<p>在Linux/Unix下，CPU利用率分为用户态，系统态和空闲态，分别表示CPU处于用户态执行的时间，系统内核执行的时间，和空闲系统进程执行的时间。平时所说的CPU利用率是指：CPU执行非系统空闲进程的时间 / CPU总的执行时间。</p>\n<p>在Linux的内核中，有一个全局变量：Jiffies。 Jiffies代表时间。它的单位随硬件平台的不同而不同。系统里定义了一个常数HZ，代表每秒种最小时间间隔的数目。这样jiffies的单位就是1/HZ。Intel平台jiffies的单位是1/100秒，这就是系统所能分辨的最小时间间隔了。每个CPU时间片，Jiffies都要加1。 CPU的利用率就是用执行用户态+系统态的Jiffies除以总的Jifffies来表示。</p>\n<p>在Linux系统中，可以用/proc/stat文件来计算cpu的利用率(详细的解释可参考：<a href=\"http://www.linuxhowtos.org/System/procstat.htm\" target=\"_blank\" rel=\"noopener\">http://www.linuxhowtos.org/System/procstat.htm</a>)。这个文件包含了所有CPU活动的信息，该文件中的所有值都是从系统启动开始累计到当前时刻。</p>\n<p>在本机上的信息如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> root@hw103:/home/yky# cat/proc/stat </span><br><span class=\"line\">cpu  7283854 35392 293546 204419077 75835 0 8385 0 0 0</span><br><span class=\"line\">cpu0 365010 48 18204 8453603 767 0 4306 0 0 0</span><br><span class=\"line\">cpu1 292817 9 14990 8526563 1358 0 2114 0 0 0</span><br><span class=\"line\">cpu2 286689 0 11880 8538662 1033 0 752 0 0 0</span><br><span class=\"line\">cpu3 287106 14624 12945 8523209 641 0 320 0 0 0</span><br><span class=\"line\">cpu4 293293 0 11784 8532282 604 0 147 0 0 0</span><br><span class=\"line\">cpu5 371312 2824 13669 8408187 40794 0 406 0 0 0</span><br><span class=\"line\">cpu6 358116 10934 14014 8453775 1230 0 68 0 0 0</span><br><span class=\"line\">cpu7 313971 6281 12243 8504303 1575 0 28 0 0 0</span><br><span class=\"line\">cpu8 318084 0 11598 8506770 2036 0 15 0 0 0</span><br><span class=\"line\">cpu9 294503 0 11137 8530318 2185 0 10 0 0 0</span><br><span class=\"line\">cpu10 307922 144 12434 8516570 1177 0 15 0 0 0</span><br><span class=\"line\">cpu11 291752 0 11502 8533957 1128 0 4 0 0 0</span><br><span class=\"line\">cpu12 315096 0 15927 8503001 3528 0 3 0 0 0</span><br><span class=\"line\">cpu13 375976 0 17927 8442873 2041 0 1 0 0 0</span><br><span class=\"line\">cpu14 299344 0 10140 8523716 2818 0 1 0 0 0</span><br><span class=\"line\">cpu15 288470 3 10146 8538685 1240 0 0 0 0 0</span><br><span class=\"line\">cpu16 301148 0 10681 8523612 2185 0 0 0 0 0</span><br><span class=\"line\">cpu17 263183 4 9149 8565345 771 0 0 0 0 0</span><br><span class=\"line\">cpu18 262518 370 10343 8562955 2105 0 11 0 0 0</span><br><span class=\"line\">cpu19 280230 3 10399 8546414 1227 0 6 0 0 0</span><br><span class=\"line\">cpu20 278962 0 10346 8547585 1221 0 9 0 0 0</span><br><span class=\"line\">cpu21 277042 143 11502 8547940 1048 0 2 0 0 0</span><br><span class=\"line\">cpu22 275560 0 9458 8549093 1271 0 153 0 0 0</span><br><span class=\"line\">cpu23 285740 0 11118 8539648 1838 0 6 0 0 0</span><br><span class=\"line\">intr 91288599 43 2 0 0 0 0 0 0 1 0 0 0 4 0 0 0 41 0 2 0 0 0 0 0 0 0 334158 0 1 2473208 45518 96917 44876 138077 45263 45258 54441 0 0 44198 44198 44198 44198 44198 44198 441</span><br><span class=\"line\">98 44198 0 0 44198 44198 44198 44198 44198 44198 44198 44198 0 0 44199 44199 44199 44199 44199 44199 44199 44199 0 0 44199 44199 44199 44199 44199 44199 44199 44199 0 0 44198 44198 44198 44198 44198 44198 44198 44198 0 0 44198 44198 44198 44198 44198 44198 44198 44198 0 0 44199 44199 44199 44199 44199 44199 44199 44199 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0ctxt 42731429</span><br><span class=\"line\">btime 1553933982</span><br><span class=\"line\">processes 190449</span><br><span class=\"line\">procs_running 5</span><br><span class=\"line\">procs_blocked 0</span><br><span class=\"line\">softirq 57291816 8 26401645 17536 5419485 334063 0 1044 10019160 0 15098875</span><br></pre></td></tr></table></figure>\n<p>第一行cpu是总的cpu信息，其他的cpu0-cpu23 是24个核的信息。</p>\n<p>计算cpu利用率只用到前7个参数， 对应的参数解释为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t user\t nice  system idle      iowait   irq  softirq</span><br><span class=\"line\">cpu  7283854 35392 293546 204419077 75835    0    8385</span><br></pre></td></tr></table></figure>\n<p>user (7283854) 从系统启动开始累计到当前时刻，用户态的CPU时间（单位：jiffies） ，不包含 nice值为负进程。1jiffies=0.01秒<br>nice (35392) 从系统启动开始累计到当前时刻，nice值为负的进程所占用的CPU时间（单位：jiffies）<br>system (293546) 从系统启动开始累计到当前时刻，核心时间（单位：jiffies）<br>idle (204419077) 从系统启动开始累计到当前时刻，除硬盘IO等待时间以外其它等待时间（单位：jiffies）<br>iowait (75835) 从系统启动开始累计到当前时刻，硬盘IO等待时间（单位：jiffies） ，<br>irq (0) 从系统启动开始累计到当前时刻，硬中断时间（单位：jiffies）<br>softirq (8385) 从系统启动开始累计到当前时刻，软中断时间（单位：jiffies）</p>\n<p>CPU时间=user+system+nice+idle+iowait+irq+softirq</p>\n<p>“intr”这行给出中断的信息，第一个为自系统启动以来，发生的所有的中断的次数；然后每个数对应一个特定的中断自系统启动以来所发生的次数。<br>“ctxt”给出了自系统启动以来CPU发生的上下文交换的次数。<br>“btime”给出了从系统启动到现在为止的时间，单位为秒。<br>“processes (total_forks) 自系统启动以来所创建的任务的个数目。<br>“procs_running”：当前运行队列的任务的数目。<br>“procs_blocked”：当前被阻塞的任务的数目。</p>\n<p>计算cpu利用率的方法就是计算出在一段时间里面，cpu工作的时间/总得时间</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cpu usage=(idle2-idle1)/(cpu2-cpu1)*100</span><br><span class=\"line\">cpu usage=[(user_2 +sys_2+nice_2) - (user_1 + sys_1+nice_1)]/(total_2 - total_1)*100</span><br></pre></td></tr></table></figure>\n<p>第二中方法只把user+sys+nice 这三个时间看作cpu的工作时间，因为其他的几个比较小。</p>\n<h2 id=\"shell脚本\"><a href=\"#shell脚本\" class=\"headerlink\" title=\"shell脚本\"></a>shell脚本</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span>!/bin/bash</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span>#echo user nice system idle iowait irq softirq</span><br><span class=\"line\"></span><br><span class=\"line\">cpulog_start=$(cat /proc/stat | grep 'cpu'| awk 'NR==1&#123;print $2 \"\\t\" $3 \"\\t\" $4 \"\\t\" $5 \"\\t\" $6 \"\\t\" $7 \"\\t\" $8&#125;' )</span><br><span class=\"line\">cpu_use_start=$(echo $cpulog_start | awk '&#123;print $1+$2+$3&#125;')</span><br><span class=\"line\">cpu_iowait_start=$(echo $cpulog_start | awk '&#123;print $5&#125;')</span><br><span class=\"line\">cpu_total_start=$(echo $cpulog_start | awk '&#123;print $1+$2+$3+$4+$5+$6+$7&#125;')</span><br><span class=\"line\"></span><br><span class=\"line\">sleep 10</span><br><span class=\"line\"></span><br><span class=\"line\">cpulog_end=$(cat /proc/stat | grep 'cpu'| awk 'NR==1&#123;print $2 \"\\t\" $3 \"\\t\" $4 \"\\t\" $5 \"\\t\" $6 \"\\t\" $7 \"\\t\" $8&#125;' )</span><br><span class=\"line\">cpu_use_end=$(echo $cpulog_end | awk '&#123;print $1+$2+$3&#125;')</span><br><span class=\"line\">cpu_iowait_end=$(echo $cpulog_end | awk '&#123;print $5&#125;')</span><br><span class=\"line\">cpu_total_end=$(echo $cpulog_end | awk '&#123;print $1+$2+$3+$4+$5+$6+$7&#125;')</span><br><span class=\"line\"></span><br><span class=\"line\">cpu_use_diff=`expr $cpu_use_end - $cpu_use_start`</span><br><span class=\"line\">cpu_iowait_diff=`expr $cpu_iowait_end - $cpu_iowait_start`</span><br><span class=\"line\">cpu_total_diff=`expr $cpu_total_end - $cpu_total_start`</span><br><span class=\"line\"></span><br><span class=\"line\">cpu_use_rate=`expr $cpu_use_diff/$cpu_total_diff*100 | bc -l`</span><br><span class=\"line\">cpu_iowait_rate=`expr $cpu_iowait_diff/$cpu_total_diff*100 | bc -l`</span><br><span class=\"line\"></span><br><span class=\"line\">echo \"---------------cpuinfo----------------------\"</span><br><span class=\"line\">echo \"cpu_usage_rate (%) : $cpu_use_rate\"</span><br><span class=\"line\">echo \"cpu_iowait_rate (%): $cpu_iowait_rate\"</span><br></pre></td></tr></table></figure>\n<p>主要的知识点讲解：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cpulog_start=$(cat /proc/stat | grep 'cpu'| awk 'NR==1&#123;print $2 \"\\t\" $3 \"\\t\" $4 \"\\t\" $5 \"\\t\" $6 \"\\t\" $7 \"\\t\" $8&#125;' )</span><br></pre></td></tr></table></figure>\n<p>这一句先将/proc/stat文件的信息读取出来然后用管道| 传递给grep 命令 ,grep 将包含cpu的信息给提取出来</p>\n<p><code>cat /proc/stat | grep &#39;cpu&#39;</code> 输出为：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@hw103:/home/yky<span class=\"comment\"># cat /proc/stat | grep 'cpu'</span></span><br><span class=\"line\">cpu  7645369 35392 318219 206250476 80895 0 9870 0 0 0</span><br><span class=\"line\">cpu0 365256 48 18792 8544685 767 0 5678 0 0 0</span><br><span class=\"line\">cpu1 292983 9 15427 8618292 1389 0 2206 0 0 0</span><br><span class=\"line\">cpu2 287020 0 12884 8629895 1033 0 760 0 0 0</span><br><span class=\"line\">cpu3 288372 14624 13910 8613386 681 0 320 0 0 0</span><br><span class=\"line\">cpu4 293707 0 13074 8623117 646 0 147 0 0 0</span><br><span class=\"line\">cpu5 390012 2824 15130 8477387 44027 0 418 0 0 0</span><br><span class=\"line\">cpu6 362140 10934 15217 8541127 1233 0 69 0 0 0</span><br><span class=\"line\">cpu7 377620 6281 12915 8532734 1700 0 28 0 0 0</span><br><span class=\"line\">cpu8 333520 0 12524 8582987 2100 0 15 0 0 0</span><br><span class=\"line\">cpu9 348913 0 12619 8567005 2453 0 10 0 0 0</span><br><span class=\"line\">cpu10 333584 144 14002 8581939 1297 0 15 0 0 0</span><br><span class=\"line\">cpu11 292980 0 12966 8623861 1137 0 4 0 0 0</span><br><span class=\"line\">cpu12 350188 0 16793 8559301 4017 0 3 0 0 0</span><br><span class=\"line\">cpu13 430200 0 19278 8479849 2344 0 1 0 0 0</span><br><span class=\"line\">cpu14 312421 0 11483 8601843 2906 0 1 0 0 0</span><br><span class=\"line\">cpu15 343656 3 10768 8575706 1268 0 0 0 0 0</span><br><span class=\"line\">cpu16 302673 0 12190 8613170 2190 0 0 0 0 0</span><br><span class=\"line\">cpu17 263473 4 9906 8656857 771 0 0 0 0 0</span><br><span class=\"line\">cpu18 263094 370 11278 8653940 2165 0 11 0 0 0</span><br><span class=\"line\">cpu19 281216 3 11166 8637253 1280 0 6 0 0 0</span><br><span class=\"line\">cpu20 280412 0 11645 8637433 1221 0 9 0 0 0</span><br><span class=\"line\">cpu21 277219 143 11967 8639929 1048 0 2 0 0 0</span><br><span class=\"line\">cpu22 275894 0 10291 8640508 1271 0 153 0 0 0</span><br><span class=\"line\">cpu23 298806 0 11985 8618261 1939 0 6 0 0 0</span><br></pre></td></tr></table></figure>\n<h3 id=\"awk-命令\"><a href=\"#awk-命令\" class=\"headerlink\" title=\"awk 命令\"></a>awk 命令</h3><p>之后使用awk命令再次进行操作。这个命令之前用的很少，参考《鸟哥的Linux私房菜》介绍：</p>\n<p>sed常用于一整行的处理，awk则倾向于将一行分成数个“字段”来处理，awk适合处理小型的数据。</p>\n<p>用法为：</p>\n<p><code>awk &#39;条件类型1{操作1} 条件类型1{操作2}...&#39;  filename</code></p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>变量名称</th>\n<th>意义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>NF</td>\n<td>每一行（$0） 拥有的字段总数</td>\n</tr>\n<tr>\n<td>NR</td>\n<td>awk当前处理的第几行数据</td>\n</tr>\n<tr>\n<td>FS</td>\n<td>目前的分割符，默认空格键</td>\n</tr>\n</tbody>\n</table>\n</div>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cpulog_start=$(cat /proc/stat | grep 'cpu'| awk 'NR==1&#123;print $2 \"\\t\" $3 \"\\t\" $4 \"\\t\" $5 \"\\t\" $6 \"\\t\" $7 \"\\t\" $8&#125;' )</span><br></pre></td></tr></table></figure>\n<p><code>NR==1</code> 限定条件为第一行，因为第一行的数据才是cpu的总信息，{}里面的操作是输出字段，$N 就是第N个字段。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> $1\t$2\t\t$3\t\t$4\t  $5\t\t$6\t\t $7\t  $8</span><br><span class=\"line\">     user\t nice  system idle      iowait   irq  softirq</span><br><span class=\"line\">cpu  7283854 35392 293546 204419077 75835    0    8385</span><br></pre></td></tr></table></figure>\n<h3 id=\"expr\"><a href=\"#expr\" class=\"headerlink\" title=\"expr\"></a>expr</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cpu_use_diff=`expr <span class=\"variable\">$cpu_use_end</span> - <span class=\"variable\">$cpu_use_start</span>`</span><br></pre></td></tr></table></figure>\n<p>使用expr 执行变量计算，然后是`` 进行反引用将值赋值给cpu_use_diff</p>\n<p>注意shell 脚本中= 不能用空格分开 需要直接相邻</p>\n<h3 id=\"bc-命令\"><a href=\"#bc-命令\" class=\"headerlink\" title=\"bc 命令\"></a>bc 命令</h3><p>bc 命令是任意精度计算器语言，通常在linux下当计算器用。</p>\n<p>简单的描述参考：<a href=\"http://www.runoob.com/linux/linux-comm-bc.html\" target=\"_blank\" rel=\"noopener\">http://www.runoob.com/linux/linux-comm-bc.html</a></p>\n<p>而expr命令不支持小数运算，所以需要使用bc进行计算。</p>\n<p>语法为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bc(选项)(参数)</span><br></pre></td></tr></table></figure>\n<p><strong>选项值</strong></p>\n<ul>\n<li>-i：强制进入交互式模式；</li>\n<li>-l：定义使用的标准数学库</li>\n<li>； -w：对POSIX bc的扩展给出警告信息；</li>\n<li>-q：不打印正常的GNU bc环境信息；</li>\n<li>-v：显示指令版本信息；</li>\n<li>-h：显示指令的帮助信息。</li>\n</ul>\n<p><strong>参数</strong></p>\n<p>文件：指定包含计算任务的文件。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://blog.csdn.net/x_i_y_u_e/article/details/50684508\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/x_i_y_u_e/article/details/50684508</a></p>"},{"title":"剑指offer 读书笔记——第2章","date":"2019-03-27T12:31:08.000Z","copyright":true,"_content":"\n# 剑指offer 读书笔记——第2章 \n\n感觉自己的代码能力还在很弱，所以又第二遍仔细的阅读剑指offer了\n\n第二章 面试需要的基础知识\n\n<!--more-->\n\n## 面试题1 赋值运算函数\n\n所谓赋值运算函数就是对=这个操作符进行重载，从而使等号能够直接用于两个实例之间的赋值。这个C++课上学过，不过现在忘完了，只记得学过。\n\n### 经典解法\n\n需要考虑的点\n\n1. **返回值的类型**声明为该类型的引用，在函数结束前返回实例自身的引用(***this**)。只有返回一个引用，才可以连续赋值。`object1=object2=object3`就是连续赋值。赋值采用右结合律，从最右边开始计算。不然的话当首先执行完`object2=object3` 后，`object2` 虽然自己的成员已经得到了更改，但是它不能再作为`object1=object2` 这个等号的右值，因为在前一个=的执行中，它没有获得返回值。而返回对象的话，就需要重新执行新建一个对象和销毁对象的构造与析构操作，增加不必要开销，降低赋值函数的效率。\n2. 传入的参数申明为**常量引用**\n3. **释放**实例自身已有的**内存**\n4. **判断**传入参数是否和当前的**实例相同**，相同的话不进行赋值操作，直接返回实例。\n\n\n\n代码：初级版\n\n```c++\nCMyString& CMyString::operator = (const CMyString& str)\n{\n    if(this == &str)\n        return *this;\n\n    delete []m_pData;\n    m_pData = nullptr;\n\n    m_pData = new char[strlen(str.m_pData) + 1]; //给strcpy复制的字符串申请空间\n    strcpy(m_pData, str.m_pData);\n\n    return *this;\n}\n```\n\n代码：高级版\n\n```c++\nCMyString& CMyString::operator = (const CMyString& str)\n{\n    if(this != &str){\n    \tCMyString strTemp(str);   // 新建一个实例 \n        \n        char *pTemp=strTemp.m_pData;   // 新建一个临时指针保存数据\n        strTemp.m_pData = m_pData; \t\t// 交换\n        m_pData = pTemp;\n    }\n    return *this;\n}\n```\n\n初级版在使用new分配内存的时候，已经把原来的数据给清楚了（`delete []m_pData;`）,这时在新分配内存的时候，如果内存不足会导致new char抛出异常，使得m_pData 变成一个空指针，这样很容易导致程序崩溃。因为在抛出异常之后，原来的CMyString实例因为数据被delete了，所以不再保持有效的状态，违背了异常安全性的原则。 （可以先将原来的数据备份，等new 成功了，再将原来的数据delete给释放掉）\n\n代码思路：新建一个实例，新建一个临时指针从而用于数据交换。\n\n````\ntmp    tmp\n^       |\n|       \nstr<--this \n先将str的值备份到tmp中，然后将str的值更新为this的值，然后在把this的值更新为tmp的值\n两个数据的交换必然需要新建第三个变量来存放其中一个变量的值。\n````\n\n\n\n之所以需要新建一个实例是因为实例是个临时变量，所以完成操作后会自动释放掉他的数据，也就是原来的数据。\n\n指针与引用的异同\n\n常量指针与常量引用。\n\n对于引用只有两种描述：\n\n```\n// 对常量类型的引用  \nconst type &ref = type a;\n//对变量类型的引用\ntype &ref = type a;\n```\n\n对常量类型的引用  实际上既可以对常量类型引用，也可以对变量类型引用，但是不能通过引用来修改它引用的对象。\n\n对于指针的修饰有4种：\n\n````\n// 普通的指针 poi is a pointer point to a type  ，\n//指针的值（指向的地址，可以改变），被指向的变量的值也可以改变\ntype *poi;\n\n//常量指针 poi is a const pointer point to a type \n//指针的值（指向的地址）不能改变，被指向的变量的值可以改变\ntype *const poi;\n\n// poi is a pointer point to a const type\n//指针的值（指向的地址）可以改变，所以指针可以指向其他变量，\n//被指向的变量的值不可以改变，所以指针不能修改指向的变量的值，\nconst type *poi;\n\n// poi is a const pointer point to a const type\n// 指针的值（指向的地址）不能改变，所以指针不能指向其他变量，\n//被指向的变量的不可以改变，所以指针不能修改指向的变量的值\nconst type *const poi;\n````\n\n以* &作为分割符进行读取，const作为前缀修饰的对象,对象存储的值不变。\n\n对于指向const type 的指针或者引用而言，指向的（引用的）变量类型不一定是常量，但是无法通过指针或者引用来修改其指向的（引用的）变量的值。《C++primer》中所说：所谓指向常量的指针或引用，不过是指针自以为自己指向了一个常量，所以自觉地不去改变所指对象的值。\n\n## 疑惑\n\n1. 为什么申明的返回值是引用，而返回的却是指针？\n   - 引用是地址的别名,但是不分配内存空间。 `CMyString &A= *this`   这里*this是指向CMyString这个类的实例的地址，而A是CMyString的一个实例的引用，是引用就需要与这个实例的内存地址相关联，所以可以传入 *this ，也就是实例的地址。 本来 =号用于赋值的时候，左值是地址，右值是变量地址上的数据也就是变量的值，但是引用的=号的右值是变量的地址。所以可以传入地址，也就是指针。\n2. 传入的参数是个常量引用，为什么不使用常量指针： `const CMyString *str`\n   - 虽然`const CMyString *str` 和`congst CMyString &str` 都不能去修改实参的值了，但是引用不是对象，是不分配内存的啊，使用指针的话，肯定会占用内存，然后不用的时候销毁内存，所以效率会降低。而且引用是一定不会空的，所以不用考虑所指的对象是否为空。（提升效率的关键，可以不申请内存就不申请内存，因为不管是自己去释放，还是系统自动回收，分配和回收都会带来效率的下降。所以能用指针就用指针，能用引用就用引用，最坏的情况才是值拷贝。）（ **对象**是指一块能存储数据并具有某种类型的内存空间）","source":"_posts/2019-03-27-剑指offer-读书笔记——第2章.md","raw":"---\ntitle: 剑指offer 读书笔记——第2章\ndate: 2019-03-27 20:31:08\ncategories: 读书笔记\ntags:\n- coding\n- c++\ncopyright: true\n---\n\n# 剑指offer 读书笔记——第2章 \n\n感觉自己的代码能力还在很弱，所以又第二遍仔细的阅读剑指offer了\n\n第二章 面试需要的基础知识\n\n<!--more-->\n\n## 面试题1 赋值运算函数\n\n所谓赋值运算函数就是对=这个操作符进行重载，从而使等号能够直接用于两个实例之间的赋值。这个C++课上学过，不过现在忘完了，只记得学过。\n\n### 经典解法\n\n需要考虑的点\n\n1. **返回值的类型**声明为该类型的引用，在函数结束前返回实例自身的引用(***this**)。只有返回一个引用，才可以连续赋值。`object1=object2=object3`就是连续赋值。赋值采用右结合律，从最右边开始计算。不然的话当首先执行完`object2=object3` 后，`object2` 虽然自己的成员已经得到了更改，但是它不能再作为`object1=object2` 这个等号的右值，因为在前一个=的执行中，它没有获得返回值。而返回对象的话，就需要重新执行新建一个对象和销毁对象的构造与析构操作，增加不必要开销，降低赋值函数的效率。\n2. 传入的参数申明为**常量引用**\n3. **释放**实例自身已有的**内存**\n4. **判断**传入参数是否和当前的**实例相同**，相同的话不进行赋值操作，直接返回实例。\n\n\n\n代码：初级版\n\n```c++\nCMyString& CMyString::operator = (const CMyString& str)\n{\n    if(this == &str)\n        return *this;\n\n    delete []m_pData;\n    m_pData = nullptr;\n\n    m_pData = new char[strlen(str.m_pData) + 1]; //给strcpy复制的字符串申请空间\n    strcpy(m_pData, str.m_pData);\n\n    return *this;\n}\n```\n\n代码：高级版\n\n```c++\nCMyString& CMyString::operator = (const CMyString& str)\n{\n    if(this != &str){\n    \tCMyString strTemp(str);   // 新建一个实例 \n        \n        char *pTemp=strTemp.m_pData;   // 新建一个临时指针保存数据\n        strTemp.m_pData = m_pData; \t\t// 交换\n        m_pData = pTemp;\n    }\n    return *this;\n}\n```\n\n初级版在使用new分配内存的时候，已经把原来的数据给清楚了（`delete []m_pData;`）,这时在新分配内存的时候，如果内存不足会导致new char抛出异常，使得m_pData 变成一个空指针，这样很容易导致程序崩溃。因为在抛出异常之后，原来的CMyString实例因为数据被delete了，所以不再保持有效的状态，违背了异常安全性的原则。 （可以先将原来的数据备份，等new 成功了，再将原来的数据delete给释放掉）\n\n代码思路：新建一个实例，新建一个临时指针从而用于数据交换。\n\n````\ntmp    tmp\n^       |\n|       \nstr<--this \n先将str的值备份到tmp中，然后将str的值更新为this的值，然后在把this的值更新为tmp的值\n两个数据的交换必然需要新建第三个变量来存放其中一个变量的值。\n````\n\n\n\n之所以需要新建一个实例是因为实例是个临时变量，所以完成操作后会自动释放掉他的数据，也就是原来的数据。\n\n指针与引用的异同\n\n常量指针与常量引用。\n\n对于引用只有两种描述：\n\n```\n// 对常量类型的引用  \nconst type &ref = type a;\n//对变量类型的引用\ntype &ref = type a;\n```\n\n对常量类型的引用  实际上既可以对常量类型引用，也可以对变量类型引用，但是不能通过引用来修改它引用的对象。\n\n对于指针的修饰有4种：\n\n````\n// 普通的指针 poi is a pointer point to a type  ，\n//指针的值（指向的地址，可以改变），被指向的变量的值也可以改变\ntype *poi;\n\n//常量指针 poi is a const pointer point to a type \n//指针的值（指向的地址）不能改变，被指向的变量的值可以改变\ntype *const poi;\n\n// poi is a pointer point to a const type\n//指针的值（指向的地址）可以改变，所以指针可以指向其他变量，\n//被指向的变量的值不可以改变，所以指针不能修改指向的变量的值，\nconst type *poi;\n\n// poi is a const pointer point to a const type\n// 指针的值（指向的地址）不能改变，所以指针不能指向其他变量，\n//被指向的变量的不可以改变，所以指针不能修改指向的变量的值\nconst type *const poi;\n````\n\n以* &作为分割符进行读取，const作为前缀修饰的对象,对象存储的值不变。\n\n对于指向const type 的指针或者引用而言，指向的（引用的）变量类型不一定是常量，但是无法通过指针或者引用来修改其指向的（引用的）变量的值。《C++primer》中所说：所谓指向常量的指针或引用，不过是指针自以为自己指向了一个常量，所以自觉地不去改变所指对象的值。\n\n## 疑惑\n\n1. 为什么申明的返回值是引用，而返回的却是指针？\n   - 引用是地址的别名,但是不分配内存空间。 `CMyString &A= *this`   这里*this是指向CMyString这个类的实例的地址，而A是CMyString的一个实例的引用，是引用就需要与这个实例的内存地址相关联，所以可以传入 *this ，也就是实例的地址。 本来 =号用于赋值的时候，左值是地址，右值是变量地址上的数据也就是变量的值，但是引用的=号的右值是变量的地址。所以可以传入地址，也就是指针。\n2. 传入的参数是个常量引用，为什么不使用常量指针： `const CMyString *str`\n   - 虽然`const CMyString *str` 和`congst CMyString &str` 都不能去修改实参的值了，但是引用不是对象，是不分配内存的啊，使用指针的话，肯定会占用内存，然后不用的时候销毁内存，所以效率会降低。而且引用是一定不会空的，所以不用考虑所指的对象是否为空。（提升效率的关键，可以不申请内存就不申请内存，因为不管是自己去释放，还是系统自动回收，分配和回收都会带来效率的下降。所以能用指针就用指针，能用引用就用引用，最坏的情况才是值拷贝。）（ **对象**是指一块能存储数据并具有某种类型的内存空间）","slug":"2019-03-27-剑指offer-读书笔记——第2章","published":1,"updated":"2019-11-08T13:14:34.631Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2yelxh00008m8tzixp8trq7","content":"<h1 id=\"剑指offer-读书笔记——第2章\"><a href=\"#剑指offer-读书笔记——第2章\" class=\"headerlink\" title=\"剑指offer 读书笔记——第2章\"></a>剑指offer 读书笔记——第2章</h1><p>感觉自己的代码能力还在很弱，所以又第二遍仔细的阅读剑指offer了</p>\n<p>第二章 面试需要的基础知识</p>\n<a id=\"more\"></a>\n<h2 id=\"面试题1-赋值运算函数\"><a href=\"#面试题1-赋值运算函数\" class=\"headerlink\" title=\"面试题1 赋值运算函数\"></a>面试题1 赋值运算函数</h2><p>所谓赋值运算函数就是对=这个操作符进行重载，从而使等号能够直接用于两个实例之间的赋值。这个C++课上学过，不过现在忘完了，只记得学过。</p>\n<h3 id=\"经典解法\"><a href=\"#经典解法\" class=\"headerlink\" title=\"经典解法\"></a>经典解法</h3><p>需要考虑的点</p>\n<ol>\n<li><strong>返回值的类型</strong>声明为该类型的引用，在函数结束前返回实例自身的引用(<strong>*this</strong>)。只有返回一个引用，才可以连续赋值。<code>object1=object2=object3</code>就是连续赋值。赋值采用右结合律，从最右边开始计算。不然的话当首先执行完<code>object2=object3</code> 后，<code>object2</code> 虽然自己的成员已经得到了更改，但是它不能再作为<code>object1=object2</code> 这个等号的右值，因为在前一个=的执行中，它没有获得返回值。而返回对象的话，就需要重新执行新建一个对象和销毁对象的构造与析构操作，增加不必要开销，降低赋值函数的效率。</li>\n<li>传入的参数申明为<strong>常量引用</strong></li>\n<li><strong>释放</strong>实例自身已有的<strong>内存</strong></li>\n<li><strong>判断</strong>传入参数是否和当前的<strong>实例相同</strong>，相同的话不进行赋值操作，直接返回实例。</li>\n</ol>\n<p>代码：初级版</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CMyString&amp; CMyString::<span class=\"keyword\">operator</span> = (<span class=\"keyword\">const</span> CMyString&amp; str)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span> == &amp;str)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">delete</span> []m_pData;</span><br><span class=\"line\">    m_pData = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    m_pData = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[<span class=\"built_in\">strlen</span>(str.m_pData) + <span class=\"number\">1</span>]; <span class=\"comment\">//给strcpy复制的字符串申请空间</span></span><br><span class=\"line\">    <span class=\"built_in\">strcpy</span>(m_pData, str.m_pData);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>代码：高级版</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CMyString&amp; CMyString::<span class=\"keyword\">operator</span> = (<span class=\"keyword\">const</span> CMyString&amp; str)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span> != &amp;str)&#123;</span><br><span class=\"line\">    \tCMyString strTemp(str);   <span class=\"comment\">// 新建一个实例 </span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">char</span> *pTemp=strTemp.m_pData;   <span class=\"comment\">// 新建一个临时指针保存数据</span></span><br><span class=\"line\">        strTemp.m_pData = m_pData; \t\t<span class=\"comment\">// 交换</span></span><br><span class=\"line\">        m_pData = pTemp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>初级版在使用new分配内存的时候，已经把原来的数据给清楚了（<code>delete []m_pData;</code>）,这时在新分配内存的时候，如果内存不足会导致new char抛出异常，使得m_pData 变成一个空指针，这样很容易导致程序崩溃。因为在抛出异常之后，原来的CMyString实例因为数据被delete了，所以不再保持有效的状态，违背了异常安全性的原则。 （可以先将原来的数据备份，等new 成功了，再将原来的数据delete给释放掉）</p>\n<p>代码思路：新建一个实例，新建一个临时指针从而用于数据交换。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tmp    tmp</span><br><span class=\"line\">^       |</span><br><span class=\"line\">|       </span><br><span class=\"line\">str&lt;--this </span><br><span class=\"line\">先将str的值备份到tmp中，然后将str的值更新为this的值，然后在把this的值更新为tmp的值</span><br><span class=\"line\">两个数据的交换必然需要新建第三个变量来存放其中一个变量的值。</span><br></pre></td></tr></table></figure>\n<p>之所以需要新建一个实例是因为实例是个临时变量，所以完成操作后会自动释放掉他的数据，也就是原来的数据。</p>\n<p>指针与引用的异同</p>\n<p>常量指针与常量引用。</p>\n<p>对于引用只有两种描述：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 对常量类型的引用  </span><br><span class=\"line\">const type &amp;ref = type a;</span><br><span class=\"line\">//对变量类型的引用</span><br><span class=\"line\">type &amp;ref = type a;</span><br></pre></td></tr></table></figure>\n<p>对常量类型的引用  实际上既可以对常量类型引用，也可以对变量类型引用，但是不能通过引用来修改它引用的对象。</p>\n<p>对于指针的修饰有4种：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 普通的指针 poi is a pointer point to a type  ，</span><br><span class=\"line\">//指针的值（指向的地址，可以改变），被指向的变量的值也可以改变</span><br><span class=\"line\">type *poi;</span><br><span class=\"line\"></span><br><span class=\"line\">//常量指针 poi is a const pointer point to a type </span><br><span class=\"line\">//指针的值（指向的地址）不能改变，被指向的变量的值可以改变</span><br><span class=\"line\">type *const poi;</span><br><span class=\"line\"></span><br><span class=\"line\">// poi is a pointer point to a const type</span><br><span class=\"line\">//指针的值（指向的地址）可以改变，所以指针可以指向其他变量，</span><br><span class=\"line\">//被指向的变量的值不可以改变，所以指针不能修改指向的变量的值，</span><br><span class=\"line\">const type *poi;</span><br><span class=\"line\"></span><br><span class=\"line\">// poi is a const pointer point to a const type</span><br><span class=\"line\">// 指针的值（指向的地址）不能改变，所以指针不能指向其他变量，</span><br><span class=\"line\">//被指向的变量的不可以改变，所以指针不能修改指向的变量的值</span><br><span class=\"line\">const type *const poi;</span><br></pre></td></tr></table></figure>\n<p>以* &amp;作为分割符进行读取，const作为前缀修饰的对象,对象存储的值不变。</p>\n<p>对于指向const type 的指针或者引用而言，指向的（引用的）变量类型不一定是常量，但是无法通过指针或者引用来修改其指向的（引用的）变量的值。《C++primer》中所说：所谓指向常量的指针或引用，不过是指针自以为自己指向了一个常量，所以自觉地不去改变所指对象的值。</p>\n<h2 id=\"疑惑\"><a href=\"#疑惑\" class=\"headerlink\" title=\"疑惑\"></a>疑惑</h2><ol>\n<li>为什么申明的返回值是引用，而返回的却是指针？<ul>\n<li>引用是地址的别名,但是不分配内存空间。 <code>CMyString &amp;A= *this</code>   这里<em>this是指向CMyString这个类的实例的地址，而A是CMyString的一个实例的引用，是引用就需要与这个实例的内存地址相关联，所以可以传入 </em>this ，也就是实例的地址。 本来 =号用于赋值的时候，左值是地址，右值是变量地址上的数据也就是变量的值，但是引用的=号的右值是变量的地址。所以可以传入地址，也就是指针。</li>\n</ul>\n</li>\n<li>传入的参数是个常量引用，为什么不使用常量指针： <code>const CMyString *str</code><ul>\n<li>虽然<code>const CMyString *str</code> 和<code>congst CMyString &amp;str</code> 都不能去修改实参的值了，但是引用不是对象，是不分配内存的啊，使用指针的话，肯定会占用内存，然后不用的时候销毁内存，所以效率会降低。而且引用是一定不会空的，所以不用考虑所指的对象是否为空。（提升效率的关键，可以不申请内存就不申请内存，因为不管是自己去释放，还是系统自动回收，分配和回收都会带来效率的下降。所以能用指针就用指针，能用引用就用引用，最坏的情况才是值拷贝。）（ <strong>对象</strong>是指一块能存储数据并具有某种类型的内存空间）</li>\n</ul>\n</li>\n</ol>\n","site":{"data":{}},"length":2612,"excerpt":"<h1 id=\"剑指offer-读书笔记——第2章\"><a href=\"#剑指offer-读书笔记——第2章\" class=\"headerlink\" title=\"剑指offer 读书笔记——第2章\"></a>剑指offer 读书笔记——第2章</h1><p>感觉自己的代码能力还在很弱，所以又第二遍仔细的阅读剑指offer了</p>\n<p>第二章 面试需要的基础知识</p>","more":"<h2 id=\"面试题1-赋值运算函数\"><a href=\"#面试题1-赋值运算函数\" class=\"headerlink\" title=\"面试题1 赋值运算函数\"></a>面试题1 赋值运算函数</h2><p>所谓赋值运算函数就是对=这个操作符进行重载，从而使等号能够直接用于两个实例之间的赋值。这个C++课上学过，不过现在忘完了，只记得学过。</p>\n<h3 id=\"经典解法\"><a href=\"#经典解法\" class=\"headerlink\" title=\"经典解法\"></a>经典解法</h3><p>需要考虑的点</p>\n<ol>\n<li><strong>返回值的类型</strong>声明为该类型的引用，在函数结束前返回实例自身的引用(<strong>*this</strong>)。只有返回一个引用，才可以连续赋值。<code>object1=object2=object3</code>就是连续赋值。赋值采用右结合律，从最右边开始计算。不然的话当首先执行完<code>object2=object3</code> 后，<code>object2</code> 虽然自己的成员已经得到了更改，但是它不能再作为<code>object1=object2</code> 这个等号的右值，因为在前一个=的执行中，它没有获得返回值。而返回对象的话，就需要重新执行新建一个对象和销毁对象的构造与析构操作，增加不必要开销，降低赋值函数的效率。</li>\n<li>传入的参数申明为<strong>常量引用</strong></li>\n<li><strong>释放</strong>实例自身已有的<strong>内存</strong></li>\n<li><strong>判断</strong>传入参数是否和当前的<strong>实例相同</strong>，相同的话不进行赋值操作，直接返回实例。</li>\n</ol>\n<p>代码：初级版</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CMyString&amp; CMyString::<span class=\"keyword\">operator</span> = (<span class=\"keyword\">const</span> CMyString&amp; str)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span> == &amp;str)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">delete</span> []m_pData;</span><br><span class=\"line\">    m_pData = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    m_pData = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[<span class=\"built_in\">strlen</span>(str.m_pData) + <span class=\"number\">1</span>]; <span class=\"comment\">//给strcpy复制的字符串申请空间</span></span><br><span class=\"line\">    <span class=\"built_in\">strcpy</span>(m_pData, str.m_pData);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>代码：高级版</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CMyString&amp; CMyString::<span class=\"keyword\">operator</span> = (<span class=\"keyword\">const</span> CMyString&amp; str)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span> != &amp;str)&#123;</span><br><span class=\"line\">    \tCMyString strTemp(str);   <span class=\"comment\">// 新建一个实例 </span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">char</span> *pTemp=strTemp.m_pData;   <span class=\"comment\">// 新建一个临时指针保存数据</span></span><br><span class=\"line\">        strTemp.m_pData = m_pData; \t\t<span class=\"comment\">// 交换</span></span><br><span class=\"line\">        m_pData = pTemp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>初级版在使用new分配内存的时候，已经把原来的数据给清楚了（<code>delete []m_pData;</code>）,这时在新分配内存的时候，如果内存不足会导致new char抛出异常，使得m_pData 变成一个空指针，这样很容易导致程序崩溃。因为在抛出异常之后，原来的CMyString实例因为数据被delete了，所以不再保持有效的状态，违背了异常安全性的原则。 （可以先将原来的数据备份，等new 成功了，再将原来的数据delete给释放掉）</p>\n<p>代码思路：新建一个实例，新建一个临时指针从而用于数据交换。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tmp    tmp</span><br><span class=\"line\">^       |</span><br><span class=\"line\">|       </span><br><span class=\"line\">str&lt;--this </span><br><span class=\"line\">先将str的值备份到tmp中，然后将str的值更新为this的值，然后在把this的值更新为tmp的值</span><br><span class=\"line\">两个数据的交换必然需要新建第三个变量来存放其中一个变量的值。</span><br></pre></td></tr></table></figure>\n<p>之所以需要新建一个实例是因为实例是个临时变量，所以完成操作后会自动释放掉他的数据，也就是原来的数据。</p>\n<p>指针与引用的异同</p>\n<p>常量指针与常量引用。</p>\n<p>对于引用只有两种描述：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 对常量类型的引用  </span><br><span class=\"line\">const type &amp;ref = type a;</span><br><span class=\"line\">//对变量类型的引用</span><br><span class=\"line\">type &amp;ref = type a;</span><br></pre></td></tr></table></figure>\n<p>对常量类型的引用  实际上既可以对常量类型引用，也可以对变量类型引用，但是不能通过引用来修改它引用的对象。</p>\n<p>对于指针的修饰有4种：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 普通的指针 poi is a pointer point to a type  ，</span><br><span class=\"line\">//指针的值（指向的地址，可以改变），被指向的变量的值也可以改变</span><br><span class=\"line\">type *poi;</span><br><span class=\"line\"></span><br><span class=\"line\">//常量指针 poi is a const pointer point to a type </span><br><span class=\"line\">//指针的值（指向的地址）不能改变，被指向的变量的值可以改变</span><br><span class=\"line\">type *const poi;</span><br><span class=\"line\"></span><br><span class=\"line\">// poi is a pointer point to a const type</span><br><span class=\"line\">//指针的值（指向的地址）可以改变，所以指针可以指向其他变量，</span><br><span class=\"line\">//被指向的变量的值不可以改变，所以指针不能修改指向的变量的值，</span><br><span class=\"line\">const type *poi;</span><br><span class=\"line\"></span><br><span class=\"line\">// poi is a const pointer point to a const type</span><br><span class=\"line\">// 指针的值（指向的地址）不能改变，所以指针不能指向其他变量，</span><br><span class=\"line\">//被指向的变量的不可以改变，所以指针不能修改指向的变量的值</span><br><span class=\"line\">const type *const poi;</span><br></pre></td></tr></table></figure>\n<p>以* &amp;作为分割符进行读取，const作为前缀修饰的对象,对象存储的值不变。</p>\n<p>对于指向const type 的指针或者引用而言，指向的（引用的）变量类型不一定是常量，但是无法通过指针或者引用来修改其指向的（引用的）变量的值。《C++primer》中所说：所谓指向常量的指针或引用，不过是指针自以为自己指向了一个常量，所以自觉地不去改变所指对象的值。</p>\n<h2 id=\"疑惑\"><a href=\"#疑惑\" class=\"headerlink\" title=\"疑惑\"></a>疑惑</h2><ol>\n<li>为什么申明的返回值是引用，而返回的却是指针？<ul>\n<li>引用是地址的别名,但是不分配内存空间。 <code>CMyString &amp;A= *this</code>   这里<em>this是指向CMyString这个类的实例的地址，而A是CMyString的一个实例的引用，是引用就需要与这个实例的内存地址相关联，所以可以传入 </em>this ，也就是实例的地址。 本来 =号用于赋值的时候，左值是地址，右值是变量地址上的数据也就是变量的值，但是引用的=号的右值是变量的地址。所以可以传入地址，也就是指针。</li>\n</ul>\n</li>\n<li>传入的参数是个常量引用，为什么不使用常量指针： <code>const CMyString *str</code><ul>\n<li>虽然<code>const CMyString *str</code> 和<code>congst CMyString &amp;str</code> 都不能去修改实参的值了，但是引用不是对象，是不分配内存的啊，使用指针的话，肯定会占用内存，然后不用的时候销毁内存，所以效率会降低。而且引用是一定不会空的，所以不用考虑所指的对象是否为空。（提升效率的关键，可以不申请内存就不申请内存，因为不管是自己去释放，还是系统自动回收，分配和回收都会带来效率的下降。所以能用指针就用指针，能用引用就用引用，最坏的情况才是值拷贝。）（ <strong>对象</strong>是指一块能存储数据并具有某种类型的内存空间）</li>\n</ul>\n</li>\n</ol>"},{"title":"Redis设计与实现读书笔记——第8章 对象","date":"2019-03-29T01:28:19.000Z","copyright":true,"_content":"\n# Redis设计与实现读书笔记——第8章 对象\n\nRedis 并没有直接使用sds、dict等数据结构来实现键值对数据库， 而是基于这些数据结构创建了一个对象系统， 这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象， 每种对象都用到了至少一种前面所介绍的数据结构。\n\n<!--more-->\n\n## 简介\n\n对象的好处：\n\n- 根据对象的类型来判断是否可以执行给定的命令。\n- 针对不同的使用场景， 为对象设置多种不同的数据结构实现， 从而优化对象在不同场景下的使用效率。\n\n对象的特性：\n\n- 基于引用计数技术的内存回收机制（和java的是否原理相似）\n- 通过引用计数技术实现对象共享机制，多个键共享同一个对象来节约内存\n- 带有访问时间记录信息，可以用来删除空转时长较大的键\n\n## 8.1 对象的类型与编码\n\nRedis 使用对象来表示数据库中的键和值，创建一个新的键值对的时候，至少包含两个对象：1. 键对象 2. 值对象\n\n对象都由一个 `redisObject` 结构表示，保存数据相关的属性\n\n```c\ntypedef struct redisObject {\n    // 对象类型\n    unsigned type:4;\n    // 编码\n    unsigned encoding:4;\n    //lru 时钟 记录最后被访问的时间，也就是空转时长\n    unsigned lru:LRU_BITS; /* LRU time (relative to global lru_clock) or\n                            * LFU data (least significant 8 bits frequency\n                            * and most significant 16 bits decreas time). */\n    // 引用计数 实现内存自动回收等。\n    int refcount;\n    // 指向底层实现数据结构的指针\n    void *ptr;\n} robj;\n\n```\n\nptr指向的就是之前的sds，dict这些数据结构的内存地址。\n\n变量申明加冒号的用法： 是C语言的位域的用法。`:`后面的数字用来限定成员变量占用的位数。冒号后面的数字说明只会用到对应多少个bit位。type只会用到4个bit，encoding 也只会用的4个bit。变量占用的内存不再是有类型决定，而是位域。\n\n### 8.1.1 类型\n\ntype属性的值包括5种：\n\n| 类型常量       | 对象的名称   |\n| :------------- | :----------- |\n| `REDIS_STRING` | 字符串对象   |\n| `REDIS_LIST`   | 列表对象     |\n| `REDIS_HASH`   | 哈希对象     |\n| `REDIS_SET`    | 集合对象     |\n| `REDIS_ZSET`   | 有序集合对象 |\n\n键对象只能是字符串对象，而值对象则5种之一。所以执行TYPE命令返回的是键值对中值对象的类型。\n\ntype命令的\n\n| 对象         | 对象 `type` 属性的值 | TYPE 命令的输出 |\n| :----------- | :------------------- | :-------------- |\n| 字符串对象   | `REDIS_STRING`       | `\"string\"`      |\n| 列表对象     | `REDIS_LIST`         | `\"list\"`        |\n| 哈希对象     | `REDIS_HASH`         | `\"hash\"`        |\n| 集合对象     | `REDIS_SET`          | `\"set\"`         |\n| 有序集合对象 | `REDIS_ZSET`         | `\"zset\"`        |\n\n### 8.2 编码和底层实现\n\nptr指向底层数据结构，而encoding则决定了具体应该指向什么样的数据结构实现。之所以不能用type来决定指向的具体数据结构，是因为同一种对象，但是底层实现会有不同的数据结构。\n\n| 编码常量                    | 编码所对应的底层数据结构      |\n| :-------------------------- | :---------------------------- |\n| `REDIS_ENCODING_INT`        | `long` 类型的整数             |\n| `REDIS_ENCODING_EMBSTR`     | `embstr` 编码的简单动态字符串 |\n| `REDIS_ENCODING_RAW`        | 简单动态字符串                |\n| `REDIS_ENCODING_HT`         | 字典                          |\n| `REDIS_ENCODING_LINKEDLIST` | 双端链表                      |\n| `REDIS_ENCODING_ZIPLIST`    | 压缩列表                      |\n| `REDIS_ENCODING_INTSET`     | 整数集合                      |\n| `REDIS_ENCODING_SKIPLIST`   | 跳跃表和字典                  |\n\n每种类型的对象都至少使用了两种不同的编码，对应关系为：\n\n| 类型           | 编码                        | 对象                                                 |\n| :------------- | :-------------------------- | :--------------------------------------------------- |\n| `REDIS_STRING` | `REDIS_ENCODING_INT`        | 使用整数值实现的字符串对象。                         |\n| `REDIS_STRING` | `REDIS_ENCODING_EMBSTR`     | 使用 `embstr` 编码的简单动态字符串实现的字符串对象。 |\n| `REDIS_STRING` | `REDIS_ENCODING_RAW`        | 使用简单动态字符串实现的字符串对象。                 |\n| `REDIS_LIST`   | `REDIS_ENCODING_ZIPLIST`    | 使用压缩列表实现的列表对象。                         |\n| `REDIS_LIST`   | `REDIS_ENCODING_LINKEDLIST` | 使用双端链表实现的列表对象。                         |\n| `REDIS_HASH`   | `REDIS_ENCODING_ZIPLIST`    | 使用压缩列表实现的哈希对象。                         |\n| `REDIS_HASH`   | `REDIS_ENCODING_HT`         | 使用字典实现的哈希对象。                             |\n| `REDIS_SET`    | `REDIS_ENCODING_INTSET`     | 使用整数集合实现的集合对象。                         |\n| `REDIS_SET`    | `REDIS_ENCODING_HT`         | 使用字典实现的集合对象。                             |\n| `REDIS_ZSET`   | `REDIS_ENCODING_ZIPLIST`    | 使用压缩列表实现的有序集合对象。                     |\n| `REDIS_ZSET`   | `REDIS_ENCODING_SKIPLIST`   | 使用跳跃表和字典实现的有序集合对象。                 |\n\n使用 OBJECT ENCODING 命令可以查看一个数据库键的值对象的编码：\n\n```\nredis> SET msg \"hello wrold\"\nOK\n\nredis> OBJECT ENCODING msg\n\"embstr\"\n```\n\n不同编码的对象所对应的OBJECT ENCODING输出：\n\n表 8-5 OBJECT ENCODING 对不同编码的输出\n\n| 对象所使用的底层数据结构             | 编码常量                    | OBJECT ENCODING 命令输出 |\n| :----------------------------------- | :-------------------------- | :----------------------- |\n| 整数                                 | `REDIS_ENCODING_INT`        | `\"int\"`                  |\n| `embstr` 编码的简单动态字符串（SDS） | `REDIS_ENCODING_EMBSTR`     | `\"embstr\"`               |\n| 简单动态字符串                       | `REDIS_ENCODING_RAW`        | `\"raw\"`                  |\n| 字典                                 | `REDIS_ENCODING_HT`         | `\"hashtable\"`            |\n| 双端链表                             | `REDIS_ENCODING_LINKEDLIST` | `\"linkedlist\"`           |\n| 压缩列表                             | `REDIS_ENCODING_ZIPLIST`    | `\"ziplist\"`              |\n| 整数集合                             | `REDIS_ENCODING_INTSET`     | `\"intset\"`               |\n| 跳跃表和字典                         | `REDIS_ENCODING_SKIPLIST`   | `\"skiplist\"`             |\n\n使用encoding属性来设定对象指向的具体数据结构实现的好处：灵活与效率。根据不同场景来给同一种对象设置不同的数据结构实现。\n\n举个例子， 在列表对象包含的元素比较少时， Redis 使用压缩列表作为列表对象的底层实现：\n\n- 因为压缩列表比双端链表更节约内存， 并且在元素数量较少时， 在内存中以连续块方式保存的压缩列表比起双端链表可以更快被载入到缓存中；\n- 随着列表对象包含的元素越来越多， 使用压缩列表来保存元素的优势逐渐消失时， 对象就会将底层实现从压缩列表转向功能更强、也更适合保存大量元素的双端链表上面；\n\n是不是也可以理解成多态呢？\n\n## 8.2 字符串对象\n\n字符串对象的编码可以是 `int` 、 `raw` 或者 `embstr` 。\n\n1. 保存的对象是整数，而且可以用long类型表示：ptr指针指向一个long类型的内存地址。（是不是不用指向sdshdr了），然后将encoding 设置为REDIS_ENCODING_INT (应该在源码中有个宏定义)\n2. 保存的对象是字符串值，长度小于44字节（书上的39字节，但是先版本已经更新）。这种短字符串对象，直接**只调用一次内存分配**函数来分配一块**连续的空间**  依次包含redisObject和sdshdr两个结构。\n3. 字符串长度大于等于44字节的时候使用raw编码。会调用两次内存分配函数来创建redisObject结构和sdshdr结构。\n\nembstr编码的好处：\n\n- 只用分配一次内存，raw编码需要两次\n- 释放embstr的sds也只需要一次内存释放函数，raw两次\n- embstr的所有数据（对象结构，字符串结构）在连续的一块内存里面，从而可以更好地利用缓存带来的优势\n\nembstr和raw的示意图，摘自书上，但是注意sds的结构稍有变化。\n\nraw编码：\n\n![](http://redisbook.com/_images/graphviz-8731210637d0567af28d3a9d4089d5f864d29950.png)\n\nembstr编码：\n\n![](http://redisbook.com/_images/graphviz-900c13b23ce79372939259603be936c955ccaa62.png)\n\n注意：\n\nlong double类型的浮点数是转换成字符串值来保存的。执行的时候取出字符串再转换成long double 类型。\n\n| 值                                                           | 编码                |\n| :----------------------------------------------------------- | :------------------ |\n| 可以用 `long` 类型保存的整数。                               | `int`               |\n| 可以用 `long double` 类型保存的浮点数。                      | `embstr` 或者 `raw` |\n| 字符串值， 或者因为长度太大而没办法用 `long` 类型表示的整数， 又或者因为长度太大而没办法用 `long double` 类型表示的浮点数。 | `embstr` 或者 `raw` |\n\n### 8.2.1 编码的转换\n\n当保存的值发生变化的时候会进行转换，比如保存的整数值变成了字符串，那么编码从int 变成raw或者embstr。\n\n**注意**： Redis 没有为embstr编写任何修改程序，只有int和raw编码的字符串对象有这些程序，所以embstr编码的对象是只读，因此发生修改的话会从embstr变成raw。\n\n发生修改的源码中应该是将原来的ptr指向的数据结构内存释放掉后，重新指向新创建的对象。\n\n### 8.2.2 字符串命令的实现\n\n所有命令都是针对字符串对象的。\n\n| 命令        | `int` 编码的实现方法                                         | `embstr` 编码的实现方法                                      | `raw` 编码的实现方法                                         |\n| :---------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |\n| SET         | 使用 `int` 编码保存值。                                      | 使用 `embstr` 编码保存值。                                   | 使用 `raw` 编码保存值。                                      |\n| GET         | 拷贝对象所保存的整数值， 将这个拷贝转换成字符串值， 然后向客户端返回这个字符串值。 | 直接向客户端返回字符串值。                                   | 直接向客户端返回字符串值。                                   |\n| APPEND      | 将对象转换成 `raw` 编码， 然后按 `raw`编码的方式执行此操作。 | 将对象转换成 `raw` 编码， 然后按 `raw`编码的方式执行此操作。 | 调用 `sdscatlen` 函数， 将给定字符串追加到现有字符串的末尾。 |\n| INCRBYFLOAT | 取出整数值并将其转换成 `longdouble` 类型的浮点数， 对这个浮点数进行加法计算， 然后将得出的浮点数结果保存起来。 | 取出字符串值并尝试将其转换成`long double` 类型的浮点数， 对这个浮点数进行加法计算， 然后将得出的浮点数结果保存起来。 如果字符串值不能被转换成浮点数， 那么向客户端返回一个错误。 | 取出字符串值并尝试将其转换成 `longdouble` 类型的浮点数， 对这个浮点数进行加法计算， 然后将得出的浮点数结果保存起来。 如果字符串值不能被转换成浮点数， 那么向客户端返回一个错误。 |\n| INCRBY      | 对整数值进行加法计算， 得出的计算结果会作为整数被保存起来。  | `embstr` 编码不能执行此命令， 向客户端返回一个错误。         | `raw` 编码不能执行此命令， 向客户端返回一个错误。            |\n| DECRBY      | 对整数值进行减法计算， 得出的计算结果会作为整数被保存起来。  | `embstr` 编码不能执行此命令， 向客户端返回一个错误。         | `raw` 编码不能执行此命令， 向客户端返回一个错误。            |\n| STRLEN      | 拷贝对象所保存的整数值， 将这个拷贝转换成字符串值， 计算并返回这个字符串值的长度。 | 调用 `sdslen` 函数， 返回字符串的长度。                      | 调用 `sdslen` 函数， 返回字符串的长度。                      |\n| SETRANGE    | 将对象转换成 `raw` 编码， 然后按 `raw`编码的方式执行此命令。 | 将对象转换成 `raw` 编码， 然后按 `raw`编码的方式执行此命令。 | 将字符串特定索引上的值设置为给定的字符。                     |\n| GETRANGE    | 拷贝对象所保存的整数值， 将这个拷贝转换成字符串值， 然后取出并返回字符串指定索引上的字符。 | 直接取出并返回字符串指定索引上的字符。                       | 直接取出并返回字符串指定索引上的字符。                       |\n\n## 8.8 内存回收\n\nRedis通过跟踪对象的引用计数信息，在适当的时候自动释放对象并进行内存回收。\n\n计数信息由 `redisObject` 结构的 `refcount` 属性记录\n\n- 在创建一个新对象时， 引用计数的值会被初始化为 `1` ；\n- 当对象被一个新程序使用时， 它的引用计数值会被增一；\n- 当对象不再被一个程序使用时， 它的引用计数值会被减一；\n- 当对象的引用计数值变为 `0` 时， 对象所占用的内存会被释放。\n\n对应的API：\n\n| 函数            | 作用                                                         |\n| :-------------- | :----------------------------------------------------------- |\n| `incrRefCount`  | 将对象的引用计数值增一。                                     |\n| `decrRefCount`  | 将对象的引用计数值减一， 当对象的引用计数值等于 `0` 时， 释放对象。 |\n| `resetRefCount` | 将对象的引用计数值设置为 `0` ， 但并不释放对象， 这个函数通常在需要重新设置对象的引用计数值时使用。 |\n\n对象生命周期可以划分为创建对象、操作对象、释放对象三个阶段\n\n一个字符串对象从创建到释放的整个过程：\n\n```c\n// 创建一个字符串对象 s ，对象的引用计数为 1\nrobj *s = createStringObject(...)\n\n// 对象 s 执行各种操作 ...\n\n// 将对象 s 的引用计数减一，使得对象的引用计数变为 0\n// 导致对象 s 被释放\ndecrRefCount(s)\n```\n\n是不是通过计算指向对象这块内存的指针数量来实现的？\n\n### 8.9 对象共享\n\n对于整数值的字符串对象（int编码），在新创建一个字符串对象的时候如果有这个值的字符串对象存在，就不再为新键创建字符串对象，而是将这个新键指向之前已经存在了的字符串对象。然后将这个字符串对象的引用+1。主要目的是节约内存。\n\nRedis初始化服务器的时候创建一万个字符串对象， 这些对象包含了从 `0` 到 `9999` 的所有整数值， 当服务器需要用到值为 `0`到 `9999` 的字符串对象时， 服务器就会使用这些共享对象， 而不是新创建对象。\n\n创建共享字符串对象的数量可以通过修改 `redis.h/REDIS_SHARED_INTEGERS` 常量来修改。\n\n**为什么 Redis 不共享包含字符串的对象？**\n\n当服务器考虑将一个共享对象设置为键的值对象时， 程序需要先检查给定的共享对象和键想创建的目标对象是否完全相同， 只有在共享对象和目标对象完全相同的情况下， 程序才会将共享对象用作键的值对象， 而一个共享对象保存的值越复杂， 验证共享对象和目标对象是否相同所需的复杂度就会越高， 消耗的 CPU 时间也会越多：\n\n- 如果共享对象是保存整数值的字符串对象， 那么验证操作的复杂度为 O(1) ；\n- 如果共享对象是保存字符串值的字符串对象， 那么验证操作的复杂度为 O(N) ；\n- 如果共享对象是包含了多个值（或者对象的）对象， 比如列表对象或者哈希对象， 那么验证操作的复杂度将会是 O(N^2) 。\n\n因此， 尽管共享更复杂的对象可以节约更多的内存， 但受到 CPU 时间的限制， Redis 只对包含整数值的字符串对象进行共享。 （时刻在空间与时间上做权衡）\n\n## 8.9 对象的空转时长\n\n`lru` 属性， 该属性记录了对象最后一次被**命令程序访问**的时间。\n\nOBJECT IDLETIME 命令可以打印出给定键的空转时长， 这一空转时长就是通过将当前时间减去键的值对象的 `lru` 时间计算得出的。\n\nOBJECT IDLETIME 命令的实现是特殊的， 这个命令在访问键的值对象时， 不会修改值对象的 `lru` 属性。\n\nlru的主要作用就是配合maxmemory选项，淘汰不常用的键值对。\n\n如果服务器打开了 `maxmemory` 选项， 并且服务器用于回收内存的算法为 `volatile-lru` 或者 `allkeys-lru` ， 那么当服务器占用的内存数超过了 `maxmemory` 选项所设置的上限值时， 空转时长较高的那部分键会优先被服务器释放， 从而回收内存。\n\n## 疑惑\n\n1. 为什么在一块连续的内存里面可以更好地利用缓存带来的优势？\n2. 引用计数的程序怎么定义？是指线程吗？\n3. 引用计数的具体实现？\n4. 对象共享的时候怎么去判断存不存在已经创建了这个整数值的对象？对整个数据库遍历吗？\n\n","source":"_posts/2019-03-29-Redis设计与实现读书笔记——第8章-对象.md","raw":"---\ntitle: Redis设计与实现读书笔记——第8章 对象\ndate: 2019-03-29 09:28:19\ncategories: 读书笔记\ntags:\n- redis\n- object\ncopyright: true\n---\n\n# Redis设计与实现读书笔记——第8章 对象\n\nRedis 并没有直接使用sds、dict等数据结构来实现键值对数据库， 而是基于这些数据结构创建了一个对象系统， 这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象， 每种对象都用到了至少一种前面所介绍的数据结构。\n\n<!--more-->\n\n## 简介\n\n对象的好处：\n\n- 根据对象的类型来判断是否可以执行给定的命令。\n- 针对不同的使用场景， 为对象设置多种不同的数据结构实现， 从而优化对象在不同场景下的使用效率。\n\n对象的特性：\n\n- 基于引用计数技术的内存回收机制（和java的是否原理相似）\n- 通过引用计数技术实现对象共享机制，多个键共享同一个对象来节约内存\n- 带有访问时间记录信息，可以用来删除空转时长较大的键\n\n## 8.1 对象的类型与编码\n\nRedis 使用对象来表示数据库中的键和值，创建一个新的键值对的时候，至少包含两个对象：1. 键对象 2. 值对象\n\n对象都由一个 `redisObject` 结构表示，保存数据相关的属性\n\n```c\ntypedef struct redisObject {\n    // 对象类型\n    unsigned type:4;\n    // 编码\n    unsigned encoding:4;\n    //lru 时钟 记录最后被访问的时间，也就是空转时长\n    unsigned lru:LRU_BITS; /* LRU time (relative to global lru_clock) or\n                            * LFU data (least significant 8 bits frequency\n                            * and most significant 16 bits decreas time). */\n    // 引用计数 实现内存自动回收等。\n    int refcount;\n    // 指向底层实现数据结构的指针\n    void *ptr;\n} robj;\n\n```\n\nptr指向的就是之前的sds，dict这些数据结构的内存地址。\n\n变量申明加冒号的用法： 是C语言的位域的用法。`:`后面的数字用来限定成员变量占用的位数。冒号后面的数字说明只会用到对应多少个bit位。type只会用到4个bit，encoding 也只会用的4个bit。变量占用的内存不再是有类型决定，而是位域。\n\n### 8.1.1 类型\n\ntype属性的值包括5种：\n\n| 类型常量       | 对象的名称   |\n| :------------- | :----------- |\n| `REDIS_STRING` | 字符串对象   |\n| `REDIS_LIST`   | 列表对象     |\n| `REDIS_HASH`   | 哈希对象     |\n| `REDIS_SET`    | 集合对象     |\n| `REDIS_ZSET`   | 有序集合对象 |\n\n键对象只能是字符串对象，而值对象则5种之一。所以执行TYPE命令返回的是键值对中值对象的类型。\n\ntype命令的\n\n| 对象         | 对象 `type` 属性的值 | TYPE 命令的输出 |\n| :----------- | :------------------- | :-------------- |\n| 字符串对象   | `REDIS_STRING`       | `\"string\"`      |\n| 列表对象     | `REDIS_LIST`         | `\"list\"`        |\n| 哈希对象     | `REDIS_HASH`         | `\"hash\"`        |\n| 集合对象     | `REDIS_SET`          | `\"set\"`         |\n| 有序集合对象 | `REDIS_ZSET`         | `\"zset\"`        |\n\n### 8.2 编码和底层实现\n\nptr指向底层数据结构，而encoding则决定了具体应该指向什么样的数据结构实现。之所以不能用type来决定指向的具体数据结构，是因为同一种对象，但是底层实现会有不同的数据结构。\n\n| 编码常量                    | 编码所对应的底层数据结构      |\n| :-------------------------- | :---------------------------- |\n| `REDIS_ENCODING_INT`        | `long` 类型的整数             |\n| `REDIS_ENCODING_EMBSTR`     | `embstr` 编码的简单动态字符串 |\n| `REDIS_ENCODING_RAW`        | 简单动态字符串                |\n| `REDIS_ENCODING_HT`         | 字典                          |\n| `REDIS_ENCODING_LINKEDLIST` | 双端链表                      |\n| `REDIS_ENCODING_ZIPLIST`    | 压缩列表                      |\n| `REDIS_ENCODING_INTSET`     | 整数集合                      |\n| `REDIS_ENCODING_SKIPLIST`   | 跳跃表和字典                  |\n\n每种类型的对象都至少使用了两种不同的编码，对应关系为：\n\n| 类型           | 编码                        | 对象                                                 |\n| :------------- | :-------------------------- | :--------------------------------------------------- |\n| `REDIS_STRING` | `REDIS_ENCODING_INT`        | 使用整数值实现的字符串对象。                         |\n| `REDIS_STRING` | `REDIS_ENCODING_EMBSTR`     | 使用 `embstr` 编码的简单动态字符串实现的字符串对象。 |\n| `REDIS_STRING` | `REDIS_ENCODING_RAW`        | 使用简单动态字符串实现的字符串对象。                 |\n| `REDIS_LIST`   | `REDIS_ENCODING_ZIPLIST`    | 使用压缩列表实现的列表对象。                         |\n| `REDIS_LIST`   | `REDIS_ENCODING_LINKEDLIST` | 使用双端链表实现的列表对象。                         |\n| `REDIS_HASH`   | `REDIS_ENCODING_ZIPLIST`    | 使用压缩列表实现的哈希对象。                         |\n| `REDIS_HASH`   | `REDIS_ENCODING_HT`         | 使用字典实现的哈希对象。                             |\n| `REDIS_SET`    | `REDIS_ENCODING_INTSET`     | 使用整数集合实现的集合对象。                         |\n| `REDIS_SET`    | `REDIS_ENCODING_HT`         | 使用字典实现的集合对象。                             |\n| `REDIS_ZSET`   | `REDIS_ENCODING_ZIPLIST`    | 使用压缩列表实现的有序集合对象。                     |\n| `REDIS_ZSET`   | `REDIS_ENCODING_SKIPLIST`   | 使用跳跃表和字典实现的有序集合对象。                 |\n\n使用 OBJECT ENCODING 命令可以查看一个数据库键的值对象的编码：\n\n```\nredis> SET msg \"hello wrold\"\nOK\n\nredis> OBJECT ENCODING msg\n\"embstr\"\n```\n\n不同编码的对象所对应的OBJECT ENCODING输出：\n\n表 8-5 OBJECT ENCODING 对不同编码的输出\n\n| 对象所使用的底层数据结构             | 编码常量                    | OBJECT ENCODING 命令输出 |\n| :----------------------------------- | :-------------------------- | :----------------------- |\n| 整数                                 | `REDIS_ENCODING_INT`        | `\"int\"`                  |\n| `embstr` 编码的简单动态字符串（SDS） | `REDIS_ENCODING_EMBSTR`     | `\"embstr\"`               |\n| 简单动态字符串                       | `REDIS_ENCODING_RAW`        | `\"raw\"`                  |\n| 字典                                 | `REDIS_ENCODING_HT`         | `\"hashtable\"`            |\n| 双端链表                             | `REDIS_ENCODING_LINKEDLIST` | `\"linkedlist\"`           |\n| 压缩列表                             | `REDIS_ENCODING_ZIPLIST`    | `\"ziplist\"`              |\n| 整数集合                             | `REDIS_ENCODING_INTSET`     | `\"intset\"`               |\n| 跳跃表和字典                         | `REDIS_ENCODING_SKIPLIST`   | `\"skiplist\"`             |\n\n使用encoding属性来设定对象指向的具体数据结构实现的好处：灵活与效率。根据不同场景来给同一种对象设置不同的数据结构实现。\n\n举个例子， 在列表对象包含的元素比较少时， Redis 使用压缩列表作为列表对象的底层实现：\n\n- 因为压缩列表比双端链表更节约内存， 并且在元素数量较少时， 在内存中以连续块方式保存的压缩列表比起双端链表可以更快被载入到缓存中；\n- 随着列表对象包含的元素越来越多， 使用压缩列表来保存元素的优势逐渐消失时， 对象就会将底层实现从压缩列表转向功能更强、也更适合保存大量元素的双端链表上面；\n\n是不是也可以理解成多态呢？\n\n## 8.2 字符串对象\n\n字符串对象的编码可以是 `int` 、 `raw` 或者 `embstr` 。\n\n1. 保存的对象是整数，而且可以用long类型表示：ptr指针指向一个long类型的内存地址。（是不是不用指向sdshdr了），然后将encoding 设置为REDIS_ENCODING_INT (应该在源码中有个宏定义)\n2. 保存的对象是字符串值，长度小于44字节（书上的39字节，但是先版本已经更新）。这种短字符串对象，直接**只调用一次内存分配**函数来分配一块**连续的空间**  依次包含redisObject和sdshdr两个结构。\n3. 字符串长度大于等于44字节的时候使用raw编码。会调用两次内存分配函数来创建redisObject结构和sdshdr结构。\n\nembstr编码的好处：\n\n- 只用分配一次内存，raw编码需要两次\n- 释放embstr的sds也只需要一次内存释放函数，raw两次\n- embstr的所有数据（对象结构，字符串结构）在连续的一块内存里面，从而可以更好地利用缓存带来的优势\n\nembstr和raw的示意图，摘自书上，但是注意sds的结构稍有变化。\n\nraw编码：\n\n![](http://redisbook.com/_images/graphviz-8731210637d0567af28d3a9d4089d5f864d29950.png)\n\nembstr编码：\n\n![](http://redisbook.com/_images/graphviz-900c13b23ce79372939259603be936c955ccaa62.png)\n\n注意：\n\nlong double类型的浮点数是转换成字符串值来保存的。执行的时候取出字符串再转换成long double 类型。\n\n| 值                                                           | 编码                |\n| :----------------------------------------------------------- | :------------------ |\n| 可以用 `long` 类型保存的整数。                               | `int`               |\n| 可以用 `long double` 类型保存的浮点数。                      | `embstr` 或者 `raw` |\n| 字符串值， 或者因为长度太大而没办法用 `long` 类型表示的整数， 又或者因为长度太大而没办法用 `long double` 类型表示的浮点数。 | `embstr` 或者 `raw` |\n\n### 8.2.1 编码的转换\n\n当保存的值发生变化的时候会进行转换，比如保存的整数值变成了字符串，那么编码从int 变成raw或者embstr。\n\n**注意**： Redis 没有为embstr编写任何修改程序，只有int和raw编码的字符串对象有这些程序，所以embstr编码的对象是只读，因此发生修改的话会从embstr变成raw。\n\n发生修改的源码中应该是将原来的ptr指向的数据结构内存释放掉后，重新指向新创建的对象。\n\n### 8.2.2 字符串命令的实现\n\n所有命令都是针对字符串对象的。\n\n| 命令        | `int` 编码的实现方法                                         | `embstr` 编码的实现方法                                      | `raw` 编码的实现方法                                         |\n| :---------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |\n| SET         | 使用 `int` 编码保存值。                                      | 使用 `embstr` 编码保存值。                                   | 使用 `raw` 编码保存值。                                      |\n| GET         | 拷贝对象所保存的整数值， 将这个拷贝转换成字符串值， 然后向客户端返回这个字符串值。 | 直接向客户端返回字符串值。                                   | 直接向客户端返回字符串值。                                   |\n| APPEND      | 将对象转换成 `raw` 编码， 然后按 `raw`编码的方式执行此操作。 | 将对象转换成 `raw` 编码， 然后按 `raw`编码的方式执行此操作。 | 调用 `sdscatlen` 函数， 将给定字符串追加到现有字符串的末尾。 |\n| INCRBYFLOAT | 取出整数值并将其转换成 `longdouble` 类型的浮点数， 对这个浮点数进行加法计算， 然后将得出的浮点数结果保存起来。 | 取出字符串值并尝试将其转换成`long double` 类型的浮点数， 对这个浮点数进行加法计算， 然后将得出的浮点数结果保存起来。 如果字符串值不能被转换成浮点数， 那么向客户端返回一个错误。 | 取出字符串值并尝试将其转换成 `longdouble` 类型的浮点数， 对这个浮点数进行加法计算， 然后将得出的浮点数结果保存起来。 如果字符串值不能被转换成浮点数， 那么向客户端返回一个错误。 |\n| INCRBY      | 对整数值进行加法计算， 得出的计算结果会作为整数被保存起来。  | `embstr` 编码不能执行此命令， 向客户端返回一个错误。         | `raw` 编码不能执行此命令， 向客户端返回一个错误。            |\n| DECRBY      | 对整数值进行减法计算， 得出的计算结果会作为整数被保存起来。  | `embstr` 编码不能执行此命令， 向客户端返回一个错误。         | `raw` 编码不能执行此命令， 向客户端返回一个错误。            |\n| STRLEN      | 拷贝对象所保存的整数值， 将这个拷贝转换成字符串值， 计算并返回这个字符串值的长度。 | 调用 `sdslen` 函数， 返回字符串的长度。                      | 调用 `sdslen` 函数， 返回字符串的长度。                      |\n| SETRANGE    | 将对象转换成 `raw` 编码， 然后按 `raw`编码的方式执行此命令。 | 将对象转换成 `raw` 编码， 然后按 `raw`编码的方式执行此命令。 | 将字符串特定索引上的值设置为给定的字符。                     |\n| GETRANGE    | 拷贝对象所保存的整数值， 将这个拷贝转换成字符串值， 然后取出并返回字符串指定索引上的字符。 | 直接取出并返回字符串指定索引上的字符。                       | 直接取出并返回字符串指定索引上的字符。                       |\n\n## 8.8 内存回收\n\nRedis通过跟踪对象的引用计数信息，在适当的时候自动释放对象并进行内存回收。\n\n计数信息由 `redisObject` 结构的 `refcount` 属性记录\n\n- 在创建一个新对象时， 引用计数的值会被初始化为 `1` ；\n- 当对象被一个新程序使用时， 它的引用计数值会被增一；\n- 当对象不再被一个程序使用时， 它的引用计数值会被减一；\n- 当对象的引用计数值变为 `0` 时， 对象所占用的内存会被释放。\n\n对应的API：\n\n| 函数            | 作用                                                         |\n| :-------------- | :----------------------------------------------------------- |\n| `incrRefCount`  | 将对象的引用计数值增一。                                     |\n| `decrRefCount`  | 将对象的引用计数值减一， 当对象的引用计数值等于 `0` 时， 释放对象。 |\n| `resetRefCount` | 将对象的引用计数值设置为 `0` ， 但并不释放对象， 这个函数通常在需要重新设置对象的引用计数值时使用。 |\n\n对象生命周期可以划分为创建对象、操作对象、释放对象三个阶段\n\n一个字符串对象从创建到释放的整个过程：\n\n```c\n// 创建一个字符串对象 s ，对象的引用计数为 1\nrobj *s = createStringObject(...)\n\n// 对象 s 执行各种操作 ...\n\n// 将对象 s 的引用计数减一，使得对象的引用计数变为 0\n// 导致对象 s 被释放\ndecrRefCount(s)\n```\n\n是不是通过计算指向对象这块内存的指针数量来实现的？\n\n### 8.9 对象共享\n\n对于整数值的字符串对象（int编码），在新创建一个字符串对象的时候如果有这个值的字符串对象存在，就不再为新键创建字符串对象，而是将这个新键指向之前已经存在了的字符串对象。然后将这个字符串对象的引用+1。主要目的是节约内存。\n\nRedis初始化服务器的时候创建一万个字符串对象， 这些对象包含了从 `0` 到 `9999` 的所有整数值， 当服务器需要用到值为 `0`到 `9999` 的字符串对象时， 服务器就会使用这些共享对象， 而不是新创建对象。\n\n创建共享字符串对象的数量可以通过修改 `redis.h/REDIS_SHARED_INTEGERS` 常量来修改。\n\n**为什么 Redis 不共享包含字符串的对象？**\n\n当服务器考虑将一个共享对象设置为键的值对象时， 程序需要先检查给定的共享对象和键想创建的目标对象是否完全相同， 只有在共享对象和目标对象完全相同的情况下， 程序才会将共享对象用作键的值对象， 而一个共享对象保存的值越复杂， 验证共享对象和目标对象是否相同所需的复杂度就会越高， 消耗的 CPU 时间也会越多：\n\n- 如果共享对象是保存整数值的字符串对象， 那么验证操作的复杂度为 O(1) ；\n- 如果共享对象是保存字符串值的字符串对象， 那么验证操作的复杂度为 O(N) ；\n- 如果共享对象是包含了多个值（或者对象的）对象， 比如列表对象或者哈希对象， 那么验证操作的复杂度将会是 O(N^2) 。\n\n因此， 尽管共享更复杂的对象可以节约更多的内存， 但受到 CPU 时间的限制， Redis 只对包含整数值的字符串对象进行共享。 （时刻在空间与时间上做权衡）\n\n## 8.9 对象的空转时长\n\n`lru` 属性， 该属性记录了对象最后一次被**命令程序访问**的时间。\n\nOBJECT IDLETIME 命令可以打印出给定键的空转时长， 这一空转时长就是通过将当前时间减去键的值对象的 `lru` 时间计算得出的。\n\nOBJECT IDLETIME 命令的实现是特殊的， 这个命令在访问键的值对象时， 不会修改值对象的 `lru` 属性。\n\nlru的主要作用就是配合maxmemory选项，淘汰不常用的键值对。\n\n如果服务器打开了 `maxmemory` 选项， 并且服务器用于回收内存的算法为 `volatile-lru` 或者 `allkeys-lru` ， 那么当服务器占用的内存数超过了 `maxmemory` 选项所设置的上限值时， 空转时长较高的那部分键会优先被服务器释放， 从而回收内存。\n\n## 疑惑\n\n1. 为什么在一块连续的内存里面可以更好地利用缓存带来的优势？\n2. 引用计数的程序怎么定义？是指线程吗？\n3. 引用计数的具体实现？\n4. 对象共享的时候怎么去判断存不存在已经创建了这个整数值的对象？对整个数据库遍历吗？\n\n","slug":"2019-03-29-Redis设计与实现读书笔记——第8章-对象","published":1,"updated":"2019-11-08T13:15:10.743Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2yelxh2000bm8tz5xi33bp7","content":"<h1 id=\"Redis设计与实现读书笔记——第8章-对象\"><a href=\"#Redis设计与实现读书笔记——第8章-对象\" class=\"headerlink\" title=\"Redis设计与实现读书笔记——第8章 对象\"></a>Redis设计与实现读书笔记——第8章 对象</h1><p>Redis 并没有直接使用sds、dict等数据结构来实现键值对数据库， 而是基于这些数据结构创建了一个对象系统， 这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象， 每种对象都用到了至少一种前面所介绍的数据结构。</p>\n<a id=\"more\"></a>\n<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>对象的好处：</p>\n<ul>\n<li>根据对象的类型来判断是否可以执行给定的命令。</li>\n<li>针对不同的使用场景， 为对象设置多种不同的数据结构实现， 从而优化对象在不同场景下的使用效率。</li>\n</ul>\n<p>对象的特性：</p>\n<ul>\n<li>基于引用计数技术的内存回收机制（和java的是否原理相似）</li>\n<li>通过引用计数技术实现对象共享机制，多个键共享同一个对象来节约内存</li>\n<li>带有访问时间记录信息，可以用来删除空转时长较大的键</li>\n</ul>\n<h2 id=\"8-1-对象的类型与编码\"><a href=\"#8-1-对象的类型与编码\" class=\"headerlink\" title=\"8.1 对象的类型与编码\"></a>8.1 对象的类型与编码</h2><p>Redis 使用对象来表示数据库中的键和值，创建一个新的键值对的时候，至少包含两个对象：1. 键对象 2. 值对象</p>\n<p>对象都由一个 <code>redisObject</code> 结构表示，保存数据相关的属性</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">redisObject</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 对象类型</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> type:<span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 编码</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> encoding:<span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"comment\">//lru 时钟 记录最后被访问的时间，也就是空转时长</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> lru:LRU_BITS; <span class=\"comment\">/* LRU time (relative to global lru_clock) or</span></span><br><span class=\"line\"><span class=\"comment\">                            * LFU data (least significant 8 bits frequency</span></span><br><span class=\"line\"><span class=\"comment\">                            * and most significant 16 bits decreas time). */</span></span><br><span class=\"line\">    <span class=\"comment\">// 引用计数 实现内存自动回收等。</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> refcount;</span><br><span class=\"line\">    <span class=\"comment\">// 指向底层实现数据结构的指针</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *ptr;</span><br><span class=\"line\">&#125; robj;</span><br></pre></td></tr></table></figure>\n<p>ptr指向的就是之前的sds，dict这些数据结构的内存地址。</p>\n<p>变量申明加冒号的用法： 是C语言的位域的用法。<code>:</code>后面的数字用来限定成员变量占用的位数。冒号后面的数字说明只会用到对应多少个bit位。type只会用到4个bit，encoding 也只会用的4个bit。变量占用的内存不再是有类型决定，而是位域。</p>\n<h3 id=\"8-1-1-类型\"><a href=\"#8-1-1-类型\" class=\"headerlink\" title=\"8.1.1 类型\"></a>8.1.1 类型</h3><p>type属性的值包括5种：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">类型常量</th>\n<th style=\"text-align:left\">对象的名称</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_STRING</code></td>\n<td style=\"text-align:left\">字符串对象</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_LIST</code></td>\n<td style=\"text-align:left\">列表对象</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_HASH</code></td>\n<td style=\"text-align:left\">哈希对象</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_SET</code></td>\n<td style=\"text-align:left\">集合对象</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_ZSET</code></td>\n<td style=\"text-align:left\">有序集合对象</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>键对象只能是字符串对象，而值对象则5种之一。所以执行TYPE命令返回的是键值对中值对象的类型。</p>\n<p>type命令的</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">对象</th>\n<th style=\"text-align:left\">对象 <code>type</code> 属性的值</th>\n<th style=\"text-align:left\">TYPE 命令的输出</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">字符串对象</td>\n<td style=\"text-align:left\"><code>REDIS_STRING</code></td>\n<td style=\"text-align:left\"><code>&quot;string&quot;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">列表对象</td>\n<td style=\"text-align:left\"><code>REDIS_LIST</code></td>\n<td style=\"text-align:left\"><code>&quot;list&quot;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">哈希对象</td>\n<td style=\"text-align:left\"><code>REDIS_HASH</code></td>\n<td style=\"text-align:left\"><code>&quot;hash&quot;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">集合对象</td>\n<td style=\"text-align:left\"><code>REDIS_SET</code></td>\n<td style=\"text-align:left\"><code>&quot;set&quot;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">有序集合对象</td>\n<td style=\"text-align:left\"><code>REDIS_ZSET</code></td>\n<td style=\"text-align:left\"><code>&quot;zset&quot;</code></td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"8-2-编码和底层实现\"><a href=\"#8-2-编码和底层实现\" class=\"headerlink\" title=\"8.2 编码和底层实现\"></a>8.2 编码和底层实现</h3><p>ptr指向底层数据结构，而encoding则决定了具体应该指向什么样的数据结构实现。之所以不能用type来决定指向的具体数据结构，是因为同一种对象，但是底层实现会有不同的数据结构。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">编码常量</th>\n<th style=\"text-align:left\">编码所对应的底层数据结构</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_INT</code></td>\n<td style=\"text-align:left\"><code>long</code> 类型的整数</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_EMBSTR</code></td>\n<td style=\"text-align:left\"><code>embstr</code> 编码的简单动态字符串</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_RAW</code></td>\n<td style=\"text-align:left\">简单动态字符串</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_HT</code></td>\n<td style=\"text-align:left\">字典</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_LINKEDLIST</code></td>\n<td style=\"text-align:left\">双端链表</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_ZIPLIST</code></td>\n<td style=\"text-align:left\">压缩列表</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_INTSET</code></td>\n<td style=\"text-align:left\">整数集合</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_SKIPLIST</code></td>\n<td style=\"text-align:left\">跳跃表和字典</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>每种类型的对象都至少使用了两种不同的编码，对应关系为：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">类型</th>\n<th style=\"text-align:left\">编码</th>\n<th style=\"text-align:left\">对象</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_STRING</code></td>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_INT</code></td>\n<td style=\"text-align:left\">使用整数值实现的字符串对象。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_STRING</code></td>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_EMBSTR</code></td>\n<td style=\"text-align:left\">使用 <code>embstr</code> 编码的简单动态字符串实现的字符串对象。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_STRING</code></td>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_RAW</code></td>\n<td style=\"text-align:left\">使用简单动态字符串实现的字符串对象。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_LIST</code></td>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_ZIPLIST</code></td>\n<td style=\"text-align:left\">使用压缩列表实现的列表对象。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_LIST</code></td>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_LINKEDLIST</code></td>\n<td style=\"text-align:left\">使用双端链表实现的列表对象。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_HASH</code></td>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_ZIPLIST</code></td>\n<td style=\"text-align:left\">使用压缩列表实现的哈希对象。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_HASH</code></td>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_HT</code></td>\n<td style=\"text-align:left\">使用字典实现的哈希对象。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_SET</code></td>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_INTSET</code></td>\n<td style=\"text-align:left\">使用整数集合实现的集合对象。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_SET</code></td>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_HT</code></td>\n<td style=\"text-align:left\">使用字典实现的集合对象。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_ZSET</code></td>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_ZIPLIST</code></td>\n<td style=\"text-align:left\">使用压缩列表实现的有序集合对象。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_ZSET</code></td>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_SKIPLIST</code></td>\n<td style=\"text-align:left\">使用跳跃表和字典实现的有序集合对象。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>使用 OBJECT ENCODING 命令可以查看一个数据库键的值对象的编码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; SET msg &quot;hello wrold&quot;</span><br><span class=\"line\">OK</span><br><span class=\"line\"></span><br><span class=\"line\">redis&gt; OBJECT ENCODING msg</span><br><span class=\"line\">&quot;embstr&quot;</span><br></pre></td></tr></table></figure>\n<p>不同编码的对象所对应的OBJECT ENCODING输出：</p>\n<p>表 8-5 OBJECT ENCODING 对不同编码的输出</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">对象所使用的底层数据结构</th>\n<th style=\"text-align:left\">编码常量</th>\n<th style=\"text-align:left\">OBJECT ENCODING 命令输出</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">整数</td>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_INT</code></td>\n<td style=\"text-align:left\"><code>&quot;int&quot;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>embstr</code> 编码的简单动态字符串（SDS）</td>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_EMBSTR</code></td>\n<td style=\"text-align:left\"><code>&quot;embstr&quot;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">简单动态字符串</td>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_RAW</code></td>\n<td style=\"text-align:left\"><code>&quot;raw&quot;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">字典</td>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_HT</code></td>\n<td style=\"text-align:left\"><code>&quot;hashtable&quot;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">双端链表</td>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_LINKEDLIST</code></td>\n<td style=\"text-align:left\"><code>&quot;linkedlist&quot;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">压缩列表</td>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_ZIPLIST</code></td>\n<td style=\"text-align:left\"><code>&quot;ziplist&quot;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">整数集合</td>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_INTSET</code></td>\n<td style=\"text-align:left\"><code>&quot;intset&quot;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">跳跃表和字典</td>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_SKIPLIST</code></td>\n<td style=\"text-align:left\"><code>&quot;skiplist&quot;</code></td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>使用encoding属性来设定对象指向的具体数据结构实现的好处：灵活与效率。根据不同场景来给同一种对象设置不同的数据结构实现。</p>\n<p>举个例子， 在列表对象包含的元素比较少时， Redis 使用压缩列表作为列表对象的底层实现：</p>\n<ul>\n<li>因为压缩列表比双端链表更节约内存， 并且在元素数量较少时， 在内存中以连续块方式保存的压缩列表比起双端链表可以更快被载入到缓存中；</li>\n<li>随着列表对象包含的元素越来越多， 使用压缩列表来保存元素的优势逐渐消失时， 对象就会将底层实现从压缩列表转向功能更强、也更适合保存大量元素的双端链表上面；</li>\n</ul>\n<p>是不是也可以理解成多态呢？</p>\n<h2 id=\"8-2-字符串对象\"><a href=\"#8-2-字符串对象\" class=\"headerlink\" title=\"8.2 字符串对象\"></a>8.2 字符串对象</h2><p>字符串对象的编码可以是 <code>int</code> 、 <code>raw</code> 或者 <code>embstr</code> 。</p>\n<ol>\n<li>保存的对象是整数，而且可以用long类型表示：ptr指针指向一个long类型的内存地址。（是不是不用指向sdshdr了），然后将encoding 设置为REDIS_ENCODING_INT (应该在源码中有个宏定义)</li>\n<li>保存的对象是字符串值，长度小于44字节（书上的39字节，但是先版本已经更新）。这种短字符串对象，直接<strong>只调用一次内存分配</strong>函数来分配一块<strong>连续的空间</strong>  依次包含redisObject和sdshdr两个结构。</li>\n<li>字符串长度大于等于44字节的时候使用raw编码。会调用两次内存分配函数来创建redisObject结构和sdshdr结构。</li>\n</ol>\n<p>embstr编码的好处：</p>\n<ul>\n<li>只用分配一次内存，raw编码需要两次</li>\n<li>释放embstr的sds也只需要一次内存释放函数，raw两次</li>\n<li>embstr的所有数据（对象结构，字符串结构）在连续的一块内存里面，从而可以更好地利用缓存带来的优势</li>\n</ul>\n<p>embstr和raw的示意图，摘自书上，但是注意sds的结构稍有变化。</p>\n<p>raw编码：</p>\n<p><img src=\"http://redisbook.com/_images/graphviz-8731210637d0567af28d3a9d4089d5f864d29950.png\" alt=\"\"></p>\n<p>embstr编码：</p>\n<p><img src=\"http://redisbook.com/_images/graphviz-900c13b23ce79372939259603be936c955ccaa62.png\" alt=\"\"></p>\n<p>注意：</p>\n<p>long double类型的浮点数是转换成字符串值来保存的。执行的时候取出字符串再转换成long double 类型。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">值</th>\n<th style=\"text-align:left\">编码</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">可以用 <code>long</code> 类型保存的整数。</td>\n<td style=\"text-align:left\"><code>int</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">可以用 <code>long double</code> 类型保存的浮点数。</td>\n<td style=\"text-align:left\"><code>embstr</code> 或者 <code>raw</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">字符串值， 或者因为长度太大而没办法用 <code>long</code> 类型表示的整数， 又或者因为长度太大而没办法用 <code>long double</code> 类型表示的浮点数。</td>\n<td style=\"text-align:left\"><code>embstr</code> 或者 <code>raw</code></td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"8-2-1-编码的转换\"><a href=\"#8-2-1-编码的转换\" class=\"headerlink\" title=\"8.2.1 编码的转换\"></a>8.2.1 编码的转换</h3><p>当保存的值发生变化的时候会进行转换，比如保存的整数值变成了字符串，那么编码从int 变成raw或者embstr。</p>\n<p><strong>注意</strong>： Redis 没有为embstr编写任何修改程序，只有int和raw编码的字符串对象有这些程序，所以embstr编码的对象是只读，因此发生修改的话会从embstr变成raw。</p>\n<p>发生修改的源码中应该是将原来的ptr指向的数据结构内存释放掉后，重新指向新创建的对象。</p>\n<h3 id=\"8-2-2-字符串命令的实现\"><a href=\"#8-2-2-字符串命令的实现\" class=\"headerlink\" title=\"8.2.2 字符串命令的实现\"></a>8.2.2 字符串命令的实现</h3><p>所有命令都是针对字符串对象的。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">命令</th>\n<th style=\"text-align:left\"><code>int</code> 编码的实现方法</th>\n<th style=\"text-align:left\"><code>embstr</code> 编码的实现方法</th>\n<th style=\"text-align:left\"><code>raw</code> 编码的实现方法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">SET</td>\n<td style=\"text-align:left\">使用 <code>int</code> 编码保存值。</td>\n<td style=\"text-align:left\">使用 <code>embstr</code> 编码保存值。</td>\n<td style=\"text-align:left\">使用 <code>raw</code> 编码保存值。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">GET</td>\n<td style=\"text-align:left\">拷贝对象所保存的整数值， 将这个拷贝转换成字符串值， 然后向客户端返回这个字符串值。</td>\n<td style=\"text-align:left\">直接向客户端返回字符串值。</td>\n<td style=\"text-align:left\">直接向客户端返回字符串值。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">APPEND</td>\n<td style=\"text-align:left\">将对象转换成 <code>raw</code> 编码， 然后按 <code>raw</code>编码的方式执行此操作。</td>\n<td style=\"text-align:left\">将对象转换成 <code>raw</code> 编码， 然后按 <code>raw</code>编码的方式执行此操作。</td>\n<td style=\"text-align:left\">调用 <code>sdscatlen</code> 函数， 将给定字符串追加到现有字符串的末尾。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">INCRBYFLOAT</td>\n<td style=\"text-align:left\">取出整数值并将其转换成 <code>longdouble</code> 类型的浮点数， 对这个浮点数进行加法计算， 然后将得出的浮点数结果保存起来。</td>\n<td style=\"text-align:left\">取出字符串值并尝试将其转换成<code>long double</code> 类型的浮点数， 对这个浮点数进行加法计算， 然后将得出的浮点数结果保存起来。 如果字符串值不能被转换成浮点数， 那么向客户端返回一个错误。</td>\n<td style=\"text-align:left\">取出字符串值并尝试将其转换成 <code>longdouble</code> 类型的浮点数， 对这个浮点数进行加法计算， 然后将得出的浮点数结果保存起来。 如果字符串值不能被转换成浮点数， 那么向客户端返回一个错误。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">INCRBY</td>\n<td style=\"text-align:left\">对整数值进行加法计算， 得出的计算结果会作为整数被保存起来。</td>\n<td style=\"text-align:left\"><code>embstr</code> 编码不能执行此命令， 向客户端返回一个错误。</td>\n<td style=\"text-align:left\"><code>raw</code> 编码不能执行此命令， 向客户端返回一个错误。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">DECRBY</td>\n<td style=\"text-align:left\">对整数值进行减法计算， 得出的计算结果会作为整数被保存起来。</td>\n<td style=\"text-align:left\"><code>embstr</code> 编码不能执行此命令， 向客户端返回一个错误。</td>\n<td style=\"text-align:left\"><code>raw</code> 编码不能执行此命令， 向客户端返回一个错误。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">STRLEN</td>\n<td style=\"text-align:left\">拷贝对象所保存的整数值， 将这个拷贝转换成字符串值， 计算并返回这个字符串值的长度。</td>\n<td style=\"text-align:left\">调用 <code>sdslen</code> 函数， 返回字符串的长度。</td>\n<td style=\"text-align:left\">调用 <code>sdslen</code> 函数， 返回字符串的长度。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">SETRANGE</td>\n<td style=\"text-align:left\">将对象转换成 <code>raw</code> 编码， 然后按 <code>raw</code>编码的方式执行此命令。</td>\n<td style=\"text-align:left\">将对象转换成 <code>raw</code> 编码， 然后按 <code>raw</code>编码的方式执行此命令。</td>\n<td style=\"text-align:left\">将字符串特定索引上的值设置为给定的字符。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">GETRANGE</td>\n<td style=\"text-align:left\">拷贝对象所保存的整数值， 将这个拷贝转换成字符串值， 然后取出并返回字符串指定索引上的字符。</td>\n<td style=\"text-align:left\">直接取出并返回字符串指定索引上的字符。</td>\n<td style=\"text-align:left\">直接取出并返回字符串指定索引上的字符。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"8-8-内存回收\"><a href=\"#8-8-内存回收\" class=\"headerlink\" title=\"8.8 内存回收\"></a>8.8 内存回收</h2><p>Redis通过跟踪对象的引用计数信息，在适当的时候自动释放对象并进行内存回收。</p>\n<p>计数信息由 <code>redisObject</code> 结构的 <code>refcount</code> 属性记录</p>\n<ul>\n<li>在创建一个新对象时， 引用计数的值会被初始化为 <code>1</code> ；</li>\n<li>当对象被一个新程序使用时， 它的引用计数值会被增一；</li>\n<li>当对象不再被一个程序使用时， 它的引用计数值会被减一；</li>\n<li>当对象的引用计数值变为 <code>0</code> 时， 对象所占用的内存会被释放。</li>\n</ul>\n<p>对应的API：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">函数</th>\n<th style=\"text-align:left\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>incrRefCount</code></td>\n<td style=\"text-align:left\">将对象的引用计数值增一。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>decrRefCount</code></td>\n<td style=\"text-align:left\">将对象的引用计数值减一， 当对象的引用计数值等于 <code>0</code> 时， 释放对象。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>resetRefCount</code></td>\n<td style=\"text-align:left\">将对象的引用计数值设置为 <code>0</code> ， 但并不释放对象， 这个函数通常在需要重新设置对象的引用计数值时使用。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>对象生命周期可以划分为创建对象、操作对象、释放对象三个阶段</p>\n<p>一个字符串对象从创建到释放的整个过程：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建一个字符串对象 s ，对象的引用计数为 1</span></span><br><span class=\"line\">robj *s = createStringObject(...)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对象 s 执行各种操作 ...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将对象 s 的引用计数减一，使得对象的引用计数变为 0</span></span><br><span class=\"line\"><span class=\"comment\">// 导致对象 s 被释放</span></span><br><span class=\"line\">decrRefCount(s)</span><br></pre></td></tr></table></figure>\n<p>是不是通过计算指向对象这块内存的指针数量来实现的？</p>\n<h3 id=\"8-9-对象共享\"><a href=\"#8-9-对象共享\" class=\"headerlink\" title=\"8.9 对象共享\"></a>8.9 对象共享</h3><p>对于整数值的字符串对象（int编码），在新创建一个字符串对象的时候如果有这个值的字符串对象存在，就不再为新键创建字符串对象，而是将这个新键指向之前已经存在了的字符串对象。然后将这个字符串对象的引用+1。主要目的是节约内存。</p>\n<p>Redis初始化服务器的时候创建一万个字符串对象， 这些对象包含了从 <code>0</code> 到 <code>9999</code> 的所有整数值， 当服务器需要用到值为 <code>0</code>到 <code>9999</code> 的字符串对象时， 服务器就会使用这些共享对象， 而不是新创建对象。</p>\n<p>创建共享字符串对象的数量可以通过修改 <code>redis.h/REDIS_SHARED_INTEGERS</code> 常量来修改。</p>\n<p><strong>为什么 Redis 不共享包含字符串的对象？</strong></p>\n<p>当服务器考虑将一个共享对象设置为键的值对象时， 程序需要先检查给定的共享对象和键想创建的目标对象是否完全相同， 只有在共享对象和目标对象完全相同的情况下， 程序才会将共享对象用作键的值对象， 而一个共享对象保存的值越复杂， 验证共享对象和目标对象是否相同所需的复杂度就会越高， 消耗的 CPU 时间也会越多：</p>\n<ul>\n<li>如果共享对象是保存整数值的字符串对象， 那么验证操作的复杂度为 O(1) ；</li>\n<li>如果共享对象是保存字符串值的字符串对象， 那么验证操作的复杂度为 O(N) ；</li>\n<li>如果共享对象是包含了多个值（或者对象的）对象， 比如列表对象或者哈希对象， 那么验证操作的复杂度将会是 O(N^2) 。</li>\n</ul>\n<p>因此， 尽管共享更复杂的对象可以节约更多的内存， 但受到 CPU 时间的限制， Redis 只对包含整数值的字符串对象进行共享。 （时刻在空间与时间上做权衡）</p>\n<h2 id=\"8-9-对象的空转时长\"><a href=\"#8-9-对象的空转时长\" class=\"headerlink\" title=\"8.9 对象的空转时长\"></a>8.9 对象的空转时长</h2><p><code>lru</code> 属性， 该属性记录了对象最后一次被<strong>命令程序访问</strong>的时间。</p>\n<p>OBJECT IDLETIME 命令可以打印出给定键的空转时长， 这一空转时长就是通过将当前时间减去键的值对象的 <code>lru</code> 时间计算得出的。</p>\n<p>OBJECT IDLETIME 命令的实现是特殊的， 这个命令在访问键的值对象时， 不会修改值对象的 <code>lru</code> 属性。</p>\n<p>lru的主要作用就是配合maxmemory选项，淘汰不常用的键值对。</p>\n<p>如果服务器打开了 <code>maxmemory</code> 选项， 并且服务器用于回收内存的算法为 <code>volatile-lru</code> 或者 <code>allkeys-lru</code> ， 那么当服务器占用的内存数超过了 <code>maxmemory</code> 选项所设置的上限值时， 空转时长较高的那部分键会优先被服务器释放， 从而回收内存。</p>\n<h2 id=\"疑惑\"><a href=\"#疑惑\" class=\"headerlink\" title=\"疑惑\"></a>疑惑</h2><ol>\n<li>为什么在一块连续的内存里面可以更好地利用缓存带来的优势？</li>\n<li>引用计数的程序怎么定义？是指线程吗？</li>\n<li>引用计数的具体实现？</li>\n<li>对象共享的时候怎么去判断存不存在已经创建了这个整数值的对象？对整个数据库遍历吗？</li>\n</ol>\n","site":{"data":{}},"length":6261,"excerpt":"<h1 id=\"Redis设计与实现读书笔记——第8章-对象\"><a href=\"#Redis设计与实现读书笔记——第8章-对象\" class=\"headerlink\" title=\"Redis设计与实现读书笔记——第8章 对象\"></a>Redis设计与实现读书笔记——第8章 对象</h1><p>Redis 并没有直接使用sds、dict等数据结构来实现键值对数据库， 而是基于这些数据结构创建了一个对象系统， 这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象， 每种对象都用到了至少一种前面所介绍的数据结构。</p>","more":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>对象的好处：</p>\n<ul>\n<li>根据对象的类型来判断是否可以执行给定的命令。</li>\n<li>针对不同的使用场景， 为对象设置多种不同的数据结构实现， 从而优化对象在不同场景下的使用效率。</li>\n</ul>\n<p>对象的特性：</p>\n<ul>\n<li>基于引用计数技术的内存回收机制（和java的是否原理相似）</li>\n<li>通过引用计数技术实现对象共享机制，多个键共享同一个对象来节约内存</li>\n<li>带有访问时间记录信息，可以用来删除空转时长较大的键</li>\n</ul>\n<h2 id=\"8-1-对象的类型与编码\"><a href=\"#8-1-对象的类型与编码\" class=\"headerlink\" title=\"8.1 对象的类型与编码\"></a>8.1 对象的类型与编码</h2><p>Redis 使用对象来表示数据库中的键和值，创建一个新的键值对的时候，至少包含两个对象：1. 键对象 2. 值对象</p>\n<p>对象都由一个 <code>redisObject</code> 结构表示，保存数据相关的属性</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">redisObject</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 对象类型</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> type:<span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 编码</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> encoding:<span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"comment\">//lru 时钟 记录最后被访问的时间，也就是空转时长</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> lru:LRU_BITS; <span class=\"comment\">/* LRU time (relative to global lru_clock) or</span></span><br><span class=\"line\"><span class=\"comment\">                            * LFU data (least significant 8 bits frequency</span></span><br><span class=\"line\"><span class=\"comment\">                            * and most significant 16 bits decreas time). */</span></span><br><span class=\"line\">    <span class=\"comment\">// 引用计数 实现内存自动回收等。</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> refcount;</span><br><span class=\"line\">    <span class=\"comment\">// 指向底层实现数据结构的指针</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *ptr;</span><br><span class=\"line\">&#125; robj;</span><br></pre></td></tr></table></figure>\n<p>ptr指向的就是之前的sds，dict这些数据结构的内存地址。</p>\n<p>变量申明加冒号的用法： 是C语言的位域的用法。<code>:</code>后面的数字用来限定成员变量占用的位数。冒号后面的数字说明只会用到对应多少个bit位。type只会用到4个bit，encoding 也只会用的4个bit。变量占用的内存不再是有类型决定，而是位域。</p>\n<h3 id=\"8-1-1-类型\"><a href=\"#8-1-1-类型\" class=\"headerlink\" title=\"8.1.1 类型\"></a>8.1.1 类型</h3><p>type属性的值包括5种：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">类型常量</th>\n<th style=\"text-align:left\">对象的名称</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_STRING</code></td>\n<td style=\"text-align:left\">字符串对象</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_LIST</code></td>\n<td style=\"text-align:left\">列表对象</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_HASH</code></td>\n<td style=\"text-align:left\">哈希对象</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_SET</code></td>\n<td style=\"text-align:left\">集合对象</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_ZSET</code></td>\n<td style=\"text-align:left\">有序集合对象</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>键对象只能是字符串对象，而值对象则5种之一。所以执行TYPE命令返回的是键值对中值对象的类型。</p>\n<p>type命令的</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">对象</th>\n<th style=\"text-align:left\">对象 <code>type</code> 属性的值</th>\n<th style=\"text-align:left\">TYPE 命令的输出</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">字符串对象</td>\n<td style=\"text-align:left\"><code>REDIS_STRING</code></td>\n<td style=\"text-align:left\"><code>&quot;string&quot;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">列表对象</td>\n<td style=\"text-align:left\"><code>REDIS_LIST</code></td>\n<td style=\"text-align:left\"><code>&quot;list&quot;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">哈希对象</td>\n<td style=\"text-align:left\"><code>REDIS_HASH</code></td>\n<td style=\"text-align:left\"><code>&quot;hash&quot;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">集合对象</td>\n<td style=\"text-align:left\"><code>REDIS_SET</code></td>\n<td style=\"text-align:left\"><code>&quot;set&quot;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">有序集合对象</td>\n<td style=\"text-align:left\"><code>REDIS_ZSET</code></td>\n<td style=\"text-align:left\"><code>&quot;zset&quot;</code></td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"8-2-编码和底层实现\"><a href=\"#8-2-编码和底层实现\" class=\"headerlink\" title=\"8.2 编码和底层实现\"></a>8.2 编码和底层实现</h3><p>ptr指向底层数据结构，而encoding则决定了具体应该指向什么样的数据结构实现。之所以不能用type来决定指向的具体数据结构，是因为同一种对象，但是底层实现会有不同的数据结构。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">编码常量</th>\n<th style=\"text-align:left\">编码所对应的底层数据结构</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_INT</code></td>\n<td style=\"text-align:left\"><code>long</code> 类型的整数</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_EMBSTR</code></td>\n<td style=\"text-align:left\"><code>embstr</code> 编码的简单动态字符串</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_RAW</code></td>\n<td style=\"text-align:left\">简单动态字符串</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_HT</code></td>\n<td style=\"text-align:left\">字典</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_LINKEDLIST</code></td>\n<td style=\"text-align:left\">双端链表</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_ZIPLIST</code></td>\n<td style=\"text-align:left\">压缩列表</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_INTSET</code></td>\n<td style=\"text-align:left\">整数集合</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_SKIPLIST</code></td>\n<td style=\"text-align:left\">跳跃表和字典</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>每种类型的对象都至少使用了两种不同的编码，对应关系为：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">类型</th>\n<th style=\"text-align:left\">编码</th>\n<th style=\"text-align:left\">对象</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_STRING</code></td>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_INT</code></td>\n<td style=\"text-align:left\">使用整数值实现的字符串对象。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_STRING</code></td>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_EMBSTR</code></td>\n<td style=\"text-align:left\">使用 <code>embstr</code> 编码的简单动态字符串实现的字符串对象。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_STRING</code></td>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_RAW</code></td>\n<td style=\"text-align:left\">使用简单动态字符串实现的字符串对象。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_LIST</code></td>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_ZIPLIST</code></td>\n<td style=\"text-align:left\">使用压缩列表实现的列表对象。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_LIST</code></td>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_LINKEDLIST</code></td>\n<td style=\"text-align:left\">使用双端链表实现的列表对象。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_HASH</code></td>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_ZIPLIST</code></td>\n<td style=\"text-align:left\">使用压缩列表实现的哈希对象。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_HASH</code></td>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_HT</code></td>\n<td style=\"text-align:left\">使用字典实现的哈希对象。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_SET</code></td>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_INTSET</code></td>\n<td style=\"text-align:left\">使用整数集合实现的集合对象。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_SET</code></td>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_HT</code></td>\n<td style=\"text-align:left\">使用字典实现的集合对象。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_ZSET</code></td>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_ZIPLIST</code></td>\n<td style=\"text-align:left\">使用压缩列表实现的有序集合对象。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>REDIS_ZSET</code></td>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_SKIPLIST</code></td>\n<td style=\"text-align:left\">使用跳跃表和字典实现的有序集合对象。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>使用 OBJECT ENCODING 命令可以查看一个数据库键的值对象的编码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; SET msg &quot;hello wrold&quot;</span><br><span class=\"line\">OK</span><br><span class=\"line\"></span><br><span class=\"line\">redis&gt; OBJECT ENCODING msg</span><br><span class=\"line\">&quot;embstr&quot;</span><br></pre></td></tr></table></figure>\n<p>不同编码的对象所对应的OBJECT ENCODING输出：</p>\n<p>表 8-5 OBJECT ENCODING 对不同编码的输出</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">对象所使用的底层数据结构</th>\n<th style=\"text-align:left\">编码常量</th>\n<th style=\"text-align:left\">OBJECT ENCODING 命令输出</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">整数</td>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_INT</code></td>\n<td style=\"text-align:left\"><code>&quot;int&quot;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>embstr</code> 编码的简单动态字符串（SDS）</td>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_EMBSTR</code></td>\n<td style=\"text-align:left\"><code>&quot;embstr&quot;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">简单动态字符串</td>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_RAW</code></td>\n<td style=\"text-align:left\"><code>&quot;raw&quot;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">字典</td>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_HT</code></td>\n<td style=\"text-align:left\"><code>&quot;hashtable&quot;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">双端链表</td>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_LINKEDLIST</code></td>\n<td style=\"text-align:left\"><code>&quot;linkedlist&quot;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">压缩列表</td>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_ZIPLIST</code></td>\n<td style=\"text-align:left\"><code>&quot;ziplist&quot;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">整数集合</td>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_INTSET</code></td>\n<td style=\"text-align:left\"><code>&quot;intset&quot;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">跳跃表和字典</td>\n<td style=\"text-align:left\"><code>REDIS_ENCODING_SKIPLIST</code></td>\n<td style=\"text-align:left\"><code>&quot;skiplist&quot;</code></td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>使用encoding属性来设定对象指向的具体数据结构实现的好处：灵活与效率。根据不同场景来给同一种对象设置不同的数据结构实现。</p>\n<p>举个例子， 在列表对象包含的元素比较少时， Redis 使用压缩列表作为列表对象的底层实现：</p>\n<ul>\n<li>因为压缩列表比双端链表更节约内存， 并且在元素数量较少时， 在内存中以连续块方式保存的压缩列表比起双端链表可以更快被载入到缓存中；</li>\n<li>随着列表对象包含的元素越来越多， 使用压缩列表来保存元素的优势逐渐消失时， 对象就会将底层实现从压缩列表转向功能更强、也更适合保存大量元素的双端链表上面；</li>\n</ul>\n<p>是不是也可以理解成多态呢？</p>\n<h2 id=\"8-2-字符串对象\"><a href=\"#8-2-字符串对象\" class=\"headerlink\" title=\"8.2 字符串对象\"></a>8.2 字符串对象</h2><p>字符串对象的编码可以是 <code>int</code> 、 <code>raw</code> 或者 <code>embstr</code> 。</p>\n<ol>\n<li>保存的对象是整数，而且可以用long类型表示：ptr指针指向一个long类型的内存地址。（是不是不用指向sdshdr了），然后将encoding 设置为REDIS_ENCODING_INT (应该在源码中有个宏定义)</li>\n<li>保存的对象是字符串值，长度小于44字节（书上的39字节，但是先版本已经更新）。这种短字符串对象，直接<strong>只调用一次内存分配</strong>函数来分配一块<strong>连续的空间</strong>  依次包含redisObject和sdshdr两个结构。</li>\n<li>字符串长度大于等于44字节的时候使用raw编码。会调用两次内存分配函数来创建redisObject结构和sdshdr结构。</li>\n</ol>\n<p>embstr编码的好处：</p>\n<ul>\n<li>只用分配一次内存，raw编码需要两次</li>\n<li>释放embstr的sds也只需要一次内存释放函数，raw两次</li>\n<li>embstr的所有数据（对象结构，字符串结构）在连续的一块内存里面，从而可以更好地利用缓存带来的优势</li>\n</ul>\n<p>embstr和raw的示意图，摘自书上，但是注意sds的结构稍有变化。</p>\n<p>raw编码：</p>\n<p><img src=\"http://redisbook.com/_images/graphviz-8731210637d0567af28d3a9d4089d5f864d29950.png\" alt=\"\"></p>\n<p>embstr编码：</p>\n<p><img src=\"http://redisbook.com/_images/graphviz-900c13b23ce79372939259603be936c955ccaa62.png\" alt=\"\"></p>\n<p>注意：</p>\n<p>long double类型的浮点数是转换成字符串值来保存的。执行的时候取出字符串再转换成long double 类型。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">值</th>\n<th style=\"text-align:left\">编码</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">可以用 <code>long</code> 类型保存的整数。</td>\n<td style=\"text-align:left\"><code>int</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">可以用 <code>long double</code> 类型保存的浮点数。</td>\n<td style=\"text-align:left\"><code>embstr</code> 或者 <code>raw</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">字符串值， 或者因为长度太大而没办法用 <code>long</code> 类型表示的整数， 又或者因为长度太大而没办法用 <code>long double</code> 类型表示的浮点数。</td>\n<td style=\"text-align:left\"><code>embstr</code> 或者 <code>raw</code></td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"8-2-1-编码的转换\"><a href=\"#8-2-1-编码的转换\" class=\"headerlink\" title=\"8.2.1 编码的转换\"></a>8.2.1 编码的转换</h3><p>当保存的值发生变化的时候会进行转换，比如保存的整数值变成了字符串，那么编码从int 变成raw或者embstr。</p>\n<p><strong>注意</strong>： Redis 没有为embstr编写任何修改程序，只有int和raw编码的字符串对象有这些程序，所以embstr编码的对象是只读，因此发生修改的话会从embstr变成raw。</p>\n<p>发生修改的源码中应该是将原来的ptr指向的数据结构内存释放掉后，重新指向新创建的对象。</p>\n<h3 id=\"8-2-2-字符串命令的实现\"><a href=\"#8-2-2-字符串命令的实现\" class=\"headerlink\" title=\"8.2.2 字符串命令的实现\"></a>8.2.2 字符串命令的实现</h3><p>所有命令都是针对字符串对象的。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">命令</th>\n<th style=\"text-align:left\"><code>int</code> 编码的实现方法</th>\n<th style=\"text-align:left\"><code>embstr</code> 编码的实现方法</th>\n<th style=\"text-align:left\"><code>raw</code> 编码的实现方法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">SET</td>\n<td style=\"text-align:left\">使用 <code>int</code> 编码保存值。</td>\n<td style=\"text-align:left\">使用 <code>embstr</code> 编码保存值。</td>\n<td style=\"text-align:left\">使用 <code>raw</code> 编码保存值。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">GET</td>\n<td style=\"text-align:left\">拷贝对象所保存的整数值， 将这个拷贝转换成字符串值， 然后向客户端返回这个字符串值。</td>\n<td style=\"text-align:left\">直接向客户端返回字符串值。</td>\n<td style=\"text-align:left\">直接向客户端返回字符串值。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">APPEND</td>\n<td style=\"text-align:left\">将对象转换成 <code>raw</code> 编码， 然后按 <code>raw</code>编码的方式执行此操作。</td>\n<td style=\"text-align:left\">将对象转换成 <code>raw</code> 编码， 然后按 <code>raw</code>编码的方式执行此操作。</td>\n<td style=\"text-align:left\">调用 <code>sdscatlen</code> 函数， 将给定字符串追加到现有字符串的末尾。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">INCRBYFLOAT</td>\n<td style=\"text-align:left\">取出整数值并将其转换成 <code>longdouble</code> 类型的浮点数， 对这个浮点数进行加法计算， 然后将得出的浮点数结果保存起来。</td>\n<td style=\"text-align:left\">取出字符串值并尝试将其转换成<code>long double</code> 类型的浮点数， 对这个浮点数进行加法计算， 然后将得出的浮点数结果保存起来。 如果字符串值不能被转换成浮点数， 那么向客户端返回一个错误。</td>\n<td style=\"text-align:left\">取出字符串值并尝试将其转换成 <code>longdouble</code> 类型的浮点数， 对这个浮点数进行加法计算， 然后将得出的浮点数结果保存起来。 如果字符串值不能被转换成浮点数， 那么向客户端返回一个错误。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">INCRBY</td>\n<td style=\"text-align:left\">对整数值进行加法计算， 得出的计算结果会作为整数被保存起来。</td>\n<td style=\"text-align:left\"><code>embstr</code> 编码不能执行此命令， 向客户端返回一个错误。</td>\n<td style=\"text-align:left\"><code>raw</code> 编码不能执行此命令， 向客户端返回一个错误。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">DECRBY</td>\n<td style=\"text-align:left\">对整数值进行减法计算， 得出的计算结果会作为整数被保存起来。</td>\n<td style=\"text-align:left\"><code>embstr</code> 编码不能执行此命令， 向客户端返回一个错误。</td>\n<td style=\"text-align:left\"><code>raw</code> 编码不能执行此命令， 向客户端返回一个错误。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">STRLEN</td>\n<td style=\"text-align:left\">拷贝对象所保存的整数值， 将这个拷贝转换成字符串值， 计算并返回这个字符串值的长度。</td>\n<td style=\"text-align:left\">调用 <code>sdslen</code> 函数， 返回字符串的长度。</td>\n<td style=\"text-align:left\">调用 <code>sdslen</code> 函数， 返回字符串的长度。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">SETRANGE</td>\n<td style=\"text-align:left\">将对象转换成 <code>raw</code> 编码， 然后按 <code>raw</code>编码的方式执行此命令。</td>\n<td style=\"text-align:left\">将对象转换成 <code>raw</code> 编码， 然后按 <code>raw</code>编码的方式执行此命令。</td>\n<td style=\"text-align:left\">将字符串特定索引上的值设置为给定的字符。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">GETRANGE</td>\n<td style=\"text-align:left\">拷贝对象所保存的整数值， 将这个拷贝转换成字符串值， 然后取出并返回字符串指定索引上的字符。</td>\n<td style=\"text-align:left\">直接取出并返回字符串指定索引上的字符。</td>\n<td style=\"text-align:left\">直接取出并返回字符串指定索引上的字符。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"8-8-内存回收\"><a href=\"#8-8-内存回收\" class=\"headerlink\" title=\"8.8 内存回收\"></a>8.8 内存回收</h2><p>Redis通过跟踪对象的引用计数信息，在适当的时候自动释放对象并进行内存回收。</p>\n<p>计数信息由 <code>redisObject</code> 结构的 <code>refcount</code> 属性记录</p>\n<ul>\n<li>在创建一个新对象时， 引用计数的值会被初始化为 <code>1</code> ；</li>\n<li>当对象被一个新程序使用时， 它的引用计数值会被增一；</li>\n<li>当对象不再被一个程序使用时， 它的引用计数值会被减一；</li>\n<li>当对象的引用计数值变为 <code>0</code> 时， 对象所占用的内存会被释放。</li>\n</ul>\n<p>对应的API：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">函数</th>\n<th style=\"text-align:left\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>incrRefCount</code></td>\n<td style=\"text-align:left\">将对象的引用计数值增一。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>decrRefCount</code></td>\n<td style=\"text-align:left\">将对象的引用计数值减一， 当对象的引用计数值等于 <code>0</code> 时， 释放对象。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>resetRefCount</code></td>\n<td style=\"text-align:left\">将对象的引用计数值设置为 <code>0</code> ， 但并不释放对象， 这个函数通常在需要重新设置对象的引用计数值时使用。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>对象生命周期可以划分为创建对象、操作对象、释放对象三个阶段</p>\n<p>一个字符串对象从创建到释放的整个过程：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建一个字符串对象 s ，对象的引用计数为 1</span></span><br><span class=\"line\">robj *s = createStringObject(...)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对象 s 执行各种操作 ...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将对象 s 的引用计数减一，使得对象的引用计数变为 0</span></span><br><span class=\"line\"><span class=\"comment\">// 导致对象 s 被释放</span></span><br><span class=\"line\">decrRefCount(s)</span><br></pre></td></tr></table></figure>\n<p>是不是通过计算指向对象这块内存的指针数量来实现的？</p>\n<h3 id=\"8-9-对象共享\"><a href=\"#8-9-对象共享\" class=\"headerlink\" title=\"8.9 对象共享\"></a>8.9 对象共享</h3><p>对于整数值的字符串对象（int编码），在新创建一个字符串对象的时候如果有这个值的字符串对象存在，就不再为新键创建字符串对象，而是将这个新键指向之前已经存在了的字符串对象。然后将这个字符串对象的引用+1。主要目的是节约内存。</p>\n<p>Redis初始化服务器的时候创建一万个字符串对象， 这些对象包含了从 <code>0</code> 到 <code>9999</code> 的所有整数值， 当服务器需要用到值为 <code>0</code>到 <code>9999</code> 的字符串对象时， 服务器就会使用这些共享对象， 而不是新创建对象。</p>\n<p>创建共享字符串对象的数量可以通过修改 <code>redis.h/REDIS_SHARED_INTEGERS</code> 常量来修改。</p>\n<p><strong>为什么 Redis 不共享包含字符串的对象？</strong></p>\n<p>当服务器考虑将一个共享对象设置为键的值对象时， 程序需要先检查给定的共享对象和键想创建的目标对象是否完全相同， 只有在共享对象和目标对象完全相同的情况下， 程序才会将共享对象用作键的值对象， 而一个共享对象保存的值越复杂， 验证共享对象和目标对象是否相同所需的复杂度就会越高， 消耗的 CPU 时间也会越多：</p>\n<ul>\n<li>如果共享对象是保存整数值的字符串对象， 那么验证操作的复杂度为 O(1) ；</li>\n<li>如果共享对象是保存字符串值的字符串对象， 那么验证操作的复杂度为 O(N) ；</li>\n<li>如果共享对象是包含了多个值（或者对象的）对象， 比如列表对象或者哈希对象， 那么验证操作的复杂度将会是 O(N^2) 。</li>\n</ul>\n<p>因此， 尽管共享更复杂的对象可以节约更多的内存， 但受到 CPU 时间的限制， Redis 只对包含整数值的字符串对象进行共享。 （时刻在空间与时间上做权衡）</p>\n<h2 id=\"8-9-对象的空转时长\"><a href=\"#8-9-对象的空转时长\" class=\"headerlink\" title=\"8.9 对象的空转时长\"></a>8.9 对象的空转时长</h2><p><code>lru</code> 属性， 该属性记录了对象最后一次被<strong>命令程序访问</strong>的时间。</p>\n<p>OBJECT IDLETIME 命令可以打印出给定键的空转时长， 这一空转时长就是通过将当前时间减去键的值对象的 <code>lru</code> 时间计算得出的。</p>\n<p>OBJECT IDLETIME 命令的实现是特殊的， 这个命令在访问键的值对象时， 不会修改值对象的 <code>lru</code> 属性。</p>\n<p>lru的主要作用就是配合maxmemory选项，淘汰不常用的键值对。</p>\n<p>如果服务器打开了 <code>maxmemory</code> 选项， 并且服务器用于回收内存的算法为 <code>volatile-lru</code> 或者 <code>allkeys-lru</code> ， 那么当服务器占用的内存数超过了 <code>maxmemory</code> 选项所设置的上限值时， 空转时长较高的那部分键会优先被服务器释放， 从而回收内存。</p>\n<h2 id=\"疑惑\"><a href=\"#疑惑\" class=\"headerlink\" title=\"疑惑\"></a>疑惑</h2><ol>\n<li>为什么在一块连续的内存里面可以更好地利用缓存带来的优势？</li>\n<li>引用计数的程序怎么定义？是指线程吗？</li>\n<li>引用计数的具体实现？</li>\n<li>对象共享的时候怎么去判断存不存在已经创建了这个整数值的对象？对整个数据库遍历吗？</li>\n</ol>"},{"title":"gdb 调试","date":"2019-04-03T08:29:00.000Z","copyright":true,"_content":"\n# gdb调试\n\n以前学习过，用得少，又忘记了，现在刚好为了调试redis 的dict 模块，所以再次记录。\n\n<!--more-->\n\n## 使用\n\n摘自参考<<https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html>>。 主要是补充实例\n\n对C/C++程序的调试，需要在编译前就加上-g选项:\n\n```\n$g++ -g hello.cpp -o hello\n```\n\n自己的Makefile里面修改成：\n\n```\ndict-benchmark: dict.c sds.c siphash.c\n        $(CC) -g -o $@ $^\n```\n\n但是好像没加之前也是可以直接就使用gdb  了？ 不知道为什么（可以使用但是出错不会显示所在的行，相当于没有调试）\n\n调试可执行文件:\n\n```\n$gdb <program>\n```\n\nprogram也就是你的执行文件，一般在当前目录下。\n\n调试core文件(core是程序非法执行后core dump后产生的文件):\n\n```\n$gdb <program> <core dump file>\n$gdb program core.11127\n```\n\n调试服务程序:\n\n```\n$gdb <program> <PID>\n$gdb hello 11127\n```\n\n如果你的程序是一个服务程序，那么你可以指定这个服务程序运行时的进程ID。gdb会自动attach上去，并调试他。program应该在PATH环境变量中搜索得到。\n\n## gdb交互命令\n\n启动gdb后，进入到交互模式，通过以下命令完成对程序的调试；注意高频使用的命令一般都会有缩写，熟练使用这些缩写命令能提高调试的效率；\n\n### 运行\n\n- run：简记为 r ，其作用是运行程序，当遇到断点后，程序会在断点处停止运行，等待用户输入下一步的命令。\n- continue （简写c ）：继续执行，到下一个断点处（或运行结束）\n- next：（简写 n），单步跟踪程序，当遇到函数调用时，也不进入此函数体；此命令同 step 的主要区别是，step 遇到用户自定义的函数，将步进到函数中去运行，而 next 则直接调用函数，不会进入到函数体内。\n- step （简写s）：单步调试如果有函数调用，则进入函数；与命令n不同，n是不进入调用的函数的\n- until：当你厌倦了在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体。\n- until+行号： 运行至某行，不仅仅用来跳出循环\n- finish： 运行程序，直到当前函数完成返回，并打印函数返回时的堆栈地址和返回值及参数值等信息。\n- call 函数(参数)：调用程序中可见的函数，并传递“参数”，如：call gdb_test(55)\n- quit：简记为 q ，退出gdb\n\n### 设置断点\n\n- break n （简写b n）:在第n行处设置断点\n\n  （可以带上代码路径和代码名称： b OAGUPDATE.cpp:578）\n\n- b fn1 if a＞b：条件断点设置\n\n- break func（break缩写为b）：在函数func()的入口处设置断点，如：break cb_button\n\n- delete 断点号n：删除第n个断点\n\n- disable 断点号n：暂停第n个断点\n\n- enable 断点号n：开启第n个断点\n\n- clear 行号n：清除第n行的断点\n\n- info b （info breakpoints） ：显示当前程序的断点设置情况\n\n- delete breakpoints：清除所有断点：\n\n### 查看源代码\n\n- list ：简记为 l ，其作用就是列出程序的源代码，默认每次显示10行。\n- list 行号：将显示当前文件以“行号”为中心的前后10行代码，如：list 12\n- list 函数名：将显示“函数名”所在函数的源代码，如：list main\n- list ：不带参数，将接着上一次 list 命令的，输出下边的内容。\n\n### 打印表达式\n\n- print 表达式：简记为 p ，其中“表达式”可以是任何当前正在被测试程序的有效表达式，比如当前正在调试C语言的程序，那么“表达式”可以是任何C语言的有效表达式，包括数字，变量甚至是函数调用。\n- print a：将显示整数 a 的值\n- print ++a：将把 a 中的值加1,并显示出来\n- print name：将显示字符串 name 的值\n- print gdb_test(22)：将以整数22作为参数调用 gdb_test() 函数\n- print gdb_test(a)：将以变量 a 作为参数调用 gdb_test() 函数\n- display 表达式：在单步运行时将非常有用，使用display命令设置一个表达式后，它将在每次单步进行指令后，紧接着输出被设置的表达式及值。如： display a\n- watch 表达式：设置一个监视点，一旦被监视的“表达式”的值改变，gdb将强行终止正在被调试的程序。如： watch a\n- whatis ：查询变量或函数\n- info function： 查询函数\n- 扩展info locals： 显示当前堆栈页的所有变量\n\n### 查询运行信息\n\n- where/bt ：当前运行的堆栈列表；\n- bt backtrace 显示当前调用堆栈\n- up/down 改变堆栈显示的深度\n- set args 参数:指定运行时的参数\n- show args：查看设置好的参数\n- info program： 来查看程序的是否在运行，进程号，被暂停的原因。\n\n### 分割窗口\n\n- layout：用于分割窗口，可以一边查看代码，一边测试：\n- layout src：显示源代码窗口\n- layout asm：显示反汇编窗口\n- layout regs：显示源代码/反汇编和CPU寄存器窗口\n- layout split：显示源代码和反汇编窗口\n- Ctrl + L：刷新窗口\n\n## 实例\n\n调试程序dict-benchmark\n\n开始调试：\n\n```\nroot@hw103:/home/yky/test/redis_dict/dict-benchmark# gdb dict-benchmark \nGNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1\nCopyright (C) 2016 Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.  Type \"show copying\"\nand \"show warranty\" for details.\nThis GDB was configured as \"x86_64-linux-gnu\".\nType \"show configuration\" for configuration details.\nFor bug reporting instructions, please see:\n<http://www.gnu.org/software/gdb/bugs/>.\nFind the GDB manual and other documentation resources online at:\n<http://www.gnu.org/software/gdb/documentation/>.\nFor help, type \"help\".\nType \"apropos word\" to search for commands related to \"word\"...\nReading symbols from dict-benchmark...done.\n(gdb) \n```\n\n使用 r 运行：\n\n```\n(gdb) r\nStarting program: /home/yky/test/redis_dict/dict-benchmark/dict-benchmark \nAdd elements to dict\nAdd ret0 is :0, ht[0].used:1, ht[0].size:4,ht[1].used:0, ht[1].size:0\nAdd ret1 is :0, ht[0].used:2, ht[0].size:4,ht[1].used:0, ht[1].size:0\nAdd ret2 is :0, ht[0].used:3, ht[0].size:4,ht[1].used:0, ht[1].size:0\n\nProgram received signal SIGSEGV, Segmentation fault.\n0x000000000040288b in _dictKeyIndex (d=0x60a050, key=0x60a011, hash=3050426978, existing=0x0) at dict.c:975\n975                 if (key==he->key || dictCompareKeys(d, key, he->key)) {\n(gdb) \n\n```\n\n在_dictKeyIndex ()函数也就是计算索引的时候出错。\n\nl 列出代码：\n\n```\n(gdb) l\n970         for (table = 0; table <= 1; table++) {\n971             idx = hash & d->ht[table].sizemask;\n972             /* Search if this slot does not already contain the given key */\n973             he = d->ht[table].table[idx];\n974             while(he) {\n975                 if (key==he->key || dictCompareKeys(d, key, he->key)) {\n976                     if (existing) *existing = he;\n977                     return -1;\n978                 }\n979                 he = he->next;\n\n```\n\n在975行加入断点  b n\n\n```\n(gdb) b 975\nBreakpoint 2 at 0x402887: file dict.c, line 975.\n\n```\n\n输出对应变量的值：print\n\n```\n(gdb) print key \n$1 = (const void *) 0x60a011\n```\n\n\n\n## 参考\n\n<https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html>","source":"_posts/2019-04-03-gdb-调试.md","raw":"---\ntitle: gdb 调试\ndate: 2019-04-03 16:29:00\ncategories: Linux\ntags:\n- gdb\n- 工具\ncopyright: true\n---\n\n# gdb调试\n\n以前学习过，用得少，又忘记了，现在刚好为了调试redis 的dict 模块，所以再次记录。\n\n<!--more-->\n\n## 使用\n\n摘自参考<<https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html>>。 主要是补充实例\n\n对C/C++程序的调试，需要在编译前就加上-g选项:\n\n```\n$g++ -g hello.cpp -o hello\n```\n\n自己的Makefile里面修改成：\n\n```\ndict-benchmark: dict.c sds.c siphash.c\n        $(CC) -g -o $@ $^\n```\n\n但是好像没加之前也是可以直接就使用gdb  了？ 不知道为什么（可以使用但是出错不会显示所在的行，相当于没有调试）\n\n调试可执行文件:\n\n```\n$gdb <program>\n```\n\nprogram也就是你的执行文件，一般在当前目录下。\n\n调试core文件(core是程序非法执行后core dump后产生的文件):\n\n```\n$gdb <program> <core dump file>\n$gdb program core.11127\n```\n\n调试服务程序:\n\n```\n$gdb <program> <PID>\n$gdb hello 11127\n```\n\n如果你的程序是一个服务程序，那么你可以指定这个服务程序运行时的进程ID。gdb会自动attach上去，并调试他。program应该在PATH环境变量中搜索得到。\n\n## gdb交互命令\n\n启动gdb后，进入到交互模式，通过以下命令完成对程序的调试；注意高频使用的命令一般都会有缩写，熟练使用这些缩写命令能提高调试的效率；\n\n### 运行\n\n- run：简记为 r ，其作用是运行程序，当遇到断点后，程序会在断点处停止运行，等待用户输入下一步的命令。\n- continue （简写c ）：继续执行，到下一个断点处（或运行结束）\n- next：（简写 n），单步跟踪程序，当遇到函数调用时，也不进入此函数体；此命令同 step 的主要区别是，step 遇到用户自定义的函数，将步进到函数中去运行，而 next 则直接调用函数，不会进入到函数体内。\n- step （简写s）：单步调试如果有函数调用，则进入函数；与命令n不同，n是不进入调用的函数的\n- until：当你厌倦了在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体。\n- until+行号： 运行至某行，不仅仅用来跳出循环\n- finish： 运行程序，直到当前函数完成返回，并打印函数返回时的堆栈地址和返回值及参数值等信息。\n- call 函数(参数)：调用程序中可见的函数，并传递“参数”，如：call gdb_test(55)\n- quit：简记为 q ，退出gdb\n\n### 设置断点\n\n- break n （简写b n）:在第n行处设置断点\n\n  （可以带上代码路径和代码名称： b OAGUPDATE.cpp:578）\n\n- b fn1 if a＞b：条件断点设置\n\n- break func（break缩写为b）：在函数func()的入口处设置断点，如：break cb_button\n\n- delete 断点号n：删除第n个断点\n\n- disable 断点号n：暂停第n个断点\n\n- enable 断点号n：开启第n个断点\n\n- clear 行号n：清除第n行的断点\n\n- info b （info breakpoints） ：显示当前程序的断点设置情况\n\n- delete breakpoints：清除所有断点：\n\n### 查看源代码\n\n- list ：简记为 l ，其作用就是列出程序的源代码，默认每次显示10行。\n- list 行号：将显示当前文件以“行号”为中心的前后10行代码，如：list 12\n- list 函数名：将显示“函数名”所在函数的源代码，如：list main\n- list ：不带参数，将接着上一次 list 命令的，输出下边的内容。\n\n### 打印表达式\n\n- print 表达式：简记为 p ，其中“表达式”可以是任何当前正在被测试程序的有效表达式，比如当前正在调试C语言的程序，那么“表达式”可以是任何C语言的有效表达式，包括数字，变量甚至是函数调用。\n- print a：将显示整数 a 的值\n- print ++a：将把 a 中的值加1,并显示出来\n- print name：将显示字符串 name 的值\n- print gdb_test(22)：将以整数22作为参数调用 gdb_test() 函数\n- print gdb_test(a)：将以变量 a 作为参数调用 gdb_test() 函数\n- display 表达式：在单步运行时将非常有用，使用display命令设置一个表达式后，它将在每次单步进行指令后，紧接着输出被设置的表达式及值。如： display a\n- watch 表达式：设置一个监视点，一旦被监视的“表达式”的值改变，gdb将强行终止正在被调试的程序。如： watch a\n- whatis ：查询变量或函数\n- info function： 查询函数\n- 扩展info locals： 显示当前堆栈页的所有变量\n\n### 查询运行信息\n\n- where/bt ：当前运行的堆栈列表；\n- bt backtrace 显示当前调用堆栈\n- up/down 改变堆栈显示的深度\n- set args 参数:指定运行时的参数\n- show args：查看设置好的参数\n- info program： 来查看程序的是否在运行，进程号，被暂停的原因。\n\n### 分割窗口\n\n- layout：用于分割窗口，可以一边查看代码，一边测试：\n- layout src：显示源代码窗口\n- layout asm：显示反汇编窗口\n- layout regs：显示源代码/反汇编和CPU寄存器窗口\n- layout split：显示源代码和反汇编窗口\n- Ctrl + L：刷新窗口\n\n## 实例\n\n调试程序dict-benchmark\n\n开始调试：\n\n```\nroot@hw103:/home/yky/test/redis_dict/dict-benchmark# gdb dict-benchmark \nGNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1\nCopyright (C) 2016 Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.  Type \"show copying\"\nand \"show warranty\" for details.\nThis GDB was configured as \"x86_64-linux-gnu\".\nType \"show configuration\" for configuration details.\nFor bug reporting instructions, please see:\n<http://www.gnu.org/software/gdb/bugs/>.\nFind the GDB manual and other documentation resources online at:\n<http://www.gnu.org/software/gdb/documentation/>.\nFor help, type \"help\".\nType \"apropos word\" to search for commands related to \"word\"...\nReading symbols from dict-benchmark...done.\n(gdb) \n```\n\n使用 r 运行：\n\n```\n(gdb) r\nStarting program: /home/yky/test/redis_dict/dict-benchmark/dict-benchmark \nAdd elements to dict\nAdd ret0 is :0, ht[0].used:1, ht[0].size:4,ht[1].used:0, ht[1].size:0\nAdd ret1 is :0, ht[0].used:2, ht[0].size:4,ht[1].used:0, ht[1].size:0\nAdd ret2 is :0, ht[0].used:3, ht[0].size:4,ht[1].used:0, ht[1].size:0\n\nProgram received signal SIGSEGV, Segmentation fault.\n0x000000000040288b in _dictKeyIndex (d=0x60a050, key=0x60a011, hash=3050426978, existing=0x0) at dict.c:975\n975                 if (key==he->key || dictCompareKeys(d, key, he->key)) {\n(gdb) \n\n```\n\n在_dictKeyIndex ()函数也就是计算索引的时候出错。\n\nl 列出代码：\n\n```\n(gdb) l\n970         for (table = 0; table <= 1; table++) {\n971             idx = hash & d->ht[table].sizemask;\n972             /* Search if this slot does not already contain the given key */\n973             he = d->ht[table].table[idx];\n974             while(he) {\n975                 if (key==he->key || dictCompareKeys(d, key, he->key)) {\n976                     if (existing) *existing = he;\n977                     return -1;\n978                 }\n979                 he = he->next;\n\n```\n\n在975行加入断点  b n\n\n```\n(gdb) b 975\nBreakpoint 2 at 0x402887: file dict.c, line 975.\n\n```\n\n输出对应变量的值：print\n\n```\n(gdb) print key \n$1 = (const void *) 0x60a011\n```\n\n\n\n## 参考\n\n<https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html>","slug":"2019-04-03-gdb-调试","published":1,"updated":"2019-11-08T13:14:43.959Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2yelxh3000cm8tzyx62c0wo","content":"<h1 id=\"gdb调试\"><a href=\"#gdb调试\" class=\"headerlink\" title=\"gdb调试\"></a>gdb调试</h1><p>以前学习过，用得少，又忘记了，现在刚好为了调试redis 的dict 模块，所以再次记录。</p>\n<a id=\"more\"></a>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><p>摘自参考<a href=\"&lt;https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html\">&lt;https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html</a>&gt;。 主要是补充实例</p>\n<p>对C/C++程序的调试，需要在编译前就加上-g选项:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$g++ -g hello.cpp -o hello</span><br></pre></td></tr></table></figure>\n<p>自己的Makefile里面修改成：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dict-benchmark: dict.c sds.c siphash.c</span><br><span class=\"line\">        $(CC) -g -o $@ $^</span><br></pre></td></tr></table></figure>\n<p>但是好像没加之前也是可以直接就使用gdb  了？ 不知道为什么（可以使用但是出错不会显示所在的行，相当于没有调试）</p>\n<p>调试可执行文件:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$gdb &lt;program&gt;</span><br></pre></td></tr></table></figure>\n<p>program也就是你的执行文件，一般在当前目录下。</p>\n<p>调试core文件(core是程序非法执行后core dump后产生的文件):</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$gdb &lt;program&gt; &lt;core dump file&gt;</span><br><span class=\"line\">$gdb program core.11127</span><br></pre></td></tr></table></figure>\n<p>调试服务程序:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$gdb &lt;program&gt; &lt;PID&gt;</span><br><span class=\"line\">$gdb hello 11127</span><br></pre></td></tr></table></figure>\n<p>如果你的程序是一个服务程序，那么你可以指定这个服务程序运行时的进程ID。gdb会自动attach上去，并调试他。program应该在PATH环境变量中搜索得到。</p>\n<h2 id=\"gdb交互命令\"><a href=\"#gdb交互命令\" class=\"headerlink\" title=\"gdb交互命令\"></a>gdb交互命令</h2><p>启动gdb后，进入到交互模式，通过以下命令完成对程序的调试；注意高频使用的命令一般都会有缩写，熟练使用这些缩写命令能提高调试的效率；</p>\n<h3 id=\"运行\"><a href=\"#运行\" class=\"headerlink\" title=\"运行\"></a>运行</h3><ul>\n<li>run：简记为 r ，其作用是运行程序，当遇到断点后，程序会在断点处停止运行，等待用户输入下一步的命令。</li>\n<li>continue （简写c ）：继续执行，到下一个断点处（或运行结束）</li>\n<li>next：（简写 n），单步跟踪程序，当遇到函数调用时，也不进入此函数体；此命令同 step 的主要区别是，step 遇到用户自定义的函数，将步进到函数中去运行，而 next 则直接调用函数，不会进入到函数体内。</li>\n<li>step （简写s）：单步调试如果有函数调用，则进入函数；与命令n不同，n是不进入调用的函数的</li>\n<li>until：当你厌倦了在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体。</li>\n<li>until+行号： 运行至某行，不仅仅用来跳出循环</li>\n<li>finish： 运行程序，直到当前函数完成返回，并打印函数返回时的堆栈地址和返回值及参数值等信息。</li>\n<li>call 函数(参数)：调用程序中可见的函数，并传递“参数”，如：call gdb_test(55)</li>\n<li>quit：简记为 q ，退出gdb</li>\n</ul>\n<h3 id=\"设置断点\"><a href=\"#设置断点\" class=\"headerlink\" title=\"设置断点\"></a>设置断点</h3><ul>\n<li><p>break n （简写b n）:在第n行处设置断点</p>\n<p>（可以带上代码路径和代码名称： b OAGUPDATE.cpp:578）</p>\n</li>\n<li><p>b fn1 if a＞b：条件断点设置</p>\n</li>\n<li><p>break func（break缩写为b）：在函数func()的入口处设置断点，如：break cb_button</p>\n</li>\n<li><p>delete 断点号n：删除第n个断点</p>\n</li>\n<li><p>disable 断点号n：暂停第n个断点</p>\n</li>\n<li><p>enable 断点号n：开启第n个断点</p>\n</li>\n<li><p>clear 行号n：清除第n行的断点</p>\n</li>\n<li><p>info b （info breakpoints） ：显示当前程序的断点设置情况</p>\n</li>\n<li><p>delete breakpoints：清除所有断点：</p>\n</li>\n</ul>\n<h3 id=\"查看源代码\"><a href=\"#查看源代码\" class=\"headerlink\" title=\"查看源代码\"></a>查看源代码</h3><ul>\n<li>list ：简记为 l ，其作用就是列出程序的源代码，默认每次显示10行。</li>\n<li>list 行号：将显示当前文件以“行号”为中心的前后10行代码，如：list 12</li>\n<li>list 函数名：将显示“函数名”所在函数的源代码，如：list main</li>\n<li>list ：不带参数，将接着上一次 list 命令的，输出下边的内容。</li>\n</ul>\n<h3 id=\"打印表达式\"><a href=\"#打印表达式\" class=\"headerlink\" title=\"打印表达式\"></a>打印表达式</h3><ul>\n<li>print 表达式：简记为 p ，其中“表达式”可以是任何当前正在被测试程序的有效表达式，比如当前正在调试C语言的程序，那么“表达式”可以是任何C语言的有效表达式，包括数字，变量甚至是函数调用。</li>\n<li>print a：将显示整数 a 的值</li>\n<li>print ++a：将把 a 中的值加1,并显示出来</li>\n<li>print name：将显示字符串 name 的值</li>\n<li>print gdb_test(22)：将以整数22作为参数调用 gdb_test() 函数</li>\n<li>print gdb_test(a)：将以变量 a 作为参数调用 gdb_test() 函数</li>\n<li>display 表达式：在单步运行时将非常有用，使用display命令设置一个表达式后，它将在每次单步进行指令后，紧接着输出被设置的表达式及值。如： display a</li>\n<li>watch 表达式：设置一个监视点，一旦被监视的“表达式”的值改变，gdb将强行终止正在被调试的程序。如： watch a</li>\n<li>whatis ：查询变量或函数</li>\n<li>info function： 查询函数</li>\n<li>扩展info locals： 显示当前堆栈页的所有变量</li>\n</ul>\n<h3 id=\"查询运行信息\"><a href=\"#查询运行信息\" class=\"headerlink\" title=\"查询运行信息\"></a>查询运行信息</h3><ul>\n<li>where/bt ：当前运行的堆栈列表；</li>\n<li>bt backtrace 显示当前调用堆栈</li>\n<li>up/down 改变堆栈显示的深度</li>\n<li>set args 参数:指定运行时的参数</li>\n<li>show args：查看设置好的参数</li>\n<li>info program： 来查看程序的是否在运行，进程号，被暂停的原因。</li>\n</ul>\n<h3 id=\"分割窗口\"><a href=\"#分割窗口\" class=\"headerlink\" title=\"分割窗口\"></a>分割窗口</h3><ul>\n<li>layout：用于分割窗口，可以一边查看代码，一边测试：</li>\n<li>layout src：显示源代码窗口</li>\n<li>layout asm：显示反汇编窗口</li>\n<li>layout regs：显示源代码/反汇编和CPU寄存器窗口</li>\n<li>layout split：显示源代码和反汇编窗口</li>\n<li>Ctrl + L：刷新窗口</li>\n</ul>\n<h2 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h2><p>调试程序dict-benchmark</p>\n<p>开始调试：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@hw103:/home/yky/test/redis_dict/dict-benchmark# gdb dict-benchmark </span><br><span class=\"line\">GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1</span><br><span class=\"line\">Copyright (C) 2016 Free Software Foundation, Inc.</span><br><span class=\"line\">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class=\"line\">This is free software: you are free to change and redistribute it.</span><br><span class=\"line\">There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;</span><br><span class=\"line\">and &quot;show warranty&quot; for details.</span><br><span class=\"line\">This GDB was configured as &quot;x86_64-linux-gnu&quot;.</span><br><span class=\"line\">Type &quot;show configuration&quot; for configuration details.</span><br><span class=\"line\">For bug reporting instructions, please see:</span><br><span class=\"line\">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class=\"line\">Find the GDB manual and other documentation resources online at:</span><br><span class=\"line\">&lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class=\"line\">For help, type &quot;help&quot;.</span><br><span class=\"line\">Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;...</span><br><span class=\"line\">Reading symbols from dict-benchmark...done.</span><br><span class=\"line\">(gdb)</span><br></pre></td></tr></table></figure>\n<p>使用 r 运行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(gdb) r</span><br><span class=\"line\">Starting program: /home/yky/test/redis_dict/dict-benchmark/dict-benchmark </span><br><span class=\"line\">Add elements to dict</span><br><span class=\"line\">Add ret0 is :0, ht[0].used:1, ht[0].size:4,ht[1].used:0, ht[1].size:0</span><br><span class=\"line\">Add ret1 is :0, ht[0].used:2, ht[0].size:4,ht[1].used:0, ht[1].size:0</span><br><span class=\"line\">Add ret2 is :0, ht[0].used:3, ht[0].size:4,ht[1].used:0, ht[1].size:0</span><br><span class=\"line\"></span><br><span class=\"line\">Program received signal SIGSEGV, Segmentation fault.</span><br><span class=\"line\">0x000000000040288b in _dictKeyIndex (d=0x60a050, key=0x60a011, hash=3050426978, existing=0x0) at dict.c:975</span><br><span class=\"line\">975                 if (key==he-&gt;key || dictCompareKeys(d, key, he-&gt;key)) &#123;</span><br><span class=\"line\">(gdb)</span><br></pre></td></tr></table></figure>\n<p>在_dictKeyIndex ()函数也就是计算索引的时候出错。</p>\n<p>l 列出代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(gdb) l</span><br><span class=\"line\">970         for (table = 0; table &lt;= 1; table++) &#123;</span><br><span class=\"line\">971             idx = hash &amp; d-&gt;ht[table].sizemask;</span><br><span class=\"line\">972             /* Search if this slot does not already contain the given key */</span><br><span class=\"line\">973             he = d-&gt;ht[table].table[idx];</span><br><span class=\"line\">974             while(he) &#123;</span><br><span class=\"line\">975                 if (key==he-&gt;key || dictCompareKeys(d, key, he-&gt;key)) &#123;</span><br><span class=\"line\">976                     if (existing) *existing = he;</span><br><span class=\"line\">977                     return -1;</span><br><span class=\"line\">978                 &#125;</span><br><span class=\"line\">979                 he = he-&gt;next;</span><br></pre></td></tr></table></figure>\n<p>在975行加入断点  b n</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(gdb) b 975</span><br><span class=\"line\">Breakpoint 2 at 0x402887: file dict.c, line 975.</span><br></pre></td></tr></table></figure>\n<p>输出对应变量的值：print</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(gdb) print key </span><br><span class=\"line\">$1 = (const void *) 0x60a011</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html\" target=\"_blank\" rel=\"noopener\">https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html</a></p>\n","site":{"data":{}},"length":4137,"excerpt":"<h1 id=\"gdb调试\"><a href=\"#gdb调试\" class=\"headerlink\" title=\"gdb调试\"></a>gdb调试</h1><p>以前学习过，用得少，又忘记了，现在刚好为了调试redis 的dict 模块，所以再次记录。</p>","more":"<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><p>摘自参考<a href=\"&lt;https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html\">&lt;https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html</a>&gt;。 主要是补充实例</p>\n<p>对C/C++程序的调试，需要在编译前就加上-g选项:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$g++ -g hello.cpp -o hello</span><br></pre></td></tr></table></figure>\n<p>自己的Makefile里面修改成：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dict-benchmark: dict.c sds.c siphash.c</span><br><span class=\"line\">        $(CC) -g -o $@ $^</span><br></pre></td></tr></table></figure>\n<p>但是好像没加之前也是可以直接就使用gdb  了？ 不知道为什么（可以使用但是出错不会显示所在的行，相当于没有调试）</p>\n<p>调试可执行文件:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$gdb &lt;program&gt;</span><br></pre></td></tr></table></figure>\n<p>program也就是你的执行文件，一般在当前目录下。</p>\n<p>调试core文件(core是程序非法执行后core dump后产生的文件):</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$gdb &lt;program&gt; &lt;core dump file&gt;</span><br><span class=\"line\">$gdb program core.11127</span><br></pre></td></tr></table></figure>\n<p>调试服务程序:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$gdb &lt;program&gt; &lt;PID&gt;</span><br><span class=\"line\">$gdb hello 11127</span><br></pre></td></tr></table></figure>\n<p>如果你的程序是一个服务程序，那么你可以指定这个服务程序运行时的进程ID。gdb会自动attach上去，并调试他。program应该在PATH环境变量中搜索得到。</p>\n<h2 id=\"gdb交互命令\"><a href=\"#gdb交互命令\" class=\"headerlink\" title=\"gdb交互命令\"></a>gdb交互命令</h2><p>启动gdb后，进入到交互模式，通过以下命令完成对程序的调试；注意高频使用的命令一般都会有缩写，熟练使用这些缩写命令能提高调试的效率；</p>\n<h3 id=\"运行\"><a href=\"#运行\" class=\"headerlink\" title=\"运行\"></a>运行</h3><ul>\n<li>run：简记为 r ，其作用是运行程序，当遇到断点后，程序会在断点处停止运行，等待用户输入下一步的命令。</li>\n<li>continue （简写c ）：继续执行，到下一个断点处（或运行结束）</li>\n<li>next：（简写 n），单步跟踪程序，当遇到函数调用时，也不进入此函数体；此命令同 step 的主要区别是，step 遇到用户自定义的函数，将步进到函数中去运行，而 next 则直接调用函数，不会进入到函数体内。</li>\n<li>step （简写s）：单步调试如果有函数调用，则进入函数；与命令n不同，n是不进入调用的函数的</li>\n<li>until：当你厌倦了在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体。</li>\n<li>until+行号： 运行至某行，不仅仅用来跳出循环</li>\n<li>finish： 运行程序，直到当前函数完成返回，并打印函数返回时的堆栈地址和返回值及参数值等信息。</li>\n<li>call 函数(参数)：调用程序中可见的函数，并传递“参数”，如：call gdb_test(55)</li>\n<li>quit：简记为 q ，退出gdb</li>\n</ul>\n<h3 id=\"设置断点\"><a href=\"#设置断点\" class=\"headerlink\" title=\"设置断点\"></a>设置断点</h3><ul>\n<li><p>break n （简写b n）:在第n行处设置断点</p>\n<p>（可以带上代码路径和代码名称： b OAGUPDATE.cpp:578）</p>\n</li>\n<li><p>b fn1 if a＞b：条件断点设置</p>\n</li>\n<li><p>break func（break缩写为b）：在函数func()的入口处设置断点，如：break cb_button</p>\n</li>\n<li><p>delete 断点号n：删除第n个断点</p>\n</li>\n<li><p>disable 断点号n：暂停第n个断点</p>\n</li>\n<li><p>enable 断点号n：开启第n个断点</p>\n</li>\n<li><p>clear 行号n：清除第n行的断点</p>\n</li>\n<li><p>info b （info breakpoints） ：显示当前程序的断点设置情况</p>\n</li>\n<li><p>delete breakpoints：清除所有断点：</p>\n</li>\n</ul>\n<h3 id=\"查看源代码\"><a href=\"#查看源代码\" class=\"headerlink\" title=\"查看源代码\"></a>查看源代码</h3><ul>\n<li>list ：简记为 l ，其作用就是列出程序的源代码，默认每次显示10行。</li>\n<li>list 行号：将显示当前文件以“行号”为中心的前后10行代码，如：list 12</li>\n<li>list 函数名：将显示“函数名”所在函数的源代码，如：list main</li>\n<li>list ：不带参数，将接着上一次 list 命令的，输出下边的内容。</li>\n</ul>\n<h3 id=\"打印表达式\"><a href=\"#打印表达式\" class=\"headerlink\" title=\"打印表达式\"></a>打印表达式</h3><ul>\n<li>print 表达式：简记为 p ，其中“表达式”可以是任何当前正在被测试程序的有效表达式，比如当前正在调试C语言的程序，那么“表达式”可以是任何C语言的有效表达式，包括数字，变量甚至是函数调用。</li>\n<li>print a：将显示整数 a 的值</li>\n<li>print ++a：将把 a 中的值加1,并显示出来</li>\n<li>print name：将显示字符串 name 的值</li>\n<li>print gdb_test(22)：将以整数22作为参数调用 gdb_test() 函数</li>\n<li>print gdb_test(a)：将以变量 a 作为参数调用 gdb_test() 函数</li>\n<li>display 表达式：在单步运行时将非常有用，使用display命令设置一个表达式后，它将在每次单步进行指令后，紧接着输出被设置的表达式及值。如： display a</li>\n<li>watch 表达式：设置一个监视点，一旦被监视的“表达式”的值改变，gdb将强行终止正在被调试的程序。如： watch a</li>\n<li>whatis ：查询变量或函数</li>\n<li>info function： 查询函数</li>\n<li>扩展info locals： 显示当前堆栈页的所有变量</li>\n</ul>\n<h3 id=\"查询运行信息\"><a href=\"#查询运行信息\" class=\"headerlink\" title=\"查询运行信息\"></a>查询运行信息</h3><ul>\n<li>where/bt ：当前运行的堆栈列表；</li>\n<li>bt backtrace 显示当前调用堆栈</li>\n<li>up/down 改变堆栈显示的深度</li>\n<li>set args 参数:指定运行时的参数</li>\n<li>show args：查看设置好的参数</li>\n<li>info program： 来查看程序的是否在运行，进程号，被暂停的原因。</li>\n</ul>\n<h3 id=\"分割窗口\"><a href=\"#分割窗口\" class=\"headerlink\" title=\"分割窗口\"></a>分割窗口</h3><ul>\n<li>layout：用于分割窗口，可以一边查看代码，一边测试：</li>\n<li>layout src：显示源代码窗口</li>\n<li>layout asm：显示反汇编窗口</li>\n<li>layout regs：显示源代码/反汇编和CPU寄存器窗口</li>\n<li>layout split：显示源代码和反汇编窗口</li>\n<li>Ctrl + L：刷新窗口</li>\n</ul>\n<h2 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h2><p>调试程序dict-benchmark</p>\n<p>开始调试：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@hw103:/home/yky/test/redis_dict/dict-benchmark# gdb dict-benchmark </span><br><span class=\"line\">GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1</span><br><span class=\"line\">Copyright (C) 2016 Free Software Foundation, Inc.</span><br><span class=\"line\">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class=\"line\">This is free software: you are free to change and redistribute it.</span><br><span class=\"line\">There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;</span><br><span class=\"line\">and &quot;show warranty&quot; for details.</span><br><span class=\"line\">This GDB was configured as &quot;x86_64-linux-gnu&quot;.</span><br><span class=\"line\">Type &quot;show configuration&quot; for configuration details.</span><br><span class=\"line\">For bug reporting instructions, please see:</span><br><span class=\"line\">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class=\"line\">Find the GDB manual and other documentation resources online at:</span><br><span class=\"line\">&lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class=\"line\">For help, type &quot;help&quot;.</span><br><span class=\"line\">Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;...</span><br><span class=\"line\">Reading symbols from dict-benchmark...done.</span><br><span class=\"line\">(gdb)</span><br></pre></td></tr></table></figure>\n<p>使用 r 运行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(gdb) r</span><br><span class=\"line\">Starting program: /home/yky/test/redis_dict/dict-benchmark/dict-benchmark </span><br><span class=\"line\">Add elements to dict</span><br><span class=\"line\">Add ret0 is :0, ht[0].used:1, ht[0].size:4,ht[1].used:0, ht[1].size:0</span><br><span class=\"line\">Add ret1 is :0, ht[0].used:2, ht[0].size:4,ht[1].used:0, ht[1].size:0</span><br><span class=\"line\">Add ret2 is :0, ht[0].used:3, ht[0].size:4,ht[1].used:0, ht[1].size:0</span><br><span class=\"line\"></span><br><span class=\"line\">Program received signal SIGSEGV, Segmentation fault.</span><br><span class=\"line\">0x000000000040288b in _dictKeyIndex (d=0x60a050, key=0x60a011, hash=3050426978, existing=0x0) at dict.c:975</span><br><span class=\"line\">975                 if (key==he-&gt;key || dictCompareKeys(d, key, he-&gt;key)) &#123;</span><br><span class=\"line\">(gdb)</span><br></pre></td></tr></table></figure>\n<p>在_dictKeyIndex ()函数也就是计算索引的时候出错。</p>\n<p>l 列出代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(gdb) l</span><br><span class=\"line\">970         for (table = 0; table &lt;= 1; table++) &#123;</span><br><span class=\"line\">971             idx = hash &amp; d-&gt;ht[table].sizemask;</span><br><span class=\"line\">972             /* Search if this slot does not already contain the given key */</span><br><span class=\"line\">973             he = d-&gt;ht[table].table[idx];</span><br><span class=\"line\">974             while(he) &#123;</span><br><span class=\"line\">975                 if (key==he-&gt;key || dictCompareKeys(d, key, he-&gt;key)) &#123;</span><br><span class=\"line\">976                     if (existing) *existing = he;</span><br><span class=\"line\">977                     return -1;</span><br><span class=\"line\">978                 &#125;</span><br><span class=\"line\">979                 he = he-&gt;next;</span><br></pre></td></tr></table></figure>\n<p>在975行加入断点  b n</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(gdb) b 975</span><br><span class=\"line\">Breakpoint 2 at 0x402887: file dict.c, line 975.</span><br></pre></td></tr></table></figure>\n<p>输出对应变量的值：print</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(gdb) print key </span><br><span class=\"line\">$1 = (const void *) 0x60a011</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html\" target=\"_blank\" rel=\"noopener\">https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html</a></p>"},{"title":"Docker 学习","date":"2019-04-01T06:18:41.000Z","copyright":true,"_content":"\n# Docker 学习\n\n之前一直听说容器可以免去配置环境的麻烦，但是一直没有机会接触，现在刚好有机会可以使用。\n\n<!--more-->\n\n## 三大基础\n\n镜像、容器、仓库\n\n类比的话：镜像是类（iso），容器是实例（操作系统），仓库类似于git的仓库。\n\n镜像的构建是一层层的继承而来的，镜像和容器都是文件，容器退出的时候容器文件依然存在。除非手动使用-rm指定，才会删除。\n\n## 命令\n\n加载镜像，进入一个新的容器：`docker run image:tag command`\n\n实例 摘自：<https://yeasy.gitbooks.io/docker_practice/image/pull.html>\n\n```bash\ndocker run -it --rm \\\n    ubuntu:18.04 \\\n    bash\n```\n\n`docker run` 就是运行容器的命令 从镜像中新建一个容器\n\n- `-it`：这是两个参数，一个是 `-i`：交互式操作，一个是 `-t` 终端。我们这里打算进入 `bash` 执行一些命令并查看返回结果，因此我们需要交互式终端。\n- `--rm`：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 `docker rm`。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 `--rm` 可以避免浪费空间。\n- `ubuntu:18.04`：这是指用 `ubuntu:18.04` 镜像为基础来启动容器。\n- `bash`：放在镜像名后的是**命令**，这里我们希望有个交互式 Shell，因此用的是 `bash`。\n\n退出: 在容器中`exit`\n\n进入容器：\n\n`docker exec`  进入一个已有的容器。 （容器需要已经运行）\n\n`dcoker cp  `  容器的复制\n\n`docker ps ` 列出启动容器 `docker ps -a ` 列出所有容器包括关闭的。\n\n启动之前关闭的容器： `docker start container-name ` ， \n\n需要先启动容器，才能执行`docker exec  container-name`\n\n## 端口映射\n\n<https://blog.csdn.net/wanglei_storage/article/details/48471753>\n\n## 参考\n\n<https://juejin.im/entry/5b19e350e51d45069f5e1d66>\n\n<https://yeasy.gitbooks.io/docker_practice/basic_concept/container.html>\n\n<https://blog.csdn.net/u010246789/article/details/53958662>","source":"_posts/2019-04-01-Docker-学习.md","raw":"---\ntitle: Docker 学习\ndate: 2019-04-01 14:18:41\ncategories: Linux\ntags:\n- docker\n- 容器\ncopyright: true\n---\n\n# Docker 学习\n\n之前一直听说容器可以免去配置环境的麻烦，但是一直没有机会接触，现在刚好有机会可以使用。\n\n<!--more-->\n\n## 三大基础\n\n镜像、容器、仓库\n\n类比的话：镜像是类（iso），容器是实例（操作系统），仓库类似于git的仓库。\n\n镜像的构建是一层层的继承而来的，镜像和容器都是文件，容器退出的时候容器文件依然存在。除非手动使用-rm指定，才会删除。\n\n## 命令\n\n加载镜像，进入一个新的容器：`docker run image:tag command`\n\n实例 摘自：<https://yeasy.gitbooks.io/docker_practice/image/pull.html>\n\n```bash\ndocker run -it --rm \\\n    ubuntu:18.04 \\\n    bash\n```\n\n`docker run` 就是运行容器的命令 从镜像中新建一个容器\n\n- `-it`：这是两个参数，一个是 `-i`：交互式操作，一个是 `-t` 终端。我们这里打算进入 `bash` 执行一些命令并查看返回结果，因此我们需要交互式终端。\n- `--rm`：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 `docker rm`。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 `--rm` 可以避免浪费空间。\n- `ubuntu:18.04`：这是指用 `ubuntu:18.04` 镜像为基础来启动容器。\n- `bash`：放在镜像名后的是**命令**，这里我们希望有个交互式 Shell，因此用的是 `bash`。\n\n退出: 在容器中`exit`\n\n进入容器：\n\n`docker exec`  进入一个已有的容器。 （容器需要已经运行）\n\n`dcoker cp  `  容器的复制\n\n`docker ps ` 列出启动容器 `docker ps -a ` 列出所有容器包括关闭的。\n\n启动之前关闭的容器： `docker start container-name ` ， \n\n需要先启动容器，才能执行`docker exec  container-name`\n\n## 端口映射\n\n<https://blog.csdn.net/wanglei_storage/article/details/48471753>\n\n## 参考\n\n<https://juejin.im/entry/5b19e350e51d45069f5e1d66>\n\n<https://yeasy.gitbooks.io/docker_practice/basic_concept/container.html>\n\n<https://blog.csdn.net/u010246789/article/details/53958662>","slug":"2019-04-01-Docker-学习","published":1,"updated":"2019-11-08T13:13:52.912Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2yelxh6000gm8tz0c5z2c5p","content":"<h1 id=\"Docker-学习\"><a href=\"#Docker-学习\" class=\"headerlink\" title=\"Docker 学习\"></a>Docker 学习</h1><p>之前一直听说容器可以免去配置环境的麻烦，但是一直没有机会接触，现在刚好有机会可以使用。</p>\n<a id=\"more\"></a>\n<h2 id=\"三大基础\"><a href=\"#三大基础\" class=\"headerlink\" title=\"三大基础\"></a>三大基础</h2><p>镜像、容器、仓库</p>\n<p>类比的话：镜像是类（iso），容器是实例（操作系统），仓库类似于git的仓库。</p>\n<p>镜像的构建是一层层的继承而来的，镜像和容器都是文件，容器退出的时候容器文件依然存在。除非手动使用-rm指定，才会删除。</p>\n<h2 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h2><p>加载镜像，进入一个新的容器：<code>docker run image:tag command</code></p>\n<p>实例 摘自：<a href=\"https://yeasy.gitbooks.io/docker_practice/image/pull.html\" target=\"_blank\" rel=\"noopener\">https://yeasy.gitbooks.io/docker_practice/image/pull.html</a></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -it --rm \\</span><br><span class=\"line\">    ubuntu:18.04 \\</span><br><span class=\"line\">    bash</span><br></pre></td></tr></table></figure>\n<p><code>docker run</code> 就是运行容器的命令 从镜像中新建一个容器</p>\n<ul>\n<li><code>-it</code>：这是两个参数，一个是 <code>-i</code>：交互式操作，一个是 <code>-t</code> 终端。我们这里打算进入 <code>bash</code> 执行一些命令并查看返回结果，因此我们需要交互式终端。</li>\n<li><code>--rm</code>：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 <code>docker rm</code>。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 <code>--rm</code> 可以避免浪费空间。</li>\n<li><code>ubuntu:18.04</code>：这是指用 <code>ubuntu:18.04</code> 镜像为基础来启动容器。</li>\n<li><code>bash</code>：放在镜像名后的是<strong>命令</strong>，这里我们希望有个交互式 Shell，因此用的是 <code>bash</code>。</li>\n</ul>\n<p>退出: 在容器中<code>exit</code></p>\n<p>进入容器：</p>\n<p><code>docker exec</code>  进入一个已有的容器。 （容器需要已经运行）</p>\n<p><code>dcoker cp</code>  容器的复制</p>\n<p><code>docker ps</code> 列出启动容器 <code>docker ps -a</code> 列出所有容器包括关闭的。</p>\n<p>启动之前关闭的容器： <code>docker start container-name</code> ， </p>\n<p>需要先启动容器，才能执行<code>docker exec  container-name</code></p>\n<h2 id=\"端口映射\"><a href=\"#端口映射\" class=\"headerlink\" title=\"端口映射\"></a>端口映射</h2><p><a href=\"https://blog.csdn.net/wanglei_storage/article/details/48471753\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/wanglei_storage/article/details/48471753</a></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://juejin.im/entry/5b19e350e51d45069f5e1d66\" target=\"_blank\" rel=\"noopener\">https://juejin.im/entry/5b19e350e51d45069f5e1d66</a></p>\n<p><a href=\"https://yeasy.gitbooks.io/docker_practice/basic_concept/container.html\" target=\"_blank\" rel=\"noopener\">https://yeasy.gitbooks.io/docker_practice/basic_concept/container.html</a></p>\n<p><a href=\"https://blog.csdn.net/u010246789/article/details/53958662\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/u010246789/article/details/53958662</a></p>\n","site":{"data":{}},"length":1000,"excerpt":"<h1 id=\"Docker-学习\"><a href=\"#Docker-学习\" class=\"headerlink\" title=\"Docker 学习\"></a>Docker 学习</h1><p>之前一直听说容器可以免去配置环境的麻烦，但是一直没有机会接触，现在刚好有机会可以使用。</p>","more":"<h2 id=\"三大基础\"><a href=\"#三大基础\" class=\"headerlink\" title=\"三大基础\"></a>三大基础</h2><p>镜像、容器、仓库</p>\n<p>类比的话：镜像是类（iso），容器是实例（操作系统），仓库类似于git的仓库。</p>\n<p>镜像的构建是一层层的继承而来的，镜像和容器都是文件，容器退出的时候容器文件依然存在。除非手动使用-rm指定，才会删除。</p>\n<h2 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h2><p>加载镜像，进入一个新的容器：<code>docker run image:tag command</code></p>\n<p>实例 摘自：<a href=\"https://yeasy.gitbooks.io/docker_practice/image/pull.html\" target=\"_blank\" rel=\"noopener\">https://yeasy.gitbooks.io/docker_practice/image/pull.html</a></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -it --rm \\</span><br><span class=\"line\">    ubuntu:18.04 \\</span><br><span class=\"line\">    bash</span><br></pre></td></tr></table></figure>\n<p><code>docker run</code> 就是运行容器的命令 从镜像中新建一个容器</p>\n<ul>\n<li><code>-it</code>：这是两个参数，一个是 <code>-i</code>：交互式操作，一个是 <code>-t</code> 终端。我们这里打算进入 <code>bash</code> 执行一些命令并查看返回结果，因此我们需要交互式终端。</li>\n<li><code>--rm</code>：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 <code>docker rm</code>。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 <code>--rm</code> 可以避免浪费空间。</li>\n<li><code>ubuntu:18.04</code>：这是指用 <code>ubuntu:18.04</code> 镜像为基础来启动容器。</li>\n<li><code>bash</code>：放在镜像名后的是<strong>命令</strong>，这里我们希望有个交互式 Shell，因此用的是 <code>bash</code>。</li>\n</ul>\n<p>退出: 在容器中<code>exit</code></p>\n<p>进入容器：</p>\n<p><code>docker exec</code>  进入一个已有的容器。 （容器需要已经运行）</p>\n<p><code>dcoker cp</code>  容器的复制</p>\n<p><code>docker ps</code> 列出启动容器 <code>docker ps -a</code> 列出所有容器包括关闭的。</p>\n<p>启动之前关闭的容器： <code>docker start container-name</code> ， </p>\n<p>需要先启动容器，才能执行<code>docker exec  container-name</code></p>\n<h2 id=\"端口映射\"><a href=\"#端口映射\" class=\"headerlink\" title=\"端口映射\"></a>端口映射</h2><p><a href=\"https://blog.csdn.net/wanglei_storage/article/details/48471753\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/wanglei_storage/article/details/48471753</a></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://juejin.im/entry/5b19e350e51d45069f5e1d66\" target=\"_blank\" rel=\"noopener\">https://juejin.im/entry/5b19e350e51d45069f5e1d66</a></p>\n<p><a href=\"https://yeasy.gitbooks.io/docker_practice/basic_concept/container.html\" target=\"_blank\" rel=\"noopener\">https://yeasy.gitbooks.io/docker_practice/basic_concept/container.html</a></p>\n<p><a href=\"https://blog.csdn.net/u010246789/article/details/53958662\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/u010246789/article/details/53958662</a></p>"},{"title":"Linux shell脚本计算运行时间","date":"2019-04-10T15:27:45.000Z","copyright":true,"_content":"\n# Linux shell脚本计算运行时间\n\n这个功能经常用但是，总是现用现查，很麻烦。\n\n<!--more-->\n\n代码\n\n```bash\n# filename: msec_diff.sh\n\nfunction timediff() {\n\n# time format:date +\"%s.%N\", such as 1502758855.907197692\n    start_time=$1\n    end_time=$2\n    \n    start_s=${start_time%.*}\n    start_nanos=${start_time#*.}\n    end_s=${end_time%.*}\n    end_nanos=${end_time#*.}\n    \n    # end_nanos > start_nanos? \n    # Another way, the time part may start with 0, which means\n    # it will be regarded as oct format, use \"10#\" to ensure\n    # calculateing with decimal\n    if [ \"$end_nanos\" -lt \"$start_nanos\" ];then\n        end_s=$(( 10#$end_s - 1 ))\n        end_nanos=$(( 10#$end_nanos + 10**9 ))\n    fi\n    \n# get timediff\n    time=$(( 10#$end_s - 10#$start_s )).`printf \"%03d\\n\" $(( (10#$end_nanos - 10#$start_nanos)/10**6 ))`\n    \n    echo $time\n}\n\n#start=$(date +\"%s.%N\")\n# Now exec some command\n#end=$(date +\"%s.%N\")\n# here give the values\nstart=1502758855.907197692\nend=1502758865.066894173\n\ntimediff $start $end\n```\n\n## 参考\n\n<https://www.cnblogs.com/f-ck-need-u/p/7426987.html>","source":"_posts/2019-04-10-Linux-shell脚本计算运行时间.md","raw":"---\ntitle: Linux shell脚本计算运行时间\ndate: 2019-04-10 23:27:45\ncategories: Linux\ntags: shell\ncopyright: true\n---\n\n# Linux shell脚本计算运行时间\n\n这个功能经常用但是，总是现用现查，很麻烦。\n\n<!--more-->\n\n代码\n\n```bash\n# filename: msec_diff.sh\n\nfunction timediff() {\n\n# time format:date +\"%s.%N\", such as 1502758855.907197692\n    start_time=$1\n    end_time=$2\n    \n    start_s=${start_time%.*}\n    start_nanos=${start_time#*.}\n    end_s=${end_time%.*}\n    end_nanos=${end_time#*.}\n    \n    # end_nanos > start_nanos? \n    # Another way, the time part may start with 0, which means\n    # it will be regarded as oct format, use \"10#\" to ensure\n    # calculateing with decimal\n    if [ \"$end_nanos\" -lt \"$start_nanos\" ];then\n        end_s=$(( 10#$end_s - 1 ))\n        end_nanos=$(( 10#$end_nanos + 10**9 ))\n    fi\n    \n# get timediff\n    time=$(( 10#$end_s - 10#$start_s )).`printf \"%03d\\n\" $(( (10#$end_nanos - 10#$start_nanos)/10**6 ))`\n    \n    echo $time\n}\n\n#start=$(date +\"%s.%N\")\n# Now exec some command\n#end=$(date +\"%s.%N\")\n# here give the values\nstart=1502758855.907197692\nend=1502758865.066894173\n\ntimediff $start $end\n```\n\n## 参考\n\n<https://www.cnblogs.com/f-ck-need-u/p/7426987.html>","slug":"2019-04-10-Linux-shell脚本计算运行时间","published":1,"updated":"2019-11-08T13:14:02.619Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2yelxh9000im8tz8enkbqqv","content":"<h1 id=\"Linux-shell脚本计算运行时间\"><a href=\"#Linux-shell脚本计算运行时间\" class=\"headerlink\" title=\"Linux shell脚本计算运行时间\"></a>Linux shell脚本计算运行时间</h1><p>这个功能经常用但是，总是现用现查，很麻烦。</p>\n<a id=\"more\"></a>\n<p>代码</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># filename: msec_diff.sh</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">timediff</span></span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># time format:date +\"%s.%N\", such as 1502758855.907197692</span></span><br><span class=\"line\">    start_time=<span class=\"variable\">$1</span></span><br><span class=\"line\">    end_time=<span class=\"variable\">$2</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    start_s=<span class=\"variable\">$&#123;start_time%.*&#125;</span></span><br><span class=\"line\">    start_nanos=<span class=\"variable\">$&#123;start_time#*.&#125;</span></span><br><span class=\"line\">    end_s=<span class=\"variable\">$&#123;end_time%.*&#125;</span></span><br><span class=\"line\">    end_nanos=<span class=\"variable\">$&#123;end_time#*.&#125;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># end_nanos &gt; start_nanos? </span></span><br><span class=\"line\">    <span class=\"comment\"># Another way, the time part may start with 0, which means</span></span><br><span class=\"line\">    <span class=\"comment\"># it will be regarded as oct format, use \"10#\" to ensure</span></span><br><span class=\"line\">    <span class=\"comment\"># calculateing with decimal</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> [ <span class=\"string\">\"<span class=\"variable\">$end_nanos</span>\"</span> -lt <span class=\"string\">\"<span class=\"variable\">$start_nanos</span>\"</span> ];<span class=\"keyword\">then</span></span><br><span class=\"line\">        end_s=$(( 10<span class=\"comment\">#$end_s - 1 ))</span></span><br><span class=\"line\">        end_nanos=$(( 10<span class=\"comment\">#$end_nanos + 10**9 ))</span></span><br><span class=\"line\">    <span class=\"keyword\">fi</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\"># get timediff</span></span><br><span class=\"line\">    time=$(( 10<span class=\"comment\">#$end_s - 10#$start_s )).`printf \"%03d\\n\" $(( (10#$end_nanos - 10#$start_nanos)/10**6 ))`</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"variable\">$time</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#start=$(date +\"%s.%N\")</span></span><br><span class=\"line\"><span class=\"comment\"># Now exec some command</span></span><br><span class=\"line\"><span class=\"comment\">#end=$(date +\"%s.%N\")</span></span><br><span class=\"line\"><span class=\"comment\"># here give the values</span></span><br><span class=\"line\">start=1502758855.907197692</span><br><span class=\"line\">end=1502758865.066894173</span><br><span class=\"line\"></span><br><span class=\"line\">timediff <span class=\"variable\">$start</span> <span class=\"variable\">$end</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://www.cnblogs.com/f-ck-need-u/p/7426987.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/f-ck-need-u/p/7426987.html</a></p>\n","site":{"data":{}},"length":915,"excerpt":"<h1 id=\"Linux-shell脚本计算运行时间\"><a href=\"#Linux-shell脚本计算运行时间\" class=\"headerlink\" title=\"Linux shell脚本计算运行时间\"></a>Linux shell脚本计算运行时间</h1><p>这个功能经常用但是，总是现用现查，很麻烦。</p>","more":"<p>代码</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># filename: msec_diff.sh</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">timediff</span></span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># time format:date +\"%s.%N\", such as 1502758855.907197692</span></span><br><span class=\"line\">    start_time=<span class=\"variable\">$1</span></span><br><span class=\"line\">    end_time=<span class=\"variable\">$2</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    start_s=<span class=\"variable\">$&#123;start_time%.*&#125;</span></span><br><span class=\"line\">    start_nanos=<span class=\"variable\">$&#123;start_time#*.&#125;</span></span><br><span class=\"line\">    end_s=<span class=\"variable\">$&#123;end_time%.*&#125;</span></span><br><span class=\"line\">    end_nanos=<span class=\"variable\">$&#123;end_time#*.&#125;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># end_nanos &gt; start_nanos? </span></span><br><span class=\"line\">    <span class=\"comment\"># Another way, the time part may start with 0, which means</span></span><br><span class=\"line\">    <span class=\"comment\"># it will be regarded as oct format, use \"10#\" to ensure</span></span><br><span class=\"line\">    <span class=\"comment\"># calculateing with decimal</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> [ <span class=\"string\">\"<span class=\"variable\">$end_nanos</span>\"</span> -lt <span class=\"string\">\"<span class=\"variable\">$start_nanos</span>\"</span> ];<span class=\"keyword\">then</span></span><br><span class=\"line\">        end_s=$(( 10<span class=\"comment\">#$end_s - 1 ))</span></span><br><span class=\"line\">        end_nanos=$(( 10<span class=\"comment\">#$end_nanos + 10**9 ))</span></span><br><span class=\"line\">    <span class=\"keyword\">fi</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\"># get timediff</span></span><br><span class=\"line\">    time=$(( 10<span class=\"comment\">#$end_s - 10#$start_s )).`printf \"%03d\\n\" $(( (10#$end_nanos - 10#$start_nanos)/10**6 ))`</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"variable\">$time</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#start=$(date +\"%s.%N\")</span></span><br><span class=\"line\"><span class=\"comment\"># Now exec some command</span></span><br><span class=\"line\"><span class=\"comment\">#end=$(date +\"%s.%N\")</span></span><br><span class=\"line\"><span class=\"comment\"># here give the values</span></span><br><span class=\"line\">start=1502758855.907197692</span><br><span class=\"line\">end=1502758865.066894173</span><br><span class=\"line\"></span><br><span class=\"line\">timediff <span class=\"variable\">$start</span> <span class=\"variable\">$end</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://www.cnblogs.com/f-ck-need-u/p/7426987.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/f-ck-need-u/p/7426987.html</a></p>"},{"title":"青蛙跳台阶问题","date":"2019-04-17T14:02:40.000Z","copyright":true,"_content":"\n# 青蛙跳台阶问题\n\n一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。 公式不能在hexo上显示出来\n\n<!--more-->\n\n题目来源：\n\n<https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4?tpId=13&tqId=11161&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking>\n\n解题思路：函数思想，把n阶台阶的调法看成是关于n的函数 f(n)。当n>2的时候：\n\n假设第一次跳一个台阶，那么还剩n-1个台阶需要跳，也就是还有f(n-1)的跳法。\n\n假设第一次跳两个台阶，那么还剩n-2个台阶需要跳，也就是还有f(n-2)的跳法\n\n所以n阶的跳法总共有f(n-1) + f(n-2)  种，也就是 f(n) = f(n-1) +f(n-2)。\n\n所以函数就是 ：\n$$\nf(n)=\n\\begin{cases}\n0& \\text{n=0}\\\\\n1& \\text{n=1}\\\\\n2& \\text {n=2}\\\\\nf(n-1)+f(n-2)& \\text {n>2}\n\\end{cases}\n$$\n也就是一个斐波那契数列，代码也就比较简单了。参考斐波那契数列的解法:\n\n<https://github.com/BraveY/Coding/blob/master/%E5%89%91%E6%8C%87offer/Fibonacci.cc>\n\n代码为：\n\n```cc\n\nclass Solution {\npublic:\n    int jumpFloor(int number) {\n        int result[3] = {0,1,2};\n        if(number<3) return result[number];\n        int fib_one = result[1];\n        int fib_two = result[2];\n        int fib;\n        for(int i=3; i<=number; i++){\n            fib = fib_one + fib_two;\n            fib_one = fib_two;\n            fib_two = fib;\n        }\n        return fib;\n    }\n};\n```\n\n## 变种题目：\n\n一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。\n\n思路也是一样的：第一次跳1级台阶，则有f(n-1)的解法，第一次跳2级台阶，则有f(n-2)的解法，第一次跳n-1级台阶，则有f(2)的解法， 第一次跳n级台阶则还有一种解法。用f(0)表示第一次跳n级的情况,f(0)=1。\n\n归纳成函数就是：\n$$\nf(n)=\n\\begin{cases}\n1& \\text{n=0}\\\\\n1& \\text{n=1}\\\\\nf(n-1)+f(n-2)...+f(1)+f(0)& \\text {n>1}\n\\end{cases}\n$$\n所以代码为：\n\n```cc\nclass Solution {\npublic:\n    int jumpFloorII(int number) {\n        vector<int> result;\n        result.push_back(1); // f(0) =1 ;\n        for(int i=1; i<=number; i++){\n            int sum = 0;\n            for(int j=0; j<i; j++){ // f(n)=f(n-1)+f(n-2)+...f(1)+f(0)\n                sum += result[j];\n            }\n            result.push_back(sum);\n        }\n        return result[number];\n    }\n};\n```\n\n另一个斐波那契数列数列问题：\n\n## 矩形覆盖\n\n<https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&tqId=11163&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking>\n\n我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？\n\n最开始的时候没有想清楚，以为不是斐波那契数列。\n\n思路：\n\n同样的方法为n的函数：f(n); 对于n=1的情况，只能竖着放：所以f(1)=1; n=2的时候，竖着放之后就变成了f(1)种方法，横着放的时候只有一种，总共有两种，所以f(2)=2;\n\n所以函数为：\n$$\nf(n)=\n\\begin{cases}\n0& \\text{n=0}\\\\\n1& \\text{n=1}\\\\\n2& \\text {n=2}\\\\\nf(n-1)+f(n-2)& \\text {n>2}\n\\end{cases}\n$$\n因此代码也是同第一个青蛙跳台阶一样的。\n\n代码：\n\n```cc\n//https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&tqId=11163&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking\nclass Solution {\npublic:\n    int rectCover(int number) {\n        int result[3] = {0,1,2};\n        if(number<3) return result[number];\n        int fib_one = result[1];\n        int fib_two = result[2];\n        int fib;\n        for(int i=3; i<=number; i++){\n            fib = fib_one + fib_two;\n            fib_one = fib_two;\n            fib_two = fib;\n        }\n       return fib;\n    }\n};\n```\n\n## 总结\n\n总结一下，对于斐波那契数列问题思路都是一样：\n\n- 输出是输入的函数， f(n)\n- 考虑第一次是如何选择的，就可以把问题给切分出来了。","source":"_posts/2019-04-17-青蛙跳台阶问题.md","raw":"---\ntitle: 青蛙跳台阶问题\ndate: 2019-04-17 22:02:40\ncategories: 题解\ntags:\n- 牛客\n- 斐波拉契数列\n- 剑指offer\ncopyright: true\n---\n\n# 青蛙跳台阶问题\n\n一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。 公式不能在hexo上显示出来\n\n<!--more-->\n\n题目来源：\n\n<https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4?tpId=13&tqId=11161&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking>\n\n解题思路：函数思想，把n阶台阶的调法看成是关于n的函数 f(n)。当n>2的时候：\n\n假设第一次跳一个台阶，那么还剩n-1个台阶需要跳，也就是还有f(n-1)的跳法。\n\n假设第一次跳两个台阶，那么还剩n-2个台阶需要跳，也就是还有f(n-2)的跳法\n\n所以n阶的跳法总共有f(n-1) + f(n-2)  种，也就是 f(n) = f(n-1) +f(n-2)。\n\n所以函数就是 ：\n$$\nf(n)=\n\\begin{cases}\n0& \\text{n=0}\\\\\n1& \\text{n=1}\\\\\n2& \\text {n=2}\\\\\nf(n-1)+f(n-2)& \\text {n>2}\n\\end{cases}\n$$\n也就是一个斐波那契数列，代码也就比较简单了。参考斐波那契数列的解法:\n\n<https://github.com/BraveY/Coding/blob/master/%E5%89%91%E6%8C%87offer/Fibonacci.cc>\n\n代码为：\n\n```cc\n\nclass Solution {\npublic:\n    int jumpFloor(int number) {\n        int result[3] = {0,1,2};\n        if(number<3) return result[number];\n        int fib_one = result[1];\n        int fib_two = result[2];\n        int fib;\n        for(int i=3; i<=number; i++){\n            fib = fib_one + fib_two;\n            fib_one = fib_two;\n            fib_two = fib;\n        }\n        return fib;\n    }\n};\n```\n\n## 变种题目：\n\n一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。\n\n思路也是一样的：第一次跳1级台阶，则有f(n-1)的解法，第一次跳2级台阶，则有f(n-2)的解法，第一次跳n-1级台阶，则有f(2)的解法， 第一次跳n级台阶则还有一种解法。用f(0)表示第一次跳n级的情况,f(0)=1。\n\n归纳成函数就是：\n$$\nf(n)=\n\\begin{cases}\n1& \\text{n=0}\\\\\n1& \\text{n=1}\\\\\nf(n-1)+f(n-2)...+f(1)+f(0)& \\text {n>1}\n\\end{cases}\n$$\n所以代码为：\n\n```cc\nclass Solution {\npublic:\n    int jumpFloorII(int number) {\n        vector<int> result;\n        result.push_back(1); // f(0) =1 ;\n        for(int i=1; i<=number; i++){\n            int sum = 0;\n            for(int j=0; j<i; j++){ // f(n)=f(n-1)+f(n-2)+...f(1)+f(0)\n                sum += result[j];\n            }\n            result.push_back(sum);\n        }\n        return result[number];\n    }\n};\n```\n\n另一个斐波那契数列数列问题：\n\n## 矩形覆盖\n\n<https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&tqId=11163&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking>\n\n我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？\n\n最开始的时候没有想清楚，以为不是斐波那契数列。\n\n思路：\n\n同样的方法为n的函数：f(n); 对于n=1的情况，只能竖着放：所以f(1)=1; n=2的时候，竖着放之后就变成了f(1)种方法，横着放的时候只有一种，总共有两种，所以f(2)=2;\n\n所以函数为：\n$$\nf(n)=\n\\begin{cases}\n0& \\text{n=0}\\\\\n1& \\text{n=1}\\\\\n2& \\text {n=2}\\\\\nf(n-1)+f(n-2)& \\text {n>2}\n\\end{cases}\n$$\n因此代码也是同第一个青蛙跳台阶一样的。\n\n代码：\n\n```cc\n//https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&tqId=11163&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking\nclass Solution {\npublic:\n    int rectCover(int number) {\n        int result[3] = {0,1,2};\n        if(number<3) return result[number];\n        int fib_one = result[1];\n        int fib_two = result[2];\n        int fib;\n        for(int i=3; i<=number; i++){\n            fib = fib_one + fib_two;\n            fib_one = fib_two;\n            fib_two = fib;\n        }\n       return fib;\n    }\n};\n```\n\n## 总结\n\n总结一下，对于斐波那契数列问题思路都是一样：\n\n- 输出是输入的函数， f(n)\n- 考虑第一次是如何选择的，就可以把问题给切分出来了。","slug":"2019-04-17-青蛙跳台阶问题","published":1,"updated":"2019-11-11T03:50:55.312Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2yelxhb000nm8tz2poqxrdh","content":"<h1 id=\"青蛙跳台阶问题\"><a href=\"#青蛙跳台阶问题\" class=\"headerlink\" title=\"青蛙跳台阶问题\"></a>青蛙跳台阶问题</h1><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。 公式不能在hexo上显示出来</p>\n<a id=\"more\"></a>\n<p>题目来源：</p>\n<p><a href=\"https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4?tpId=13&amp;tqId=11161&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking\" target=\"_blank\" rel=\"noopener\">https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4?tpId=13&amp;tqId=11161&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a></p>\n<p>解题思路：函数思想，把n阶台阶的调法看成是关于n的函数 f(n)。当n&gt;2的时候：</p>\n<p>假设第一次跳一个台阶，那么还剩n-1个台阶需要跳，也就是还有f(n-1)的跳法。</p>\n<p>假设第一次跳两个台阶，那么还剩n-2个台阶需要跳，也就是还有f(n-2)的跳法</p>\n<p>所以n阶的跳法总共有f(n-1) + f(n-2)  种，也就是 f(n) = f(n-1) +f(n-2)。</p>\n<p>所以函数就是 ：</p>\n<script type=\"math/tex; mode=display\">\nf(n)=\n\\begin{cases}\n0& \\text{n=0}\\\\\n1& \\text{n=1}\\\\\n2& \\text {n=2}\\\\\nf(n-1)+f(n-2)& \\text {n>2}\n\\end{cases}</script><p>也就是一个斐波那契数列，代码也就比较简单了。参考斐波那契数列的解法:</p>\n<p><a href=\"https://github.com/BraveY/Coding/blob/master/%E5%89%91%E6%8C%87offer/Fibonacci.cc\" target=\"_blank\" rel=\"noopener\">https://github.com/BraveY/Coding/blob/master/%E5%89%91%E6%8C%87offer/Fibonacci.cc</a></p>\n<p>代码为：</p>\n<figure class=\"highlight cc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">jumpFloor</span><span class=\"params\">(<span class=\"keyword\">int</span> number)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> result[<span class=\"number\">3</span>] = &#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(number&lt;<span class=\"number\">3</span>) <span class=\"keyword\">return</span> result[number];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> fib_one = result[<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> fib_two = result[<span class=\"number\">2</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> fib;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">3</span>; i&lt;=number; i++)&#123;</span><br><span class=\"line\">            fib = fib_one + fib_two;</span><br><span class=\"line\">            fib_one = fib_two;</span><br><span class=\"line\">            fib_two = fib;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fib;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"变种题目：\"><a href=\"#变种题目：\" class=\"headerlink\" title=\"变种题目：\"></a>变种题目：</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>\n<p>思路也是一样的：第一次跳1级台阶，则有f(n-1)的解法，第一次跳2级台阶，则有f(n-2)的解法，第一次跳n-1级台阶，则有f(2)的解法， 第一次跳n级台阶则还有一种解法。用f(0)表示第一次跳n级的情况,f(0)=1。</p>\n<p>归纳成函数就是：</p>\n<script type=\"math/tex; mode=display\">\nf(n)=\n\\begin{cases}\n1& \\text{n=0}\\\\\n1& \\text{n=1}\\\\\nf(n-1)+f(n-2)...+f(1)+f(0)& \\text {n>1}\n\\end{cases}</script><p>所以代码为：</p>\n<figure class=\"highlight cc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">jumpFloorII</span><span class=\"params\">(<span class=\"keyword\">int</span> number)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; result;</span><br><span class=\"line\">        result.push_back(<span class=\"number\">1</span>); <span class=\"comment\">// f(0) =1 ;</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>; i&lt;=number; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>; j&lt;i; j++)&#123; <span class=\"comment\">// f(n)=f(n-1)+f(n-2)+...f(1)+f(0)</span></span><br><span class=\"line\">                sum += result[j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            result.push_back(sum);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result[number];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>另一个斐波那契数列数列问题：</p>\n<h2 id=\"矩形覆盖\"><a href=\"#矩形覆盖\" class=\"headerlink\" title=\"矩形覆盖\"></a>矩形覆盖</h2><p><a href=\"https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&amp;tqId=11163&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking\" target=\"_blank\" rel=\"noopener\">https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&amp;tqId=11163&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a></p>\n<p>我们可以用2<em>1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2</em>1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p>\n<p>最开始的时候没有想清楚，以为不是斐波那契数列。</p>\n<p>思路：</p>\n<p>同样的方法为n的函数：f(n); 对于n=1的情况，只能竖着放：所以f(1)=1; n=2的时候，竖着放之后就变成了f(1)种方法，横着放的时候只有一种，总共有两种，所以f(2)=2;</p>\n<p>所以函数为：</p>\n<script type=\"math/tex; mode=display\">\nf(n)=\n\\begin{cases}\n0& \\text{n=0}\\\\\n1& \\text{n=1}\\\\\n2& \\text {n=2}\\\\\nf(n-1)+f(n-2)& \\text {n>2}\n\\end{cases}</script><p>因此代码也是同第一个青蛙跳台阶一样的。</p>\n<p>代码：</p>\n<figure class=\"highlight cc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&amp;tqId=11163&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">rectCover</span><span class=\"params\">(<span class=\"keyword\">int</span> number)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> result[<span class=\"number\">3</span>] = &#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(number&lt;<span class=\"number\">3</span>) <span class=\"keyword\">return</span> result[number];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> fib_one = result[<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> fib_two = result[<span class=\"number\">2</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> fib;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">3</span>; i&lt;=number; i++)&#123;</span><br><span class=\"line\">            fib = fib_one + fib_two;</span><br><span class=\"line\">            fib_one = fib_two;</span><br><span class=\"line\">            fib_two = fib;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> fib;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>总结一下，对于斐波那契数列问题思路都是一样：</p>\n<ul>\n<li>输出是输入的函数， f(n)</li>\n<li>考虑第一次是如何选择的，就可以把问题给切分出来了。</li>\n</ul>\n","site":{"data":{}},"length":2603,"excerpt":"<h1 id=\"青蛙跳台阶问题\"><a href=\"#青蛙跳台阶问题\" class=\"headerlink\" title=\"青蛙跳台阶问题\"></a>青蛙跳台阶问题</h1><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。 公式不能在hexo上显示出来</p>","more":"<p>题目来源：</p>\n<p><a href=\"https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4?tpId=13&amp;tqId=11161&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking\" target=\"_blank\" rel=\"noopener\">https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4?tpId=13&amp;tqId=11161&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a></p>\n<p>解题思路：函数思想，把n阶台阶的调法看成是关于n的函数 f(n)。当n&gt;2的时候：</p>\n<p>假设第一次跳一个台阶，那么还剩n-1个台阶需要跳，也就是还有f(n-1)的跳法。</p>\n<p>假设第一次跳两个台阶，那么还剩n-2个台阶需要跳，也就是还有f(n-2)的跳法</p>\n<p>所以n阶的跳法总共有f(n-1) + f(n-2)  种，也就是 f(n) = f(n-1) +f(n-2)。</p>\n<p>所以函数就是 ：</p>\n<script type=\"math/tex; mode=display\">\nf(n)=\n\\begin{cases}\n0& \\text{n=0}\\\\\n1& \\text{n=1}\\\\\n2& \\text {n=2}\\\\\nf(n-1)+f(n-2)& \\text {n>2}\n\\end{cases}</script><p>也就是一个斐波那契数列，代码也就比较简单了。参考斐波那契数列的解法:</p>\n<p><a href=\"https://github.com/BraveY/Coding/blob/master/%E5%89%91%E6%8C%87offer/Fibonacci.cc\" target=\"_blank\" rel=\"noopener\">https://github.com/BraveY/Coding/blob/master/%E5%89%91%E6%8C%87offer/Fibonacci.cc</a></p>\n<p>代码为：</p>\n<figure class=\"highlight cc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">jumpFloor</span><span class=\"params\">(<span class=\"keyword\">int</span> number)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> result[<span class=\"number\">3</span>] = &#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(number&lt;<span class=\"number\">3</span>) <span class=\"keyword\">return</span> result[number];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> fib_one = result[<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> fib_two = result[<span class=\"number\">2</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> fib;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">3</span>; i&lt;=number; i++)&#123;</span><br><span class=\"line\">            fib = fib_one + fib_two;</span><br><span class=\"line\">            fib_one = fib_two;</span><br><span class=\"line\">            fib_two = fib;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fib;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"变种题目：\"><a href=\"#变种题目：\" class=\"headerlink\" title=\"变种题目：\"></a>变种题目：</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>\n<p>思路也是一样的：第一次跳1级台阶，则有f(n-1)的解法，第一次跳2级台阶，则有f(n-2)的解法，第一次跳n-1级台阶，则有f(2)的解法， 第一次跳n级台阶则还有一种解法。用f(0)表示第一次跳n级的情况,f(0)=1。</p>\n<p>归纳成函数就是：</p>\n<script type=\"math/tex; mode=display\">\nf(n)=\n\\begin{cases}\n1& \\text{n=0}\\\\\n1& \\text{n=1}\\\\\nf(n-1)+f(n-2)...+f(1)+f(0)& \\text {n>1}\n\\end{cases}</script><p>所以代码为：</p>\n<figure class=\"highlight cc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">jumpFloorII</span><span class=\"params\">(<span class=\"keyword\">int</span> number)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; result;</span><br><span class=\"line\">        result.push_back(<span class=\"number\">1</span>); <span class=\"comment\">// f(0) =1 ;</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>; i&lt;=number; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>; j&lt;i; j++)&#123; <span class=\"comment\">// f(n)=f(n-1)+f(n-2)+...f(1)+f(0)</span></span><br><span class=\"line\">                sum += result[j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            result.push_back(sum);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result[number];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>另一个斐波那契数列数列问题：</p>\n<h2 id=\"矩形覆盖\"><a href=\"#矩形覆盖\" class=\"headerlink\" title=\"矩形覆盖\"></a>矩形覆盖</h2><p><a href=\"https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&amp;tqId=11163&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking\" target=\"_blank\" rel=\"noopener\">https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&amp;tqId=11163&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a></p>\n<p>我们可以用2<em>1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2</em>1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p>\n<p>最开始的时候没有想清楚，以为不是斐波那契数列。</p>\n<p>思路：</p>\n<p>同样的方法为n的函数：f(n); 对于n=1的情况，只能竖着放：所以f(1)=1; n=2的时候，竖着放之后就变成了f(1)种方法，横着放的时候只有一种，总共有两种，所以f(2)=2;</p>\n<p>所以函数为：</p>\n<script type=\"math/tex; mode=display\">\nf(n)=\n\\begin{cases}\n0& \\text{n=0}\\\\\n1& \\text{n=1}\\\\\n2& \\text {n=2}\\\\\nf(n-1)+f(n-2)& \\text {n>2}\n\\end{cases}</script><p>因此代码也是同第一个青蛙跳台阶一样的。</p>\n<p>代码：</p>\n<figure class=\"highlight cc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&amp;tqId=11163&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">rectCover</span><span class=\"params\">(<span class=\"keyword\">int</span> number)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> result[<span class=\"number\">3</span>] = &#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(number&lt;<span class=\"number\">3</span>) <span class=\"keyword\">return</span> result[number];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> fib_one = result[<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> fib_two = result[<span class=\"number\">2</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> fib;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">3</span>; i&lt;=number; i++)&#123;</span><br><span class=\"line\">            fib = fib_one + fib_two;</span><br><span class=\"line\">            fib_one = fib_two;</span><br><span class=\"line\">            fib_two = fib;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> fib;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>总结一下，对于斐波那契数列问题思路都是一样：</p>\n<ul>\n<li>输出是输入的函数， f(n)</li>\n<li>考虑第一次是如何选择的，就可以把问题给切分出来了。</li>\n</ul>"},{"title":"OJ输入输出","date":"2019-09-08T14:16:11.000Z","copyright":true,"_content":"\n# OJ输入输出\n\n算法课要求打UOJ，实际操作后发现与leetcode，牛客这些只用写解决类不一样，OJ要求自己编写输入输出。所以对于输入输出还是很头痛，在此总结下。\n\n<!--more-->\n\n## C++输入输出\n\n输入输出不是对文件进行操作的，可以理解成是在命令行中进行输入与输出。所以主要使用标准输入流cin进行数据的输入，标准输出流cout进行输出。因为有多组测试样例，所以一般需要放在while循环中来读取数据并进行操作。总思路是输入一组输入对应的输出一组输出，边输入边输出。\n\n需要注意的是cin 会自动跳过空格、tab、换行符等不可见的符号，所以可以在同一行中输入a,b两个值，而不用自己去分割空格。\n\n### 只有一组输入输出 \t\n\n直接从键盘获取一组输入，随后输出，以计算a+b为例。\n\n```c++\n#include < iostream >   \nusing namespace std; \nint main() \n{\n     int a,b; \n     cin >> a >> b;\n     cout << a+b << endl; \n     return 0; \n}\n```\n\n## **有多组测试数据，直到读至输入文件结尾为止** \n\n有多组测试数据，需要在while循环中读取数据并进行处理。当输入\n\n````c++\n#include < iostream >    \nusing namespace std;\nint main()\n{\n       int a,b;\n       while(cin >> a >> b)\n            cout << a+b << endl;\n       return 0;\n}\n````\n\n## **在开始的时候输入一个N，接下来是N组数据** \n\n在while循环中进行数据读入，需要注意的是如果后面需要用到n这个参数，需要使用临时变量来存储n，否则n在循环后会变成0.\n\n```c++\n#include <iostream>\nusing namespace std;\nint main() {\n    int a, b, n;\n    cin >> n;\n    while (n--) {\n        cin>>a>>b;\n        cout << a + b << endl;\n    }\n    return 0;\n}\n```\n\n## 未知输入数据量，但以某个特殊输入为结束标志\n\n当a或者b为0的时候结束输入，否则读入一组a，b并输出二者之和。\n\n```c++\n#include<iostream>\nusing namespace std;\nint main()\n{\n    int a ,b;\n    while(cin>>a>>b&&(a||b)){\n        cout<<a+b<<endl;\n    }\n    return 0;\n}\n```\n\n## 重定向输入\n\n将输入从控制台重定向到文件，从文件进行输入。\n\n```c++\n#include<iostream>  \n#include<cstdio>  \nusing namespace std;  \nint main()  \n{  \n    freopen(\"input.txt\",\"r\",stdin);  //输入将被重定向到文件\n    int a,b;  \n    cin>>a>>b;  \n    cout<<a+b<<endl;  \n    return 0;  \n} \n```\n\n## 字符串输入\n\n使用` cin.getline()`函数，其原型为：\n\n```c++\nistream& getline(char line[], int size, char endchar = '\\n');\nchar line[]： 就是一个字符数组，用户输入的内容将存入在该数组内。\nint size : 最多接受几个字符，用户超过size的输入都将不被接受。\nchar endchar :当用户输入endchar指定的字符时，自动结束，默认是回车符。\n```\n\n所以输入指定数目的字符串可以写成：\n\n```c++\n#include<iostream>\nusing namespace std;\nint main()\n{\n    char buf[ 255 ];\n    while(cin.getline( buf, 255 ));\n\n}\n```\n\n也可以使用string类型来进行输入，如下程序循环输入pair组字符串，每组字符串有两个字符串用空格分开。\n\n```c++\n#include<iostream>\n#include<string>\nusing namespace std;\nint main(int argc, char const *argv[])\n{\n\tint pair;\n    string str1, str2;\n\twhile(cin>>pair){\n\t\twhile(pair--){\n\t\t\tcin>>str1;\n\t\t\tcin>>str2;\n\t\t\tcout<<str1<<str2<<endl;\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\n上面的输入样式为：\n\n```\n2\nABCD AEFC\nSCFEZ BNI\n3\nABCD AEFC\nSCFEZ BNI\nABCD XVC\n```\n\n即第一次输入2组字符串，第一组字符串为：`ABCD 与 AEFC`这两个字符串，cin会跳过空格即自动把空格前的ABCD这个字符串作为str1的输入而把空格后面的`AEFC`作为str2的输入。第二组字符串为：`SCFEZ BNI` ,与前面同理不赘述。\n\n第二次输入为3组字符串，与第一次同理。\n\n## 参考\n\n<https://blog.csdn.net/qiao1245/article/details/53020326> \n\n<https://www.cnblogs.com/emerson027/articles/9319135.html> ","source":"_posts/2019-09-08-OJ输入输出.md","raw":"---\ntitle: OJ输入输出\ndate: 2019-09-08 22:16:11\ncategories: 题解\ntags:\n- OJ\n- 编程\ncopyright: true\n---\n\n# OJ输入输出\n\n算法课要求打UOJ，实际操作后发现与leetcode，牛客这些只用写解决类不一样，OJ要求自己编写输入输出。所以对于输入输出还是很头痛，在此总结下。\n\n<!--more-->\n\n## C++输入输出\n\n输入输出不是对文件进行操作的，可以理解成是在命令行中进行输入与输出。所以主要使用标准输入流cin进行数据的输入，标准输出流cout进行输出。因为有多组测试样例，所以一般需要放在while循环中来读取数据并进行操作。总思路是输入一组输入对应的输出一组输出，边输入边输出。\n\n需要注意的是cin 会自动跳过空格、tab、换行符等不可见的符号，所以可以在同一行中输入a,b两个值，而不用自己去分割空格。\n\n### 只有一组输入输出 \t\n\n直接从键盘获取一组输入，随后输出，以计算a+b为例。\n\n```c++\n#include < iostream >   \nusing namespace std; \nint main() \n{\n     int a,b; \n     cin >> a >> b;\n     cout << a+b << endl; \n     return 0; \n}\n```\n\n## **有多组测试数据，直到读至输入文件结尾为止** \n\n有多组测试数据，需要在while循环中读取数据并进行处理。当输入\n\n````c++\n#include < iostream >    \nusing namespace std;\nint main()\n{\n       int a,b;\n       while(cin >> a >> b)\n            cout << a+b << endl;\n       return 0;\n}\n````\n\n## **在开始的时候输入一个N，接下来是N组数据** \n\n在while循环中进行数据读入，需要注意的是如果后面需要用到n这个参数，需要使用临时变量来存储n，否则n在循环后会变成0.\n\n```c++\n#include <iostream>\nusing namespace std;\nint main() {\n    int a, b, n;\n    cin >> n;\n    while (n--) {\n        cin>>a>>b;\n        cout << a + b << endl;\n    }\n    return 0;\n}\n```\n\n## 未知输入数据量，但以某个特殊输入为结束标志\n\n当a或者b为0的时候结束输入，否则读入一组a，b并输出二者之和。\n\n```c++\n#include<iostream>\nusing namespace std;\nint main()\n{\n    int a ,b;\n    while(cin>>a>>b&&(a||b)){\n        cout<<a+b<<endl;\n    }\n    return 0;\n}\n```\n\n## 重定向输入\n\n将输入从控制台重定向到文件，从文件进行输入。\n\n```c++\n#include<iostream>  \n#include<cstdio>  \nusing namespace std;  \nint main()  \n{  \n    freopen(\"input.txt\",\"r\",stdin);  //输入将被重定向到文件\n    int a,b;  \n    cin>>a>>b;  \n    cout<<a+b<<endl;  \n    return 0;  \n} \n```\n\n## 字符串输入\n\n使用` cin.getline()`函数，其原型为：\n\n```c++\nistream& getline(char line[], int size, char endchar = '\\n');\nchar line[]： 就是一个字符数组，用户输入的内容将存入在该数组内。\nint size : 最多接受几个字符，用户超过size的输入都将不被接受。\nchar endchar :当用户输入endchar指定的字符时，自动结束，默认是回车符。\n```\n\n所以输入指定数目的字符串可以写成：\n\n```c++\n#include<iostream>\nusing namespace std;\nint main()\n{\n    char buf[ 255 ];\n    while(cin.getline( buf, 255 ));\n\n}\n```\n\n也可以使用string类型来进行输入，如下程序循环输入pair组字符串，每组字符串有两个字符串用空格分开。\n\n```c++\n#include<iostream>\n#include<string>\nusing namespace std;\nint main(int argc, char const *argv[])\n{\n\tint pair;\n    string str1, str2;\n\twhile(cin>>pair){\n\t\twhile(pair--){\n\t\t\tcin>>str1;\n\t\t\tcin>>str2;\n\t\t\tcout<<str1<<str2<<endl;\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\n上面的输入样式为：\n\n```\n2\nABCD AEFC\nSCFEZ BNI\n3\nABCD AEFC\nSCFEZ BNI\nABCD XVC\n```\n\n即第一次输入2组字符串，第一组字符串为：`ABCD 与 AEFC`这两个字符串，cin会跳过空格即自动把空格前的ABCD这个字符串作为str1的输入而把空格后面的`AEFC`作为str2的输入。第二组字符串为：`SCFEZ BNI` ,与前面同理不赘述。\n\n第二次输入为3组字符串，与第一次同理。\n\n## 参考\n\n<https://blog.csdn.net/qiao1245/article/details/53020326> \n\n<https://www.cnblogs.com/emerson027/articles/9319135.html> ","slug":"2019-09-08-OJ输入输出","published":1,"updated":"2019-11-11T03:34:45.463Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2yelxhc000pm8tzr2pmpp8t","content":"<h1 id=\"OJ输入输出\"><a href=\"#OJ输入输出\" class=\"headerlink\" title=\"OJ输入输出\"></a>OJ输入输出</h1><p>算法课要求打UOJ，实际操作后发现与leetcode，牛客这些只用写解决类不一样，OJ要求自己编写输入输出。所以对于输入输出还是很头痛，在此总结下。</p>\n<a id=\"more\"></a>\n<h2 id=\"C-输入输出\"><a href=\"#C-输入输出\" class=\"headerlink\" title=\"C++输入输出\"></a>C++输入输出</h2><p>输入输出不是对文件进行操作的，可以理解成是在命令行中进行输入与输出。所以主要使用标准输入流cin进行数据的输入，标准输出流cout进行输出。因为有多组测试样例，所以一般需要放在while循环中来读取数据并进行操作。总思路是输入一组输入对应的输出一组输出，边输入边输出。</p>\n<p>需要注意的是cin 会自动跳过空格、tab、换行符等不可见的符号，所以可以在同一行中输入a,b两个值，而不用自己去分割空格。</p>\n<h3 id=\"只有一组输入输出\"><a href=\"#只有一组输入输出\" class=\"headerlink\" title=\"只有一组输入输出\"></a>只有一组输入输出</h3><p>直接从键盘获取一组输入，随后输出，以计算a+b为例。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt; iostream &gt;   </span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>; </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">int</span> a,b; </span><br><span class=\"line\">     <span class=\"built_in\">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class=\"line\">     <span class=\"built_in\">cout</span> &lt;&lt; a+b &lt;&lt; <span class=\"built_in\">endl</span>; </span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"number\">0</span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"有多组测试数据，直到读至输入文件结尾为止\"><a href=\"#有多组测试数据，直到读至输入文件结尾为止\" class=\"headerlink\" title=\"有多组测试数据，直到读至输入文件结尾为止\"></a><strong>有多组测试数据，直到读至输入文件结尾为止</strong></h2><p>有多组测试数据，需要在while循环中读取数据并进行处理。当输入</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt; iostream &gt;    </span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">int</span> a,b;</span><br><span class=\"line\">       <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span> &gt;&gt; a &gt;&gt; b)</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; a+b &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"在开始的时候输入一个N，接下来是N组数据\"><a href=\"#在开始的时候输入一个N，接下来是N组数据\" class=\"headerlink\" title=\"在开始的时候输入一个N，接下来是N组数据\"></a><strong>在开始的时候输入一个N，接下来是N组数据</strong></h2><p>在while循环中进行数据读入，需要注意的是如果后面需要用到n这个参数，需要使用临时变量来存储n，否则n在循环后会变成0.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a, b, n;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (n--) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; a + b &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"未知输入数据量，但以某个特殊输入为结束标志\"><a href=\"#未知输入数据量，但以某个特殊输入为结束标志\" class=\"headerlink\" title=\"未知输入数据量，但以某个特殊输入为结束标志\"></a>未知输入数据量，但以某个特殊输入为结束标志</h2><p>当a或者b为0的时候结束输入，否则读入一组a，b并输出二者之和。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a ,b;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span>&gt;&gt;a&gt;&gt;b&amp;&amp;(a||b))&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;a+b&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"重定向输入\"><a href=\"#重定向输入\" class=\"headerlink\" title=\"重定向输入\"></a>重定向输入</h2><p>将输入从控制台重定向到文件，从文件进行输入。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;  </span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cstdio&gt;  </span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span>  </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;  </span><br><span class=\"line\">    freopen(<span class=\"string\">\"input.txt\"</span>,<span class=\"string\">\"r\"</span>,<span class=\"built_in\">stdin</span>);  <span class=\"comment\">//输入将被重定向到文件</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a,b;  </span><br><span class=\"line\">    <span class=\"built_in\">cin</span>&gt;&gt;a&gt;&gt;b;  </span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;a+b&lt;&lt;<span class=\"built_in\">endl</span>;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"字符串输入\"><a href=\"#字符串输入\" class=\"headerlink\" title=\"字符串输入\"></a>字符串输入</h2><p>使用<code>cin.getline()</code>函数，其原型为：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">istream&amp; <span class=\"title\">getline</span><span class=\"params\">(<span class=\"keyword\">char</span> line[], <span class=\"keyword\">int</span> size, <span class=\"keyword\">char</span> endchar = <span class=\"string\">'\\n'</span>)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">char</span> line[]： 就是一个字符数组，用户输入的内容将存入在该数组内。</span><br><span class=\"line\"><span class=\"keyword\">int</span> size : 最多接受几个字符，用户超过size的输入都将不被接受。</span><br><span class=\"line\"><span class=\"keyword\">char</span> endchar :当用户输入endchar指定的字符时，自动结束，默认是回车符。</span><br></pre></td></tr></table></figure>\n<p>所以输入指定数目的字符串可以写成：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> buf[ <span class=\"number\">255</span> ];</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span>.getline( buf, <span class=\"number\">255</span> ));</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>也可以使用string类型来进行输入，如下程序循环输入pair组字符串，每组字符串有两个字符串用空格分开。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> pair;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> str1, str2;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span>&gt;&gt;pair)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(pair--)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">cin</span>&gt;&gt;str1;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">cin</span>&gt;&gt;str2;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">cout</span>&lt;&lt;str1&lt;&lt;str2&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的输入样式为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2</span><br><span class=\"line\">ABCD AEFC</span><br><span class=\"line\">SCFEZ BNI</span><br><span class=\"line\">3</span><br><span class=\"line\">ABCD AEFC</span><br><span class=\"line\">SCFEZ BNI</span><br><span class=\"line\">ABCD XVC</span><br></pre></td></tr></table></figure>\n<p>即第一次输入2组字符串，第一组字符串为：<code>ABCD 与 AEFC</code>这两个字符串，cin会跳过空格即自动把空格前的ABCD这个字符串作为str1的输入而把空格后面的<code>AEFC</code>作为str2的输入。第二组字符串为：<code>SCFEZ BNI</code> ,与前面同理不赘述。</p>\n<p>第二次输入为3组字符串，与第一次同理。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://blog.csdn.net/qiao1245/article/details/53020326\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/qiao1245/article/details/53020326</a> </p>\n<p><a href=\"https://www.cnblogs.com/emerson027/articles/9319135.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/emerson027/articles/9319135.html</a> </p>\n","site":{"data":{}},"length":2353,"excerpt":"<h1 id=\"OJ输入输出\"><a href=\"#OJ输入输出\" class=\"headerlink\" title=\"OJ输入输出\"></a>OJ输入输出</h1><p>算法课要求打UOJ，实际操作后发现与leetcode，牛客这些只用写解决类不一样，OJ要求自己编写输入输出。所以对于输入输出还是很头痛，在此总结下。</p>","more":"<h2 id=\"C-输入输出\"><a href=\"#C-输入输出\" class=\"headerlink\" title=\"C++输入输出\"></a>C++输入输出</h2><p>输入输出不是对文件进行操作的，可以理解成是在命令行中进行输入与输出。所以主要使用标准输入流cin进行数据的输入，标准输出流cout进行输出。因为有多组测试样例，所以一般需要放在while循环中来读取数据并进行操作。总思路是输入一组输入对应的输出一组输出，边输入边输出。</p>\n<p>需要注意的是cin 会自动跳过空格、tab、换行符等不可见的符号，所以可以在同一行中输入a,b两个值，而不用自己去分割空格。</p>\n<h3 id=\"只有一组输入输出\"><a href=\"#只有一组输入输出\" class=\"headerlink\" title=\"只有一组输入输出\"></a>只有一组输入输出</h3><p>直接从键盘获取一组输入，随后输出，以计算a+b为例。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt; iostream &gt;   </span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>; </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">int</span> a,b; </span><br><span class=\"line\">     <span class=\"built_in\">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class=\"line\">     <span class=\"built_in\">cout</span> &lt;&lt; a+b &lt;&lt; <span class=\"built_in\">endl</span>; </span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"number\">0</span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"有多组测试数据，直到读至输入文件结尾为止\"><a href=\"#有多组测试数据，直到读至输入文件结尾为止\" class=\"headerlink\" title=\"有多组测试数据，直到读至输入文件结尾为止\"></a><strong>有多组测试数据，直到读至输入文件结尾为止</strong></h2><p>有多组测试数据，需要在while循环中读取数据并进行处理。当输入</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt; iostream &gt;    </span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">int</span> a,b;</span><br><span class=\"line\">       <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span> &gt;&gt; a &gt;&gt; b)</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; a+b &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"在开始的时候输入一个N，接下来是N组数据\"><a href=\"#在开始的时候输入一个N，接下来是N组数据\" class=\"headerlink\" title=\"在开始的时候输入一个N，接下来是N组数据\"></a><strong>在开始的时候输入一个N，接下来是N组数据</strong></h2><p>在while循环中进行数据读入，需要注意的是如果后面需要用到n这个参数，需要使用临时变量来存储n，否则n在循环后会变成0.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a, b, n;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (n--) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; a + b &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"未知输入数据量，但以某个特殊输入为结束标志\"><a href=\"#未知输入数据量，但以某个特殊输入为结束标志\" class=\"headerlink\" title=\"未知输入数据量，但以某个特殊输入为结束标志\"></a>未知输入数据量，但以某个特殊输入为结束标志</h2><p>当a或者b为0的时候结束输入，否则读入一组a，b并输出二者之和。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a ,b;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span>&gt;&gt;a&gt;&gt;b&amp;&amp;(a||b))&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;a+b&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"重定向输入\"><a href=\"#重定向输入\" class=\"headerlink\" title=\"重定向输入\"></a>重定向输入</h2><p>将输入从控制台重定向到文件，从文件进行输入。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;  </span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cstdio&gt;  </span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span>  </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;  </span><br><span class=\"line\">    freopen(<span class=\"string\">\"input.txt\"</span>,<span class=\"string\">\"r\"</span>,<span class=\"built_in\">stdin</span>);  <span class=\"comment\">//输入将被重定向到文件</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a,b;  </span><br><span class=\"line\">    <span class=\"built_in\">cin</span>&gt;&gt;a&gt;&gt;b;  </span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;a+b&lt;&lt;<span class=\"built_in\">endl</span>;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"字符串输入\"><a href=\"#字符串输入\" class=\"headerlink\" title=\"字符串输入\"></a>字符串输入</h2><p>使用<code>cin.getline()</code>函数，其原型为：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">istream&amp; <span class=\"title\">getline</span><span class=\"params\">(<span class=\"keyword\">char</span> line[], <span class=\"keyword\">int</span> size, <span class=\"keyword\">char</span> endchar = <span class=\"string\">'\\n'</span>)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">char</span> line[]： 就是一个字符数组，用户输入的内容将存入在该数组内。</span><br><span class=\"line\"><span class=\"keyword\">int</span> size : 最多接受几个字符，用户超过size的输入都将不被接受。</span><br><span class=\"line\"><span class=\"keyword\">char</span> endchar :当用户输入endchar指定的字符时，自动结束，默认是回车符。</span><br></pre></td></tr></table></figure>\n<p>所以输入指定数目的字符串可以写成：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> buf[ <span class=\"number\">255</span> ];</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span>.getline( buf, <span class=\"number\">255</span> ));</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>也可以使用string类型来进行输入，如下程序循环输入pair组字符串，每组字符串有两个字符串用空格分开。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> pair;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> str1, str2;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span>&gt;&gt;pair)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(pair--)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">cin</span>&gt;&gt;str1;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">cin</span>&gt;&gt;str2;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">cout</span>&lt;&lt;str1&lt;&lt;str2&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的输入样式为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2</span><br><span class=\"line\">ABCD AEFC</span><br><span class=\"line\">SCFEZ BNI</span><br><span class=\"line\">3</span><br><span class=\"line\">ABCD AEFC</span><br><span class=\"line\">SCFEZ BNI</span><br><span class=\"line\">ABCD XVC</span><br></pre></td></tr></table></figure>\n<p>即第一次输入2组字符串，第一组字符串为：<code>ABCD 与 AEFC</code>这两个字符串，cin会跳过空格即自动把空格前的ABCD这个字符串作为str1的输入而把空格后面的<code>AEFC</code>作为str2的输入。第二组字符串为：<code>SCFEZ BNI</code> ,与前面同理不赘述。</p>\n<p>第二次输入为3组字符串，与第一次同理。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://blog.csdn.net/qiao1245/article/details/53020326\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/qiao1245/article/details/53020326</a> </p>\n<p><a href=\"https://www.cnblogs.com/emerson027/articles/9319135.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/emerson027/articles/9319135.html</a> </p>"},{"title":"GCC的编译选项","date":"2019-04-25T06:18:49.000Z","copyright":true,"_content":"\n# GCC的编译选项\n\nMakefile 中的gcc的编译选项有很多，因此学习记录下。\n\n<!--more-->\n\n这些选项在Makefile文件中常用CFLAGS（gcc 用在c语言的编译），CXXFLAGS（g++用在c++的编译）来表示。\n\n## 程序编译的过程\n\ngcc 与 g++ 分别是 gnu 的 c & c++ 编译器 gcc/g++ 在执行编译工作的时候，总共需要4步：\n\n- 1、预处理,生成 .i 的文件[预处理器cpp]\n- 2、将预处理后的文件转换成汇编语言, 生成文件 .s [编译器egcs]\n- 3、将汇编代码变为目标代码(机器代码)生成 .o 的obj文件[汇编器as]\n- 4、连接目标代码, 生成可执行程序 [链接器ld]\n\n## 选项\n\n| 选项          | 释义                                                         |\n| ------------- | ------------------------------------------------------------ |\n| -c            | 只激活预处理,编译,和汇编。只把程序做成obj文件，不是可执行文件（因为没有链接,有的程序中也没有main入口） |\n| -S            | 只激活预处理和编译，就是只把文件编译成为汇编代码。生成.s的汇编代码 |\n| -E            | 只激活预处理,不生成文件,你需要把它重定向到一个输出文件里面 例子：gcc -E hello.c > pianoapan.txt |\n| -o            | 指定输出，缺省的时候,gcc 编译出来的文件是a.out               |\n| -Wall         | 显示所有警告信息                                             |\n| -w            | 不生成任何警告信息。                                         |\n| -Wextra       | 打印出更多的警告信息，比开启 -Wall 打印的还多                |\n| -ansi         | 关闭gnu c中与ansi c不兼容的特性,激活ansi c的专有特性(包括禁止一些asm inline typeof关键字,以及UNIX,vax等预处理宏 |\n| -include file | 包含某个代码,简单来说,就是便于某个文件需要另一个文件的时候,就可以用它设<br/>定,功能就相当于在代码中使用#include<filename> |\n| -Idir         | 添加dir目录为头文件搜索路径，如-I./ 在当前目录查找头文件     |\n| -I-           | 取消前一个参数的功能,所以一般在-Idir之后使用                 |\n| -llib         | 指定编译的时候使用的库，gcc -lcurses hello.c 使用库curses进行编译 |\n| -std=         | 编译的标准,包括GNU99，c++11,c99,等等                         |\n| -O2           | 编译器的优化选项的4个级别，-O0表示没有优化,-O1为缺省值，-O3优化级别最高 |\n| -Ldir         | 链接的时候，搜索库的路径 -L./ 在当前目录搜说                 |\n| -g            | 产生调试信息，可以使用gdb调试可执行文件                      |\n| -ggdb         | 此选项将尽可能的生成gdb的可以使用的调试信息.                 |\n| -static       | 禁止使用动态库，所以，编译出来的东西，一般都很大，也不需要什么 |\n| -share        | 此选项将尽量使用动态库，所以生成文件比较小，但是需要系统由动态库. |\n| -shared       | 创建一个动态链接库（不指定的话输出的是obj文件）gcc -fPIC -shared func.c -o libfunc.s |\n| -rdynamic     | 动态连接符号信息，用于动态连接功能。所有符号添加到动态符号表中（目的是能够通过使用 dlopen 来实现向后跟踪） |\n| -pedantic     | 用于保证代码规范满足ISO C和ISO C++标准, 不允许使用任何扩展以及不满足ISO C和C++的代码, 遵守 -std 选项指定的标准 |\n| -pthread      | 支持多线程, 使用pthread库                                    |\n| -fPIC         | PIC 是 position-independent code的意思, 此选项去除独立位置代码, 适合于动态链接 |\n\nar -r libhello.a hello.o  #这里的ar相当于tar的作用，将多个目标打包。 makefile中用于创建静态链接库（就是把多个目标文件打包成一个）\n\n## 参考\n\n<https://blog.csdn.net/navyhu/article/details/46788559>\n\nhttps://blog.csdn.net/woshinia/article/details/11060797>\n\n<https://gcc.gnu.org/onlinedocs/>","source":"_posts/2019-04-25-GCC的编译选项.md","raw":"---\ntitle: GCC的编译选项\ndate: 2019-04-25 14:18:49\ncategories: Linux\ntags: \n- gcc\n- make\ncopyright: true\n---\n\n# GCC的编译选项\n\nMakefile 中的gcc的编译选项有很多，因此学习记录下。\n\n<!--more-->\n\n这些选项在Makefile文件中常用CFLAGS（gcc 用在c语言的编译），CXXFLAGS（g++用在c++的编译）来表示。\n\n## 程序编译的过程\n\ngcc 与 g++ 分别是 gnu 的 c & c++ 编译器 gcc/g++ 在执行编译工作的时候，总共需要4步：\n\n- 1、预处理,生成 .i 的文件[预处理器cpp]\n- 2、将预处理后的文件转换成汇编语言, 生成文件 .s [编译器egcs]\n- 3、将汇编代码变为目标代码(机器代码)生成 .o 的obj文件[汇编器as]\n- 4、连接目标代码, 生成可执行程序 [链接器ld]\n\n## 选项\n\n| 选项          | 释义                                                         |\n| ------------- | ------------------------------------------------------------ |\n| -c            | 只激活预处理,编译,和汇编。只把程序做成obj文件，不是可执行文件（因为没有链接,有的程序中也没有main入口） |\n| -S            | 只激活预处理和编译，就是只把文件编译成为汇编代码。生成.s的汇编代码 |\n| -E            | 只激活预处理,不生成文件,你需要把它重定向到一个输出文件里面 例子：gcc -E hello.c > pianoapan.txt |\n| -o            | 指定输出，缺省的时候,gcc 编译出来的文件是a.out               |\n| -Wall         | 显示所有警告信息                                             |\n| -w            | 不生成任何警告信息。                                         |\n| -Wextra       | 打印出更多的警告信息，比开启 -Wall 打印的还多                |\n| -ansi         | 关闭gnu c中与ansi c不兼容的特性,激活ansi c的专有特性(包括禁止一些asm inline typeof关键字,以及UNIX,vax等预处理宏 |\n| -include file | 包含某个代码,简单来说,就是便于某个文件需要另一个文件的时候,就可以用它设<br/>定,功能就相当于在代码中使用#include<filename> |\n| -Idir         | 添加dir目录为头文件搜索路径，如-I./ 在当前目录查找头文件     |\n| -I-           | 取消前一个参数的功能,所以一般在-Idir之后使用                 |\n| -llib         | 指定编译的时候使用的库，gcc -lcurses hello.c 使用库curses进行编译 |\n| -std=         | 编译的标准,包括GNU99，c++11,c99,等等                         |\n| -O2           | 编译器的优化选项的4个级别，-O0表示没有优化,-O1为缺省值，-O3优化级别最高 |\n| -Ldir         | 链接的时候，搜索库的路径 -L./ 在当前目录搜说                 |\n| -g            | 产生调试信息，可以使用gdb调试可执行文件                      |\n| -ggdb         | 此选项将尽可能的生成gdb的可以使用的调试信息.                 |\n| -static       | 禁止使用动态库，所以，编译出来的东西，一般都很大，也不需要什么 |\n| -share        | 此选项将尽量使用动态库，所以生成文件比较小，但是需要系统由动态库. |\n| -shared       | 创建一个动态链接库（不指定的话输出的是obj文件）gcc -fPIC -shared func.c -o libfunc.s |\n| -rdynamic     | 动态连接符号信息，用于动态连接功能。所有符号添加到动态符号表中（目的是能够通过使用 dlopen 来实现向后跟踪） |\n| -pedantic     | 用于保证代码规范满足ISO C和ISO C++标准, 不允许使用任何扩展以及不满足ISO C和C++的代码, 遵守 -std 选项指定的标准 |\n| -pthread      | 支持多线程, 使用pthread库                                    |\n| -fPIC         | PIC 是 position-independent code的意思, 此选项去除独立位置代码, 适合于动态链接 |\n\nar -r libhello.a hello.o  #这里的ar相当于tar的作用，将多个目标打包。 makefile中用于创建静态链接库（就是把多个目标文件打包成一个）\n\n## 参考\n\n<https://blog.csdn.net/navyhu/article/details/46788559>\n\nhttps://blog.csdn.net/woshinia/article/details/11060797>\n\n<https://gcc.gnu.org/onlinedocs/>","slug":"2019-04-25-GCC的编译选项","published":1,"updated":"2019-11-08T13:13:31.703Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2yelxhe000tm8tzcimady2q","content":"<h1 id=\"GCC的编译选项\"><a href=\"#GCC的编译选项\" class=\"headerlink\" title=\"GCC的编译选项\"></a>GCC的编译选项</h1><p>Makefile 中的gcc的编译选项有很多，因此学习记录下。</p>\n<a id=\"more\"></a>\n<p>这些选项在Makefile文件中常用CFLAGS（gcc 用在c语言的编译），CXXFLAGS（g++用在c++的编译）来表示。</p>\n<h2 id=\"程序编译的过程\"><a href=\"#程序编译的过程\" class=\"headerlink\" title=\"程序编译的过程\"></a>程序编译的过程</h2><p>gcc 与 g++ 分别是 gnu 的 c &amp; c++ 编译器 gcc/g++ 在执行编译工作的时候，总共需要4步：</p>\n<ul>\n<li>1、预处理,生成 .i 的文件[预处理器cpp]</li>\n<li>2、将预处理后的文件转换成汇编语言, 生成文件 .s [编译器egcs]</li>\n<li>3、将汇编代码变为目标代码(机器代码)生成 .o 的obj文件[汇编器as]</li>\n<li>4、连接目标代码, 生成可执行程序 [链接器ld]</li>\n</ul>\n<h2 id=\"选项\"><a href=\"#选项\" class=\"headerlink\" title=\"选项\"></a>选项</h2><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>释义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-c</td>\n<td>只激活预处理,编译,和汇编。只把程序做成obj文件，不是可执行文件（因为没有链接,有的程序中也没有main入口）</td>\n</tr>\n<tr>\n<td>-S</td>\n<td>只激活预处理和编译，就是只把文件编译成为汇编代码。生成.s的汇编代码</td>\n</tr>\n<tr>\n<td>-E</td>\n<td>只激活预处理,不生成文件,你需要把它重定向到一个输出文件里面 例子：gcc -E hello.c &gt; pianoapan.txt</td>\n</tr>\n<tr>\n<td>-o</td>\n<td>指定输出，缺省的时候,gcc 编译出来的文件是a.out</td>\n</tr>\n<tr>\n<td>-Wall</td>\n<td>显示所有警告信息</td>\n</tr>\n<tr>\n<td>-w</td>\n<td>不生成任何警告信息。</td>\n</tr>\n<tr>\n<td>-Wextra</td>\n<td>打印出更多的警告信息，比开启 -Wall 打印的还多</td>\n</tr>\n<tr>\n<td>-ansi</td>\n<td>关闭gnu c中与ansi c不兼容的特性,激活ansi c的专有特性(包括禁止一些asm inline typeof关键字,以及UNIX,vax等预处理宏</td>\n</tr>\n<tr>\n<td>-include file</td>\n<td>包含某个代码,简单来说,就是便于某个文件需要另一个文件的时候,就可以用它设<br>定,功能就相当于在代码中使用#include<filename></filename></td>\n</tr>\n<tr>\n<td>-Idir</td>\n<td>添加dir目录为头文件搜索路径，如-I./ 在当前目录查找头文件</td>\n</tr>\n<tr>\n<td>-I-</td>\n<td>取消前一个参数的功能,所以一般在-Idir之后使用</td>\n</tr>\n<tr>\n<td>-llib</td>\n<td>指定编译的时候使用的库，gcc -lcurses hello.c 使用库curses进行编译</td>\n</tr>\n<tr>\n<td>-std=</td>\n<td>编译的标准,包括GNU99，c++11,c99,等等</td>\n</tr>\n<tr>\n<td>-O2</td>\n<td>编译器的优化选项的4个级别，-O0表示没有优化,-O1为缺省值，-O3优化级别最高</td>\n</tr>\n<tr>\n<td>-Ldir</td>\n<td>链接的时候，搜索库的路径 -L./ 在当前目录搜说</td>\n</tr>\n<tr>\n<td>-g</td>\n<td>产生调试信息，可以使用gdb调试可执行文件</td>\n</tr>\n<tr>\n<td>-ggdb</td>\n<td>此选项将尽可能的生成gdb的可以使用的调试信息.</td>\n</tr>\n<tr>\n<td>-static</td>\n<td>禁止使用动态库，所以，编译出来的东西，一般都很大，也不需要什么</td>\n</tr>\n<tr>\n<td>-share</td>\n<td>此选项将尽量使用动态库，所以生成文件比较小，但是需要系统由动态库.</td>\n</tr>\n<tr>\n<td>-shared</td>\n<td>创建一个动态链接库（不指定的话输出的是obj文件）gcc -fPIC -shared func.c -o libfunc.s</td>\n</tr>\n<tr>\n<td>-rdynamic</td>\n<td>动态连接符号信息，用于动态连接功能。所有符号添加到动态符号表中（目的是能够通过使用 dlopen 来实现向后跟踪）</td>\n</tr>\n<tr>\n<td>-pedantic</td>\n<td>用于保证代码规范满足ISO C和ISO C++标准, 不允许使用任何扩展以及不满足ISO C和C++的代码, 遵守 -std 选项指定的标准</td>\n</tr>\n<tr>\n<td>-pthread</td>\n<td>支持多线程, 使用pthread库</td>\n</tr>\n<tr>\n<td>-fPIC</td>\n<td>PIC 是 position-independent code的意思, 此选项去除独立位置代码, 适合于动态链接</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>ar -r libhello.a hello.o  #这里的ar相当于tar的作用，将多个目标打包。 makefile中用于创建静态链接库（就是把多个目标文件打包成一个）</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://blog.csdn.net/navyhu/article/details/46788559\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/navyhu/article/details/46788559</a></p>\n<p><a href=\"https://blog.csdn.net/woshinia/article/details/11060797&gt;\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/woshinia/article/details/11060797&gt;</a></p>\n<p><a href=\"https://gcc.gnu.org/onlinedocs/\" target=\"_blank\" rel=\"noopener\">https://gcc.gnu.org/onlinedocs/</a></p>\n","site":{"data":{}},"length":1519,"excerpt":"<h1 id=\"GCC的编译选项\"><a href=\"#GCC的编译选项\" class=\"headerlink\" title=\"GCC的编译选项\"></a>GCC的编译选项</h1><p>Makefile 中的gcc的编译选项有很多，因此学习记录下。</p>","more":"<p>这些选项在Makefile文件中常用CFLAGS（gcc 用在c语言的编译），CXXFLAGS（g++用在c++的编译）来表示。</p>\n<h2 id=\"程序编译的过程\"><a href=\"#程序编译的过程\" class=\"headerlink\" title=\"程序编译的过程\"></a>程序编译的过程</h2><p>gcc 与 g++ 分别是 gnu 的 c &amp; c++ 编译器 gcc/g++ 在执行编译工作的时候，总共需要4步：</p>\n<ul>\n<li>1、预处理,生成 .i 的文件[预处理器cpp]</li>\n<li>2、将预处理后的文件转换成汇编语言, 生成文件 .s [编译器egcs]</li>\n<li>3、将汇编代码变为目标代码(机器代码)生成 .o 的obj文件[汇编器as]</li>\n<li>4、连接目标代码, 生成可执行程序 [链接器ld]</li>\n</ul>\n<h2 id=\"选项\"><a href=\"#选项\" class=\"headerlink\" title=\"选项\"></a>选项</h2><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>释义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-c</td>\n<td>只激活预处理,编译,和汇编。只把程序做成obj文件，不是可执行文件（因为没有链接,有的程序中也没有main入口）</td>\n</tr>\n<tr>\n<td>-S</td>\n<td>只激活预处理和编译，就是只把文件编译成为汇编代码。生成.s的汇编代码</td>\n</tr>\n<tr>\n<td>-E</td>\n<td>只激活预处理,不生成文件,你需要把它重定向到一个输出文件里面 例子：gcc -E hello.c &gt; pianoapan.txt</td>\n</tr>\n<tr>\n<td>-o</td>\n<td>指定输出，缺省的时候,gcc 编译出来的文件是a.out</td>\n</tr>\n<tr>\n<td>-Wall</td>\n<td>显示所有警告信息</td>\n</tr>\n<tr>\n<td>-w</td>\n<td>不生成任何警告信息。</td>\n</tr>\n<tr>\n<td>-Wextra</td>\n<td>打印出更多的警告信息，比开启 -Wall 打印的还多</td>\n</tr>\n<tr>\n<td>-ansi</td>\n<td>关闭gnu c中与ansi c不兼容的特性,激活ansi c的专有特性(包括禁止一些asm inline typeof关键字,以及UNIX,vax等预处理宏</td>\n</tr>\n<tr>\n<td>-include file</td>\n<td>包含某个代码,简单来说,就是便于某个文件需要另一个文件的时候,就可以用它设<br>定,功能就相当于在代码中使用#include<filename></filename></td>\n</tr>\n<tr>\n<td>-Idir</td>\n<td>添加dir目录为头文件搜索路径，如-I./ 在当前目录查找头文件</td>\n</tr>\n<tr>\n<td>-I-</td>\n<td>取消前一个参数的功能,所以一般在-Idir之后使用</td>\n</tr>\n<tr>\n<td>-llib</td>\n<td>指定编译的时候使用的库，gcc -lcurses hello.c 使用库curses进行编译</td>\n</tr>\n<tr>\n<td>-std=</td>\n<td>编译的标准,包括GNU99，c++11,c99,等等</td>\n</tr>\n<tr>\n<td>-O2</td>\n<td>编译器的优化选项的4个级别，-O0表示没有优化,-O1为缺省值，-O3优化级别最高</td>\n</tr>\n<tr>\n<td>-Ldir</td>\n<td>链接的时候，搜索库的路径 -L./ 在当前目录搜说</td>\n</tr>\n<tr>\n<td>-g</td>\n<td>产生调试信息，可以使用gdb调试可执行文件</td>\n</tr>\n<tr>\n<td>-ggdb</td>\n<td>此选项将尽可能的生成gdb的可以使用的调试信息.</td>\n</tr>\n<tr>\n<td>-static</td>\n<td>禁止使用动态库，所以，编译出来的东西，一般都很大，也不需要什么</td>\n</tr>\n<tr>\n<td>-share</td>\n<td>此选项将尽量使用动态库，所以生成文件比较小，但是需要系统由动态库.</td>\n</tr>\n<tr>\n<td>-shared</td>\n<td>创建一个动态链接库（不指定的话输出的是obj文件）gcc -fPIC -shared func.c -o libfunc.s</td>\n</tr>\n<tr>\n<td>-rdynamic</td>\n<td>动态连接符号信息，用于动态连接功能。所有符号添加到动态符号表中（目的是能够通过使用 dlopen 来实现向后跟踪）</td>\n</tr>\n<tr>\n<td>-pedantic</td>\n<td>用于保证代码规范满足ISO C和ISO C++标准, 不允许使用任何扩展以及不满足ISO C和C++的代码, 遵守 -std 选项指定的标准</td>\n</tr>\n<tr>\n<td>-pthread</td>\n<td>支持多线程, 使用pthread库</td>\n</tr>\n<tr>\n<td>-fPIC</td>\n<td>PIC 是 position-independent code的意思, 此选项去除独立位置代码, 适合于动态链接</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>ar -r libhello.a hello.o  #这里的ar相当于tar的作用，将多个目标打包。 makefile中用于创建静态链接库（就是把多个目标文件打包成一个）</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://blog.csdn.net/navyhu/article/details/46788559\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/navyhu/article/details/46788559</a></p>\n<p><a href=\"https://blog.csdn.net/woshinia/article/details/11060797&gt;\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/woshinia/article/details/11060797&gt;</a></p>\n<p><a href=\"https://gcc.gnu.org/onlinedocs/\" target=\"_blank\" rel=\"noopener\">https://gcc.gnu.org/onlinedocs/</a></p>"},{"title":"Redis Makefile注解","date":"2019-04-26T07:57:19.000Z","copyright":true,"_content":"\n# Redis Makefile注解\n\nRedis的makefile是阅读源码的第一步，总共有292行，读起来也是头大，记录之。\n\n<!--more-->\n\n4.02版本源码为：\n\n```makefile\n# Redis Makefile\n# Copyright (C) 2009 Salvatore Sanfilippo <antirez at gmail dot com>\n# This file is released under the BSD license, see the COPYING file\n#\n# The Makefile composes the final FINAL_CFLAGS and FINAL_LDFLAGS using\n# what is needed for Redis plus the standard CFLAGS and LDFLAGS passed.\n# However when building the dependencies (Jemalloc, Lua, Hiredis, ...)\n# CFLAGS and LDFLAGS are propagated to the dependencies, so to pass\n# flags only to be used when compiling / linking Redis itself REDIS_CFLAGS\n# and REDIS_LDFLAGS are used instead (this is the case of 'make gcov').\n#\n# Dependencies are stored in the Makefile.dep file. To rebuild this file\n# Just use 'make dep', but this is only needed by developers.\n\nrelease_hdr := $(shell sh -c './mkreleasehdr.sh')\n# uname -s 获取操作系统的类型 Linux\nuname_S := $(shell sh -c 'uname -s 2>/dev/null || echo not')\n#uname -m 获取机子的架构 x86_64\nuname_M := $(shell sh -c 'uname -m 2>/dev/null || echo not')\n# 优化选项\nOPTIMIZATION?=-O2\n# 依赖目标\nDEPENDENCY_TARGETS=hiredis linenoise lua\nNODEPS:=clean distclean\n\n# Default settings\n# 使用c99标准编译，-pedantic 保证代码规范满足ISO C和ISO C++标准\nSTD=-std=c99 -pedantic -DREDIS_STATIC=''\n# 输出所有编译警告信息 ，Wno-missing-field-initializers 不输出missing-的警告信息\nWARN=-Wall -W -Wno-missing-field-initializers\nOPT=$(OPTIMIZATION)\n\n#默认目录\nPREFIX?=/usr/local\n#安装的默认目录\nINSTALL_BIN=$(PREFIX)/bin\nINSTALL=install\n\n# Default allocator defaults to Jemalloc if it's not an ARM\n#内存分配器的指定 默认libc，linux系统而且架构不是armv61和71的时候则是jemalloc，\nMALLOC=libc\nifneq ($(uname_M),armv6l)\nifneq ($(uname_M),armv7l)\nifeq ($(uname_S),Linux)\n\tMALLOC=jemalloc\nendif\nendif\nendif\n\n# To get ARM stack traces if Redis crashes we need a special C flag.\nifneq (,$(findstring armv,$(uname_M)))\n        CFLAGS+=-funwind-tables\nendif\n\n# Backwards compatibility for selecting an allocator\n#编译的时候指定内存分配器\nifeq ($(USE_TCMALLOC),yes)\n\tMALLOC=tcmalloc\nendif\n\nifeq ($(USE_TCMALLOC_MINIMAL),yes)\n\tMALLOC=tcmalloc_minimal\nendif\n\nifeq ($(USE_JEMALLOC),yes)\n\tMALLOC=jemalloc\nendif\n\nifeq ($(USE_JEMALLOC),no)\n\tMALLOC=libc\nendif\n\n# Override default settings if possible\n-include .make-settings\n# 最终的编译选项CFLAGS是-c的选项，LDFLAGS是链接的选项\nFINAL_CFLAGS=$(STD) $(WARN) $(OPT) $(DEBUG) $(CFLAGS) $(REDIS_CFLAGS)\nFINAL_LDFLAGS=$(LDFLAGS) $(REDIS_LDFLAGS) $(DEBUG)\n# m这个lib是libmath 也就是math的链接\nFINAL_LIBS=-lm\n# 调试信息\nDEBUG=-g -ggdb\n#根据操作系统继续指定编译选项\nifeq ($(uname_S),SunOS)\n\t# SunOS\n        ifneq ($(@@),32bit)\n\t\tCFLAGS+= -m64\n\t\tLDFLAGS+= -m64\n\tendif\n\tDEBUG=-g\n\tDEBUG_FLAGS=-g\n\texport CFLAGS LDFLAGS DEBUG DEBUG_FLAGS\n\tINSTALL=cp -pf\n\tFINAL_CFLAGS+= -D__EXTENSIONS__ -D_XPG6\n\tFINAL_LIBS+= -ldl -lnsl -lsocket -lresolv -lpthread -lrt\nelse\nifeq ($(uname_S),Darwin)\n\t# Darwin\n\tFINAL_LIBS+= -ldl\nelse\nifeq ($(uname_S),AIX)\n        # AIX\n        FINAL_LDFLAGS+= -Wl,-bexpall\n        FINAL_LIBS+=-ldl -pthread -lcrypt -lbsd\nelse\nifeq ($(uname_S),OpenBSD)\n\t# OpenBSD\n\tFINAL_LIBS+= -lpthread\nelse\nifeq ($(uname_S),FreeBSD)\n\t# FreeBSD\n\tFINAL_LIBS+= -lpthread\nelse\n\t# 特别是对Linux的指定\n\t# All the other OSes (notably Linux)\n\t# -rdynamic将链接器将所有符号添加到动态符号表\n\tFINAL_LDFLAGS+= -rdynamic\n\t#pthread库 用于多线程， dl是libdl 动态链接库\n\tFINAL_LIBS+=-ldl -pthread\nendif\nendif\nendif\nendif\nendif\n# Include paths to dependencies\n# -I 指定头文件的目录\nFINAL_CFLAGS+= -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src\n\nifeq ($(MALLOC),tcmalloc)\n\tFINAL_CFLAGS+= -DUSE_TCMALLOC\n\tFINAL_LIBS+= -ltcmalloc\nendif\n\nifeq ($(MALLOC),tcmalloc_minimal)\n\tFINAL_CFLAGS+= -DUSE_TCMALLOC\n\tFINAL_LIBS+= -ltcmalloc_minimal\nendif\n#使用jemalloc的话 链接 libjemalloc.a -I指定jemalloc的头文件目录\nifeq ($(MALLOC),jemalloc)\n\tDEPENDENCY_TARGETS+= jemalloc\n\tFINAL_CFLAGS+= -DUSE_JEMALLOC -I../deps/jemalloc/include\n\tFINAL_LIBS+= ../deps/jemalloc/lib/libjemalloc.a\nendif\n#redis 的gcc -c 选项\nREDIS_CC=$(QUIET_CC)$(CC) $(FINAL_CFLAGS)\n#redis的gcc 链接选项\nREDIS_LD=$(QUIET_LINK)$(CC) $(FINAL_LDFLAGS)\n#redis的安装选项\nREDIS_INSTALL=$(QUIET_INSTALL)$(INSTALL)\n\nCCCOLOR=\"\\033[34m\"\nLINKCOLOR=\"\\033[34;1m\"\nSRCCOLOR=\"\\033[33m\"\nBINCOLOR=\"\\033[37;1m\"\nMAKECOLOR=\"\\033[32;1m\"\nENDCOLOR=\"\\033[0m\"\n\nifndef V\nQUIET_CC = @printf '    %b %b\\n' $(CCCOLOR)CC$(ENDCOLOR) $(SRCCOLOR)$@$(ENDCOLOR) 1>&2;\nQUIET_LINK = @printf '    %b %b\\n' $(LINKCOLOR)LINK$(ENDCOLOR) $(BINCOLOR)$@$(ENDCOLOR) 1>&2;\nQUIET_INSTALL = @printf '    %b %b\\n' $(LINKCOLOR)INSTALL$(ENDCOLOR) $(BINCOLOR)$@$(ENDCOLOR) 1>&2;\nendif\n\nREDIS_SERVER_NAME=redis-server\nREDIS_SENTINEL_NAME=redis-sentinel\n# redis-server的需要使用的对象文件，也就是各个模块\nREDIS_SERVER_OBJ=adlist.o quicklist.o ae.o anet.o dict.o server.o sds.o zmalloc.o lzf_c.o lzf_d.o pqsort.o zipmap.o sha1.o ziplist.o release.o networking.o util.o object.o db.o replication.o rdb.o t_string.o t_list.o t_set.o t_zset.o t_hash.o config.o aof.o pubsub.o multi.o debug.o sort.o intset.o syncio.o cluster.o crc16.o endianconv.o slowlog.o scripting.o bio.o rio.o rand.o memtest.o crc64.o bitops.o sentinel.o notify.o setproctitle.o blocked.o hyperloglog.o latency.o sparkline.o redis-check-rdb.o redis-check-aof.o geo.o lazyfree.o module.o evict.o expire.o geohash.o geohash_helper.o childinfo.o defrag.o siphash.o rax.o\nREDIS_CLI_NAME=redis-cli\n#redis-cli 需要使用的对象文件\nREDIS_CLI_OBJ=anet.o adlist.o redis-cli.o zmalloc.o release.o anet.o ae.o crc64.o\nREDIS_BENCHMARK_NAME=redis-benchmark\n#redis-benchmark需要使用的对象文件\nREDIS_BENCHMARK_OBJ=ae.o anet.o redis-benchmark.o adlist.o zmalloc.o redis-benchmark.o\nREDIS_CHECK_RDB_NAME=redis-check-rdb\nREDIS_CHECK_AOF_NAME=redis-check-aof\n#所有需要需要构建的对象，第一条规则也就是默认规则，不指定规则的话，从第一个规则执行\nall: $(REDIS_SERVER_NAME) $(REDIS_SENTINEL_NAME) $(REDIS_CLI_NAME) $(REDIS_BENCHMARK_NAME) $(REDIS_CHECK_RDB_NAME) $(REDIS_CHECK_AOF_NAME)\n\t@echo \"\"\n\t@echo \"Hint: It's a good idea to run 'make test' ;)\"\n\t@echo \"\"\n#Makefil.dep 的生成\nMakefile.dep:\n\t-$(REDIS_CC) -MM *.c > Makefile.dep 2> /dev/null || true\n\nifeq (0, $(words $(findstring $(MAKECMDGOALS), $(NODEPS))))\n-include Makefile.dep\nendif\n\n.PHONY: all\n#先清除所有编译的输出然后，  将所有设置持久化\npersist-settings: distclean\n\techo STD=$(STD) >> .make-settings\n\techo WARN=$(WARN) >> .make-settings\n\techo OPT=$(OPT) >> .make-settings\n\techo MALLOC=$(MALLOC) >> .make-settings\n\techo CFLAGS=$(CFLAGS) >> .make-settings\n\techo LDFLAGS=$(LDFLAGS) >> .make-settings\n\techo REDIS_CFLAGS=$(REDIS_CFLAGS) >> .make-settings\n\techo REDIS_LDFLAGS=$(REDIS_LDFLAGS) >> .make-settings\n\techo PREV_FINAL_CFLAGS=$(FINAL_CFLAGS) >> .make-settings\n\techo PREV_FINAL_LDFLAGS=$(FINAL_LDFLAGS) >> .make-settings\n\t-(cd ../deps && $(MAKE) $(DEPENDENCY_TARGETS))\n\n.PHONY: persist-settings\n \n# Prerequisites target\n.make-prerequisites:\n\t@touch $@\n\n# Clean everything, persist settings and build dependencies if anything changed\n#当设置有变化的时候清除并重新持久化设置\nifneq ($(strip $(PREV_FINAL_CFLAGS)), $(strip $(FINAL_CFLAGS)))\n.make-prerequisites: persist-settings\nendif\n\nifneq ($(strip $(PREV_FINAL_LDFLAGS)), $(strip $(FINAL_LDFLAGS)))\n.make-prerequisites: persist-settings\nendif\n\n# redis-server\n#redis-server可执行程序的链接，需要链接的静态链接文件包括hiredi和lua,还有final_libs\n$(REDIS_SERVER_NAME): $(REDIS_SERVER_OBJ)\n\t$(REDIS_LD) -o $@ $^ ../deps/hiredis/libhiredis.a ../deps/lua/src/liblua.a $(FINAL_LIBS)\n\n# redis-sentinel\n#redis-sentienl构建\n$(REDIS_SENTINEL_NAME): $(REDIS_SERVER_NAME)\n\t$(REDIS_INSTALL) $(REDIS_SERVER_NAME) $(REDIS_SENTINEL_NAME)\n\n# redis-check-rdb\n#redis-check-rdb的构建\n$(REDIS_CHECK_RDB_NAME): $(REDIS_SERVER_NAME)\n\t$(REDIS_INSTALL) $(REDIS_SERVER_NAME) $(REDIS_CHECK_RDB_NAME)\n\n# redis-check-aof\n#redis-check-aof的构建\n$(REDIS_CHECK_AOF_NAME): $(REDIS_SERVER_NAME)\n\t$(REDIS_INSTALL) $(REDIS_SERVER_NAME) $(REDIS_CHECK_AOF_NAME)\n\n# redis-cli\n#redis-cli的链接\n$(REDIS_CLI_NAME): $(REDIS_CLI_OBJ)\n\t$(REDIS_LD) -o $@ $^ ../deps/hiredis/libhiredis.a ../deps/linenoise/linenoise.o $(FINAL_LIBS)\n\n# redis-benchmark\n#redis-benchmark的链接\n$(REDIS_BENCHMARK_NAME): $(REDIS_BENCHMARK_OBJ)\n\t$(REDIS_LD) -o $@ $^ ../deps/hiredis/libhiredis.a $(FINAL_LIBS)\n\ndict-benchmark: dict.c zmalloc.c sds.c siphash.c\n\t$(REDIS_CC) $(FINAL_CFLAGS) $^ -D DICT_BENCHMARK_MAIN -o $@ $(FINAL_LIBS)\n\n# Because the jemalloc.h header is generated as a part of the jemalloc build,\n# building it should complete before building any other object. Instead of\n# depending on a single artifact, build all dependencies first.\n#将所有点c文件编译成.o文件 自动完成file.c 到file.o的对应\n%.o: %.c .make-prerequisites\n\t$(REDIS_CC) -c $<\n\nclean:\n\trm -rf $(REDIS_SERVER_NAME) $(REDIS_SENTINEL_NAME) $(REDIS_CLI_NAME) $(REDIS_BENCHMARK_NAME) $(REDIS_CHECK_RDB_NAME) $(REDIS_CHECK_AOF_NAME) *.o *.gcda *.gcno *.gcov redis.info lcov-html Makefile.dep dict-benchmark\n\n.PHONY: clean\n\ndistclean: clean\n\t-(cd ../deps && $(MAKE) distclean)\n\t-(rm -f .make-*)\n\n.PHONY: distclean\n\ntest: $(REDIS_SERVER_NAME) $(REDIS_CHECK_AOF_NAME)\n\t@(cd ..; ./runtest)\n\ntest-sentinel: $(REDIS_SENTINEL_NAME)\n\t@(cd ..; ./runtest-sentinel)\n\ncheck: test\n\nlcov:\n\t$(MAKE) gcov\n\t@(set -e; cd ..; ./runtest --clients 1)\n\t@geninfo -o redis.info .\n\t@genhtml --legend -o lcov-html redis.info\n\ntest-sds: sds.c sds.h\n\t$(REDIS_CC) sds.c zmalloc.c -DSDS_TEST_MAIN $(FINAL_LIBS) -o /tmp/sds_test\n\t/tmp/sds_test\n\n.PHONY: lcov\n\nbench: $(REDIS_BENCHMARK_NAME)\n\t./$(REDIS_BENCHMARK_NAME)\n\n32bit:\n\t@echo \"\"\n\t@echo \"WARNING: if it fails under Linux you probably need to install libc6-dev-i386\"\n\t@echo \"\"\n\t$(MAKE) CFLAGS=\"-m32\" LDFLAGS=\"-m32\"\n\ngcov:\n\t$(MAKE) REDIS_CFLAGS=\"-fprofile-arcs -ftest-coverage -DCOVERAGE_TEST\" REDIS_LDFLAGS=\"-fprofile-arcs -ftest-coverage\"\n\nnoopt:\n\t$(MAKE) OPTIMIZATION=\"-O0\"\n\nvalgrind:\n\t$(MAKE) OPTIMIZATION=\"-O0\" MALLOC=\"libc\"\n\nhelgrind:\n\t$(MAKE) OPTIMIZATION=\"-O0\" MALLOC=\"libc\" CFLAGS=\"-D__ATOMIC_VAR_FORCE_SYNC_MACROS\"\n\nsrc/help.h:\n\t@../utils/generate-command-help.rb > help.h\n#将构建完成的可执行程序安装到指定的目录，-p选项自行创建多层目录\ninstall: all\n\t@mkdir -p $(INSTALL_BIN)\n\t$(REDIS_INSTALL) $(REDIS_SERVER_NAME) $(INSTALL_BIN)\n\t$(REDIS_INSTALL) $(REDIS_BENCHMARK_NAME) $(INSTALL_BIN)\n\t$(REDIS_INSTALL) $(REDIS_CLI_NAME) $(INSTALL_BIN)\n\t$(REDIS_INSTALL) $(REDIS_CHECK_RDB_NAME) $(INSTALL_BIN)\n\t$(REDIS_INSTALL) $(REDIS_CHECK_AOF_NAME) $(INSTALL_BIN)\n\t@ln -sf $(REDIS_SERVER_NAME) $(INSTALL_BIN)/$(REDIS_SENTINEL_NAME)\n\n```\n\n`uname_S := $(shell sh -c 'uname -s 2>/dev/null || echo not') ` 这一句-c让后面的字符串命令当成一个完成的命令来执行，从而避免向文件中写入东西的时候权限不够的问题。就算加上sudo也不行，因为里面的命令有>,echo等很多个文件，所以只能用-c来当成一个整体来执行。[参考](https://blog.csdn.net/bobchill/article/details/84647575)\n\n## Makefile思路\n\n总结一下Redis Makefile的思路：\n\n1. 在默认规则也就是第一条规则之前，通过变量设置好编译的相关选项：LDFLAGS，相应的对应关系REDIS_SERVER_OBJ，将规则的target用变量表示好（方便all规则里面用作前置条件），比如REDIS_SERVER_NAME。\n2. 在第一条默认规则 all规则里面指定需要构建的东西\n3. 在第一规则后面先完成链接，再完成编译的规则\n4. 其他功能性规则如clean和distclean\n\n也就是从上到下的结构是总-分。显示整个项目 ，然后是各个模块如redis-server，redis-cli的链接，然后是从源文件到obj文件的编译。\n\n## 参考\n\n<https://blog.csdn.net/bobchill/article/details/84647575>","source":"_posts/2019-04-26-Redis-Makefile注解.md","raw":"---\ntitle: Redis Makefile注解\ndate: 2019-04-26 15:57:19\ncategories: 源码阅读\ntags:\n- redis\n- Makefile\ncopyright: true\n---\n\n# Redis Makefile注解\n\nRedis的makefile是阅读源码的第一步，总共有292行，读起来也是头大，记录之。\n\n<!--more-->\n\n4.02版本源码为：\n\n```makefile\n# Redis Makefile\n# Copyright (C) 2009 Salvatore Sanfilippo <antirez at gmail dot com>\n# This file is released under the BSD license, see the COPYING file\n#\n# The Makefile composes the final FINAL_CFLAGS and FINAL_LDFLAGS using\n# what is needed for Redis plus the standard CFLAGS and LDFLAGS passed.\n# However when building the dependencies (Jemalloc, Lua, Hiredis, ...)\n# CFLAGS and LDFLAGS are propagated to the dependencies, so to pass\n# flags only to be used when compiling / linking Redis itself REDIS_CFLAGS\n# and REDIS_LDFLAGS are used instead (this is the case of 'make gcov').\n#\n# Dependencies are stored in the Makefile.dep file. To rebuild this file\n# Just use 'make dep', but this is only needed by developers.\n\nrelease_hdr := $(shell sh -c './mkreleasehdr.sh')\n# uname -s 获取操作系统的类型 Linux\nuname_S := $(shell sh -c 'uname -s 2>/dev/null || echo not')\n#uname -m 获取机子的架构 x86_64\nuname_M := $(shell sh -c 'uname -m 2>/dev/null || echo not')\n# 优化选项\nOPTIMIZATION?=-O2\n# 依赖目标\nDEPENDENCY_TARGETS=hiredis linenoise lua\nNODEPS:=clean distclean\n\n# Default settings\n# 使用c99标准编译，-pedantic 保证代码规范满足ISO C和ISO C++标准\nSTD=-std=c99 -pedantic -DREDIS_STATIC=''\n# 输出所有编译警告信息 ，Wno-missing-field-initializers 不输出missing-的警告信息\nWARN=-Wall -W -Wno-missing-field-initializers\nOPT=$(OPTIMIZATION)\n\n#默认目录\nPREFIX?=/usr/local\n#安装的默认目录\nINSTALL_BIN=$(PREFIX)/bin\nINSTALL=install\n\n# Default allocator defaults to Jemalloc if it's not an ARM\n#内存分配器的指定 默认libc，linux系统而且架构不是armv61和71的时候则是jemalloc，\nMALLOC=libc\nifneq ($(uname_M),armv6l)\nifneq ($(uname_M),armv7l)\nifeq ($(uname_S),Linux)\n\tMALLOC=jemalloc\nendif\nendif\nendif\n\n# To get ARM stack traces if Redis crashes we need a special C flag.\nifneq (,$(findstring armv,$(uname_M)))\n        CFLAGS+=-funwind-tables\nendif\n\n# Backwards compatibility for selecting an allocator\n#编译的时候指定内存分配器\nifeq ($(USE_TCMALLOC),yes)\n\tMALLOC=tcmalloc\nendif\n\nifeq ($(USE_TCMALLOC_MINIMAL),yes)\n\tMALLOC=tcmalloc_minimal\nendif\n\nifeq ($(USE_JEMALLOC),yes)\n\tMALLOC=jemalloc\nendif\n\nifeq ($(USE_JEMALLOC),no)\n\tMALLOC=libc\nendif\n\n# Override default settings if possible\n-include .make-settings\n# 最终的编译选项CFLAGS是-c的选项，LDFLAGS是链接的选项\nFINAL_CFLAGS=$(STD) $(WARN) $(OPT) $(DEBUG) $(CFLAGS) $(REDIS_CFLAGS)\nFINAL_LDFLAGS=$(LDFLAGS) $(REDIS_LDFLAGS) $(DEBUG)\n# m这个lib是libmath 也就是math的链接\nFINAL_LIBS=-lm\n# 调试信息\nDEBUG=-g -ggdb\n#根据操作系统继续指定编译选项\nifeq ($(uname_S),SunOS)\n\t# SunOS\n        ifneq ($(@@),32bit)\n\t\tCFLAGS+= -m64\n\t\tLDFLAGS+= -m64\n\tendif\n\tDEBUG=-g\n\tDEBUG_FLAGS=-g\n\texport CFLAGS LDFLAGS DEBUG DEBUG_FLAGS\n\tINSTALL=cp -pf\n\tFINAL_CFLAGS+= -D__EXTENSIONS__ -D_XPG6\n\tFINAL_LIBS+= -ldl -lnsl -lsocket -lresolv -lpthread -lrt\nelse\nifeq ($(uname_S),Darwin)\n\t# Darwin\n\tFINAL_LIBS+= -ldl\nelse\nifeq ($(uname_S),AIX)\n        # AIX\n        FINAL_LDFLAGS+= -Wl,-bexpall\n        FINAL_LIBS+=-ldl -pthread -lcrypt -lbsd\nelse\nifeq ($(uname_S),OpenBSD)\n\t# OpenBSD\n\tFINAL_LIBS+= -lpthread\nelse\nifeq ($(uname_S),FreeBSD)\n\t# FreeBSD\n\tFINAL_LIBS+= -lpthread\nelse\n\t# 特别是对Linux的指定\n\t# All the other OSes (notably Linux)\n\t# -rdynamic将链接器将所有符号添加到动态符号表\n\tFINAL_LDFLAGS+= -rdynamic\n\t#pthread库 用于多线程， dl是libdl 动态链接库\n\tFINAL_LIBS+=-ldl -pthread\nendif\nendif\nendif\nendif\nendif\n# Include paths to dependencies\n# -I 指定头文件的目录\nFINAL_CFLAGS+= -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src\n\nifeq ($(MALLOC),tcmalloc)\n\tFINAL_CFLAGS+= -DUSE_TCMALLOC\n\tFINAL_LIBS+= -ltcmalloc\nendif\n\nifeq ($(MALLOC),tcmalloc_minimal)\n\tFINAL_CFLAGS+= -DUSE_TCMALLOC\n\tFINAL_LIBS+= -ltcmalloc_minimal\nendif\n#使用jemalloc的话 链接 libjemalloc.a -I指定jemalloc的头文件目录\nifeq ($(MALLOC),jemalloc)\n\tDEPENDENCY_TARGETS+= jemalloc\n\tFINAL_CFLAGS+= -DUSE_JEMALLOC -I../deps/jemalloc/include\n\tFINAL_LIBS+= ../deps/jemalloc/lib/libjemalloc.a\nendif\n#redis 的gcc -c 选项\nREDIS_CC=$(QUIET_CC)$(CC) $(FINAL_CFLAGS)\n#redis的gcc 链接选项\nREDIS_LD=$(QUIET_LINK)$(CC) $(FINAL_LDFLAGS)\n#redis的安装选项\nREDIS_INSTALL=$(QUIET_INSTALL)$(INSTALL)\n\nCCCOLOR=\"\\033[34m\"\nLINKCOLOR=\"\\033[34;1m\"\nSRCCOLOR=\"\\033[33m\"\nBINCOLOR=\"\\033[37;1m\"\nMAKECOLOR=\"\\033[32;1m\"\nENDCOLOR=\"\\033[0m\"\n\nifndef V\nQUIET_CC = @printf '    %b %b\\n' $(CCCOLOR)CC$(ENDCOLOR) $(SRCCOLOR)$@$(ENDCOLOR) 1>&2;\nQUIET_LINK = @printf '    %b %b\\n' $(LINKCOLOR)LINK$(ENDCOLOR) $(BINCOLOR)$@$(ENDCOLOR) 1>&2;\nQUIET_INSTALL = @printf '    %b %b\\n' $(LINKCOLOR)INSTALL$(ENDCOLOR) $(BINCOLOR)$@$(ENDCOLOR) 1>&2;\nendif\n\nREDIS_SERVER_NAME=redis-server\nREDIS_SENTINEL_NAME=redis-sentinel\n# redis-server的需要使用的对象文件，也就是各个模块\nREDIS_SERVER_OBJ=adlist.o quicklist.o ae.o anet.o dict.o server.o sds.o zmalloc.o lzf_c.o lzf_d.o pqsort.o zipmap.o sha1.o ziplist.o release.o networking.o util.o object.o db.o replication.o rdb.o t_string.o t_list.o t_set.o t_zset.o t_hash.o config.o aof.o pubsub.o multi.o debug.o sort.o intset.o syncio.o cluster.o crc16.o endianconv.o slowlog.o scripting.o bio.o rio.o rand.o memtest.o crc64.o bitops.o sentinel.o notify.o setproctitle.o blocked.o hyperloglog.o latency.o sparkline.o redis-check-rdb.o redis-check-aof.o geo.o lazyfree.o module.o evict.o expire.o geohash.o geohash_helper.o childinfo.o defrag.o siphash.o rax.o\nREDIS_CLI_NAME=redis-cli\n#redis-cli 需要使用的对象文件\nREDIS_CLI_OBJ=anet.o adlist.o redis-cli.o zmalloc.o release.o anet.o ae.o crc64.o\nREDIS_BENCHMARK_NAME=redis-benchmark\n#redis-benchmark需要使用的对象文件\nREDIS_BENCHMARK_OBJ=ae.o anet.o redis-benchmark.o adlist.o zmalloc.o redis-benchmark.o\nREDIS_CHECK_RDB_NAME=redis-check-rdb\nREDIS_CHECK_AOF_NAME=redis-check-aof\n#所有需要需要构建的对象，第一条规则也就是默认规则，不指定规则的话，从第一个规则执行\nall: $(REDIS_SERVER_NAME) $(REDIS_SENTINEL_NAME) $(REDIS_CLI_NAME) $(REDIS_BENCHMARK_NAME) $(REDIS_CHECK_RDB_NAME) $(REDIS_CHECK_AOF_NAME)\n\t@echo \"\"\n\t@echo \"Hint: It's a good idea to run 'make test' ;)\"\n\t@echo \"\"\n#Makefil.dep 的生成\nMakefile.dep:\n\t-$(REDIS_CC) -MM *.c > Makefile.dep 2> /dev/null || true\n\nifeq (0, $(words $(findstring $(MAKECMDGOALS), $(NODEPS))))\n-include Makefile.dep\nendif\n\n.PHONY: all\n#先清除所有编译的输出然后，  将所有设置持久化\npersist-settings: distclean\n\techo STD=$(STD) >> .make-settings\n\techo WARN=$(WARN) >> .make-settings\n\techo OPT=$(OPT) >> .make-settings\n\techo MALLOC=$(MALLOC) >> .make-settings\n\techo CFLAGS=$(CFLAGS) >> .make-settings\n\techo LDFLAGS=$(LDFLAGS) >> .make-settings\n\techo REDIS_CFLAGS=$(REDIS_CFLAGS) >> .make-settings\n\techo REDIS_LDFLAGS=$(REDIS_LDFLAGS) >> .make-settings\n\techo PREV_FINAL_CFLAGS=$(FINAL_CFLAGS) >> .make-settings\n\techo PREV_FINAL_LDFLAGS=$(FINAL_LDFLAGS) >> .make-settings\n\t-(cd ../deps && $(MAKE) $(DEPENDENCY_TARGETS))\n\n.PHONY: persist-settings\n \n# Prerequisites target\n.make-prerequisites:\n\t@touch $@\n\n# Clean everything, persist settings and build dependencies if anything changed\n#当设置有变化的时候清除并重新持久化设置\nifneq ($(strip $(PREV_FINAL_CFLAGS)), $(strip $(FINAL_CFLAGS)))\n.make-prerequisites: persist-settings\nendif\n\nifneq ($(strip $(PREV_FINAL_LDFLAGS)), $(strip $(FINAL_LDFLAGS)))\n.make-prerequisites: persist-settings\nendif\n\n# redis-server\n#redis-server可执行程序的链接，需要链接的静态链接文件包括hiredi和lua,还有final_libs\n$(REDIS_SERVER_NAME): $(REDIS_SERVER_OBJ)\n\t$(REDIS_LD) -o $@ $^ ../deps/hiredis/libhiredis.a ../deps/lua/src/liblua.a $(FINAL_LIBS)\n\n# redis-sentinel\n#redis-sentienl构建\n$(REDIS_SENTINEL_NAME): $(REDIS_SERVER_NAME)\n\t$(REDIS_INSTALL) $(REDIS_SERVER_NAME) $(REDIS_SENTINEL_NAME)\n\n# redis-check-rdb\n#redis-check-rdb的构建\n$(REDIS_CHECK_RDB_NAME): $(REDIS_SERVER_NAME)\n\t$(REDIS_INSTALL) $(REDIS_SERVER_NAME) $(REDIS_CHECK_RDB_NAME)\n\n# redis-check-aof\n#redis-check-aof的构建\n$(REDIS_CHECK_AOF_NAME): $(REDIS_SERVER_NAME)\n\t$(REDIS_INSTALL) $(REDIS_SERVER_NAME) $(REDIS_CHECK_AOF_NAME)\n\n# redis-cli\n#redis-cli的链接\n$(REDIS_CLI_NAME): $(REDIS_CLI_OBJ)\n\t$(REDIS_LD) -o $@ $^ ../deps/hiredis/libhiredis.a ../deps/linenoise/linenoise.o $(FINAL_LIBS)\n\n# redis-benchmark\n#redis-benchmark的链接\n$(REDIS_BENCHMARK_NAME): $(REDIS_BENCHMARK_OBJ)\n\t$(REDIS_LD) -o $@ $^ ../deps/hiredis/libhiredis.a $(FINAL_LIBS)\n\ndict-benchmark: dict.c zmalloc.c sds.c siphash.c\n\t$(REDIS_CC) $(FINAL_CFLAGS) $^ -D DICT_BENCHMARK_MAIN -o $@ $(FINAL_LIBS)\n\n# Because the jemalloc.h header is generated as a part of the jemalloc build,\n# building it should complete before building any other object. Instead of\n# depending on a single artifact, build all dependencies first.\n#将所有点c文件编译成.o文件 自动完成file.c 到file.o的对应\n%.o: %.c .make-prerequisites\n\t$(REDIS_CC) -c $<\n\nclean:\n\trm -rf $(REDIS_SERVER_NAME) $(REDIS_SENTINEL_NAME) $(REDIS_CLI_NAME) $(REDIS_BENCHMARK_NAME) $(REDIS_CHECK_RDB_NAME) $(REDIS_CHECK_AOF_NAME) *.o *.gcda *.gcno *.gcov redis.info lcov-html Makefile.dep dict-benchmark\n\n.PHONY: clean\n\ndistclean: clean\n\t-(cd ../deps && $(MAKE) distclean)\n\t-(rm -f .make-*)\n\n.PHONY: distclean\n\ntest: $(REDIS_SERVER_NAME) $(REDIS_CHECK_AOF_NAME)\n\t@(cd ..; ./runtest)\n\ntest-sentinel: $(REDIS_SENTINEL_NAME)\n\t@(cd ..; ./runtest-sentinel)\n\ncheck: test\n\nlcov:\n\t$(MAKE) gcov\n\t@(set -e; cd ..; ./runtest --clients 1)\n\t@geninfo -o redis.info .\n\t@genhtml --legend -o lcov-html redis.info\n\ntest-sds: sds.c sds.h\n\t$(REDIS_CC) sds.c zmalloc.c -DSDS_TEST_MAIN $(FINAL_LIBS) -o /tmp/sds_test\n\t/tmp/sds_test\n\n.PHONY: lcov\n\nbench: $(REDIS_BENCHMARK_NAME)\n\t./$(REDIS_BENCHMARK_NAME)\n\n32bit:\n\t@echo \"\"\n\t@echo \"WARNING: if it fails under Linux you probably need to install libc6-dev-i386\"\n\t@echo \"\"\n\t$(MAKE) CFLAGS=\"-m32\" LDFLAGS=\"-m32\"\n\ngcov:\n\t$(MAKE) REDIS_CFLAGS=\"-fprofile-arcs -ftest-coverage -DCOVERAGE_TEST\" REDIS_LDFLAGS=\"-fprofile-arcs -ftest-coverage\"\n\nnoopt:\n\t$(MAKE) OPTIMIZATION=\"-O0\"\n\nvalgrind:\n\t$(MAKE) OPTIMIZATION=\"-O0\" MALLOC=\"libc\"\n\nhelgrind:\n\t$(MAKE) OPTIMIZATION=\"-O0\" MALLOC=\"libc\" CFLAGS=\"-D__ATOMIC_VAR_FORCE_SYNC_MACROS\"\n\nsrc/help.h:\n\t@../utils/generate-command-help.rb > help.h\n#将构建完成的可执行程序安装到指定的目录，-p选项自行创建多层目录\ninstall: all\n\t@mkdir -p $(INSTALL_BIN)\n\t$(REDIS_INSTALL) $(REDIS_SERVER_NAME) $(INSTALL_BIN)\n\t$(REDIS_INSTALL) $(REDIS_BENCHMARK_NAME) $(INSTALL_BIN)\n\t$(REDIS_INSTALL) $(REDIS_CLI_NAME) $(INSTALL_BIN)\n\t$(REDIS_INSTALL) $(REDIS_CHECK_RDB_NAME) $(INSTALL_BIN)\n\t$(REDIS_INSTALL) $(REDIS_CHECK_AOF_NAME) $(INSTALL_BIN)\n\t@ln -sf $(REDIS_SERVER_NAME) $(INSTALL_BIN)/$(REDIS_SENTINEL_NAME)\n\n```\n\n`uname_S := $(shell sh -c 'uname -s 2>/dev/null || echo not') ` 这一句-c让后面的字符串命令当成一个完成的命令来执行，从而避免向文件中写入东西的时候权限不够的问题。就算加上sudo也不行，因为里面的命令有>,echo等很多个文件，所以只能用-c来当成一个整体来执行。[参考](https://blog.csdn.net/bobchill/article/details/84647575)\n\n## Makefile思路\n\n总结一下Redis Makefile的思路：\n\n1. 在默认规则也就是第一条规则之前，通过变量设置好编译的相关选项：LDFLAGS，相应的对应关系REDIS_SERVER_OBJ，将规则的target用变量表示好（方便all规则里面用作前置条件），比如REDIS_SERVER_NAME。\n2. 在第一条默认规则 all规则里面指定需要构建的东西\n3. 在第一规则后面先完成链接，再完成编译的规则\n4. 其他功能性规则如clean和distclean\n\n也就是从上到下的结构是总-分。显示整个项目 ，然后是各个模块如redis-server，redis-cli的链接，然后是从源文件到obj文件的编译。\n\n## 参考\n\n<https://blog.csdn.net/bobchill/article/details/84647575>","slug":"2019-04-26-Redis-Makefile注解","published":1,"updated":"2019-11-08T13:13:23.742Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2yelxhf000vm8tz89pkozz7","content":"<h1 id=\"Redis-Makefile注解\"><a href=\"#Redis-Makefile注解\" class=\"headerlink\" title=\"Redis Makefile注解\"></a>Redis Makefile注解</h1><p>Redis的makefile是阅读源码的第一步，总共有292行，读起来也是头大，记录之。</p>\n<a id=\"more\"></a>\n<p>4.02版本源码为：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br><span class=\"line\">291</span><br><span class=\"line\">292</span><br><span class=\"line\">293</span><br><span class=\"line\">294</span><br><span class=\"line\">295</span><br><span class=\"line\">296</span><br><span class=\"line\">297</span><br><span class=\"line\">298</span><br><span class=\"line\">299</span><br><span class=\"line\">300</span><br><span class=\"line\">301</span><br><span class=\"line\">302</span><br><span class=\"line\">303</span><br><span class=\"line\">304</span><br><span class=\"line\">305</span><br><span class=\"line\">306</span><br><span class=\"line\">307</span><br><span class=\"line\">308</span><br><span class=\"line\">309</span><br><span class=\"line\">310</span><br><span class=\"line\">311</span><br><span class=\"line\">312</span><br><span class=\"line\">313</span><br><span class=\"line\">314</span><br><span class=\"line\">315</span><br><span class=\"line\">316</span><br><span class=\"line\">317</span><br><span class=\"line\">318</span><br><span class=\"line\">319</span><br><span class=\"line\">320</span><br><span class=\"line\">321</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Redis Makefile</span></span><br><span class=\"line\"><span class=\"comment\"># Copyright (C) 2009 Salvatore Sanfilippo &lt;antirez at gmail dot com&gt;</span></span><br><span class=\"line\"><span class=\"comment\"># This file is released under the BSD license, see the COPYING file</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># The Makefile composes the final FINAL_CFLAGS and FINAL_LDFLAGS using</span></span><br><span class=\"line\"><span class=\"comment\"># what is needed for Redis plus the standard CFLAGS and LDFLAGS passed.</span></span><br><span class=\"line\"><span class=\"comment\"># However when building the dependencies (Jemalloc, Lua, Hiredis, ...)</span></span><br><span class=\"line\"><span class=\"comment\"># CFLAGS and LDFLAGS are propagated to the dependencies, so to pass</span></span><br><span class=\"line\"><span class=\"comment\"># flags only to be used when compiling / linking Redis itself REDIS_CFLAGS</span></span><br><span class=\"line\"><span class=\"comment\"># and REDIS_LDFLAGS are used instead (this is the case of 'make gcov').</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># Dependencies are stored in the Makefile.dep file. To rebuild this file</span></span><br><span class=\"line\"><span class=\"comment\"># Just use 'make dep', but this is only needed by developers.</span></span><br><span class=\"line\"></span><br><span class=\"line\">release_hdr := <span class=\"variable\">$(<span class=\"built_in\">shell</span> sh -c './mkreleasehdr.sh')</span></span><br><span class=\"line\"><span class=\"comment\"># uname -s 获取操作系统的类型 Linux</span></span><br><span class=\"line\">uname_S := <span class=\"variable\">$(<span class=\"built_in\">shell</span> sh -c 'uname -s 2&gt;/dev/null || echo not')</span></span><br><span class=\"line\"><span class=\"comment\">#uname -m 获取机子的架构 x86_64</span></span><br><span class=\"line\">uname_M := <span class=\"variable\">$(<span class=\"built_in\">shell</span> sh -c 'uname -m 2&gt;/dev/null || echo not')</span></span><br><span class=\"line\"><span class=\"comment\"># 优化选项</span></span><br><span class=\"line\">OPTIMIZATION?=-O2</span><br><span class=\"line\"><span class=\"comment\"># 依赖目标</span></span><br><span class=\"line\">DEPENDENCY_TARGETS=hiredis linenoise lua</span><br><span class=\"line\">NODEPS:=clean distclean</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Default settings</span></span><br><span class=\"line\"><span class=\"comment\"># 使用c99标准编译，-pedantic 保证代码规范满足ISO C和ISO C++标准</span></span><br><span class=\"line\">STD=-std=c99 -pedantic -DREDIS_STATIC=''</span><br><span class=\"line\"><span class=\"comment\"># 输出所有编译警告信息 ，Wno-missing-field-initializers 不输出missing-的警告信息</span></span><br><span class=\"line\">WARN=-Wall -W -Wno-missing-field-initializers</span><br><span class=\"line\">OPT=<span class=\"variable\">$(OPTIMIZATION)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#默认目录</span></span><br><span class=\"line\">PREFIX?=/usr/local</span><br><span class=\"line\"><span class=\"comment\">#安装的默认目录</span></span><br><span class=\"line\">INSTALL_BIN=<span class=\"variable\">$(PREFIX)</span>/bin</span><br><span class=\"line\">INSTALL=install</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Default allocator defaults to Jemalloc if it's not an ARM</span></span><br><span class=\"line\"><span class=\"comment\">#内存分配器的指定 默认libc，linux系统而且架构不是armv61和71的时候则是jemalloc，</span></span><br><span class=\"line\">MALLOC=libc</span><br><span class=\"line\"><span class=\"keyword\">ifneq</span> (<span class=\"variable\">$(uname_M)</span>,armv6l)</span><br><span class=\"line\"><span class=\"keyword\">ifneq</span> (<span class=\"variable\">$(uname_M)</span>,armv7l)</span><br><span class=\"line\"><span class=\"keyword\">ifeq</span> (<span class=\"variable\">$(uname_S)</span>,Linux)</span><br><span class=\"line\">\tMALLOC=jemalloc</span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># To get ARM stack traces if Redis crashes we need a special C flag.</span></span><br><span class=\"line\"><span class=\"keyword\">ifneq</span> (,<span class=\"variable\">$(<span class=\"built_in\">findstring</span> armv,<span class=\"variable\">$(uname_M)</span>)</span>)</span><br><span class=\"line\">        CFLAGS+=-funwind-tables</span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Backwards compatibility for selecting an allocator</span></span><br><span class=\"line\"><span class=\"comment\">#编译的时候指定内存分配器</span></span><br><span class=\"line\"><span class=\"keyword\">ifeq</span> (<span class=\"variable\">$(USE_TCMALLOC)</span>,yes)</span><br><span class=\"line\">\tMALLOC=tcmalloc</span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ifeq</span> (<span class=\"variable\">$(USE_TCMALLOC_MINIMAL)</span>,yes)</span><br><span class=\"line\">\tMALLOC=tcmalloc_minimal</span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ifeq</span> (<span class=\"variable\">$(USE_JEMALLOC)</span>,yes)</span><br><span class=\"line\">\tMALLOC=jemalloc</span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ifeq</span> (<span class=\"variable\">$(USE_JEMALLOC)</span>,no)</span><br><span class=\"line\">\tMALLOC=libc</span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Override default settings if possible</span></span><br><span class=\"line\"><span class=\"keyword\">-include</span> .make-settings</span><br><span class=\"line\"><span class=\"comment\"># 最终的编译选项CFLAGS是-c的选项，LDFLAGS是链接的选项</span></span><br><span class=\"line\">FINAL_CFLAGS=<span class=\"variable\">$(STD)</span> <span class=\"variable\">$(WARN)</span> <span class=\"variable\">$(OPT)</span> <span class=\"variable\">$(DEBUG)</span> <span class=\"variable\">$(CFLAGS)</span> <span class=\"variable\">$(REDIS_CFLAGS)</span></span><br><span class=\"line\">FINAL_LDFLAGS=<span class=\"variable\">$(LDFLAGS)</span> <span class=\"variable\">$(REDIS_LDFLAGS)</span> <span class=\"variable\">$(DEBUG)</span></span><br><span class=\"line\"><span class=\"comment\"># m这个lib是libmath 也就是math的链接</span></span><br><span class=\"line\">FINAL_LIBS=-lm</span><br><span class=\"line\"><span class=\"comment\"># 调试信息</span></span><br><span class=\"line\">DEBUG=-g -ggdb</span><br><span class=\"line\"><span class=\"comment\">#根据操作系统继续指定编译选项</span></span><br><span class=\"line\"><span class=\"keyword\">ifeq</span> (<span class=\"variable\">$(uname_S)</span>,SunOS)</span><br><span class=\"line\">\t<span class=\"comment\"># SunOS</span></span><br><span class=\"line\">        <span class=\"keyword\">ifneq</span> ($(@@),32bit)</span><br><span class=\"line\">\t\tCFLAGS+= -m64</span><br><span class=\"line\">\t\tLDFLAGS+= -m64</span><br><span class=\"line\">\t<span class=\"keyword\">endif</span></span><br><span class=\"line\">\tDEBUG=-g</span><br><span class=\"line\">\tDEBUG_FLAGS=-g</span><br><span class=\"line\">\t<span class=\"keyword\">export</span> CFLAGS LDFLAGS DEBUG DEBUG_FLAGS</span><br><span class=\"line\">\tINSTALL=cp -pf</span><br><span class=\"line\">\tFINAL_CFLAGS+= -D__EXTENSIONS__ -D_XPG6</span><br><span class=\"line\">\tFINAL_LIBS+= -ldl -lnsl -lsocket -lresolv -lpthread -lrt</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\"><span class=\"keyword\">ifeq</span> (<span class=\"variable\">$(uname_S)</span>,Darwin)</span><br><span class=\"line\">\t<span class=\"comment\"># Darwin</span></span><br><span class=\"line\">\tFINAL_LIBS+= -ldl</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\"><span class=\"keyword\">ifeq</span> (<span class=\"variable\">$(uname_S)</span>,AIX)</span><br><span class=\"line\">        <span class=\"comment\"># AIX</span></span><br><span class=\"line\">        FINAL_LDFLAGS+= -Wl,-bexpall</span><br><span class=\"line\">        FINAL_LIBS+=-ldl -pthread -lcrypt -lbsd</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\"><span class=\"keyword\">ifeq</span> (<span class=\"variable\">$(uname_S)</span>,OpenBSD)</span><br><span class=\"line\">\t<span class=\"comment\"># OpenBSD</span></span><br><span class=\"line\">\tFINAL_LIBS+= -lpthread</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\"><span class=\"keyword\">ifeq</span> (<span class=\"variable\">$(uname_S)</span>,FreeBSD)</span><br><span class=\"line\">\t<span class=\"comment\"># FreeBSD</span></span><br><span class=\"line\">\tFINAL_LIBS+= -lpthread</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">\t<span class=\"comment\"># 特别是对Linux的指定</span></span><br><span class=\"line\">\t<span class=\"comment\"># All the other OSes (notably Linux)</span></span><br><span class=\"line\">\t<span class=\"comment\"># -rdynamic将链接器将所有符号添加到动态符号表</span></span><br><span class=\"line\">\tFINAL_LDFLAGS+= -rdynamic</span><br><span class=\"line\">\t<span class=\"comment\">#pthread库 用于多线程， dl是libdl 动态链接库</span></span><br><span class=\"line\">\tFINAL_LIBS+=-ldl -pthread</span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"><span class=\"comment\"># Include paths to dependencies</span></span><br><span class=\"line\"><span class=\"comment\"># -I 指定头文件的目录</span></span><br><span class=\"line\">FINAL_CFLAGS+= -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ifeq</span> (<span class=\"variable\">$(MALLOC)</span>,tcmalloc)</span><br><span class=\"line\">\tFINAL_CFLAGS+= -DUSE_TCMALLOC</span><br><span class=\"line\">\tFINAL_LIBS+= -ltcmalloc</span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ifeq</span> (<span class=\"variable\">$(MALLOC)</span>,tcmalloc_minimal)</span><br><span class=\"line\">\tFINAL_CFLAGS+= -DUSE_TCMALLOC</span><br><span class=\"line\">\tFINAL_LIBS+= -ltcmalloc_minimal</span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"><span class=\"comment\">#使用jemalloc的话 链接 libjemalloc.a -I指定jemalloc的头文件目录</span></span><br><span class=\"line\"><span class=\"keyword\">ifeq</span> (<span class=\"variable\">$(MALLOC)</span>,jemalloc)</span><br><span class=\"line\">\tDEPENDENCY_TARGETS+= jemalloc</span><br><span class=\"line\">\tFINAL_CFLAGS+= -DUSE_JEMALLOC -I../deps/jemalloc/<span class=\"keyword\">include</span></span><br><span class=\"line\">\tFINAL_LIBS+= ../deps/jemalloc/lib/libjemalloc.a</span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"><span class=\"comment\">#redis 的gcc -c 选项</span></span><br><span class=\"line\">REDIS_CC=<span class=\"variable\">$(QUIET_CC)</span><span class=\"variable\">$(CC)</span> <span class=\"variable\">$(FINAL_CFLAGS)</span></span><br><span class=\"line\"><span class=\"comment\">#redis的gcc 链接选项</span></span><br><span class=\"line\">REDIS_LD=<span class=\"variable\">$(QUIET_LINK)</span><span class=\"variable\">$(CC)</span> <span class=\"variable\">$(FINAL_LDFLAGS)</span></span><br><span class=\"line\"><span class=\"comment\">#redis的安装选项</span></span><br><span class=\"line\">REDIS_INSTALL=<span class=\"variable\">$(QUIET_INSTALL)</span><span class=\"variable\">$(INSTALL)</span></span><br><span class=\"line\"></span><br><span class=\"line\">CCCOLOR=<span class=\"string\">\"\\033[34m\"</span></span><br><span class=\"line\">LINKCOLOR=<span class=\"string\">\"\\033[34;1m\"</span></span><br><span class=\"line\">SRCCOLOR=<span class=\"string\">\"\\033[33m\"</span></span><br><span class=\"line\">BINCOLOR=<span class=\"string\">\"\\033[37;1m\"</span></span><br><span class=\"line\">MAKECOLOR=<span class=\"string\">\"\\033[32;1m\"</span></span><br><span class=\"line\">ENDCOLOR=<span class=\"string\">\"\\033[0m\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ifndef</span> V</span><br><span class=\"line\">QUIET_CC = @printf '    %b %b\\n' <span class=\"variable\">$(CCCOLOR)</span>CC<span class=\"variable\">$(ENDCOLOR)</span> <span class=\"variable\">$(SRCCOLOR)</span><span class=\"variable\">$@</span><span class=\"variable\">$(ENDCOLOR)</span> 1&gt;&amp;2;</span><br><span class=\"line\">QUIET_LINK = @printf '    %b %b\\n' <span class=\"variable\">$(LINKCOLOR)</span>LINK<span class=\"variable\">$(ENDCOLOR)</span> <span class=\"variable\">$(BINCOLOR)</span><span class=\"variable\">$@</span><span class=\"variable\">$(ENDCOLOR)</span> 1&gt;&amp;2;</span><br><span class=\"line\">QUIET_INSTALL = @printf '    %b %b\\n' <span class=\"variable\">$(LINKCOLOR)</span>INSTALL<span class=\"variable\">$(ENDCOLOR)</span> <span class=\"variable\">$(BINCOLOR)</span><span class=\"variable\">$@</span><span class=\"variable\">$(ENDCOLOR)</span> 1&gt;&amp;2;</span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"></span><br><span class=\"line\">REDIS_SERVER_NAME=redis-server</span><br><span class=\"line\">REDIS_SENTINEL_NAME=redis-sentinel</span><br><span class=\"line\"><span class=\"comment\"># redis-server的需要使用的对象文件，也就是各个模块</span></span><br><span class=\"line\">REDIS_SERVER_OBJ=adlist.o quicklist.o ae.o anet.o dict.o server.o sds.o zmalloc.o lzf_c.o lzf_d.o pqsort.o zipmap.o sha1.o ziplist.o release.o networking.o util.o object.o db.o replication.o rdb.o t_string.o t_list.o t_set.o t_zset.o t_hash.o config.o aof.o pubsub.o multi.o debug.o sort.o intset.o syncio.o cluster.o crc16.o endianconv.o slowlog.o scripting.o bio.o rio.o rand.o memtest.o crc64.o bitops.o sentinel.o notify.o setproctitle.o blocked.o hyperloglog.o latency.o sparkline.o redis-check-rdb.o redis-check-aof.o geo.o lazyfree.o module.o evict.o expire.o geohash.o geohash_helper.o childinfo.o defrag.o siphash.o rax.o</span><br><span class=\"line\">REDIS_CLI_NAME=redis-cli</span><br><span class=\"line\"><span class=\"comment\">#redis-cli 需要使用的对象文件</span></span><br><span class=\"line\">REDIS_CLI_OBJ=anet.o adlist.o redis-cli.o zmalloc.o release.o anet.o ae.o crc64.o</span><br><span class=\"line\">REDIS_BENCHMARK_NAME=redis-benchmark</span><br><span class=\"line\"><span class=\"comment\">#redis-benchmark需要使用的对象文件</span></span><br><span class=\"line\">REDIS_BENCHMARK_OBJ=ae.o anet.o redis-benchmark.o adlist.o zmalloc.o redis-benchmark.o</span><br><span class=\"line\">REDIS_CHECK_RDB_NAME=redis-check-rdb</span><br><span class=\"line\">REDIS_CHECK_AOF_NAME=redis-check-aof</span><br><span class=\"line\"><span class=\"comment\">#所有需要需要构建的对象，第一条规则也就是默认规则，不指定规则的话，从第一个规则执行</span></span><br><span class=\"line\"><span class=\"section\">all: <span class=\"variable\">$(REDIS_SERVER_NAME)</span> <span class=\"variable\">$(REDIS_SENTINEL_NAME)</span> <span class=\"variable\">$(REDIS_CLI_NAME)</span> <span class=\"variable\">$(REDIS_BENCHMARK_NAME)</span> <span class=\"variable\">$(REDIS_CHECK_RDB_NAME)</span> <span class=\"variable\">$(REDIS_CHECK_AOF_NAME)</span></span></span><br><span class=\"line\">\t@echo <span class=\"string\">\"\"</span></span><br><span class=\"line\">\t@echo <span class=\"string\">\"Hint: It's a good idea to run 'make test' ;)\"</span></span><br><span class=\"line\">\t@echo <span class=\"string\">\"\"</span></span><br><span class=\"line\"><span class=\"comment\">#Makefil.dep 的生成</span></span><br><span class=\"line\"><span class=\"section\">Makefile.dep:</span></span><br><span class=\"line\">\t-<span class=\"variable\">$(REDIS_CC)</span> -MM *.c &gt; Makefile.dep 2&gt; /dev/null || true</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ifeq</span> (0, <span class=\"variable\">$(words $(<span class=\"built_in\">findstring</span> <span class=\"variable\">$(MAKECMDGOALS)</span>, <span class=\"variable\">$(NODEPS)</span>)</span>))</span><br><span class=\"line\"><span class=\"keyword\">-include</span> Makefile.dep</span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\"><span class=\"meta-keyword\">.PHONY</span>: all</span></span><br><span class=\"line\"><span class=\"comment\">#先清除所有编译的输出然后，  将所有设置持久化</span></span><br><span class=\"line\"><span class=\"section\">persist-settings: distclean</span></span><br><span class=\"line\">\techo STD=<span class=\"variable\">$(STD)</span> &gt;&gt; .make-settings</span><br><span class=\"line\">\techo WARN=<span class=\"variable\">$(WARN)</span> &gt;&gt; .make-settings</span><br><span class=\"line\">\techo OPT=<span class=\"variable\">$(OPT)</span> &gt;&gt; .make-settings</span><br><span class=\"line\">\techo MALLOC=<span class=\"variable\">$(MALLOC)</span> &gt;&gt; .make-settings</span><br><span class=\"line\">\techo CFLAGS=<span class=\"variable\">$(CFLAGS)</span> &gt;&gt; .make-settings</span><br><span class=\"line\">\techo LDFLAGS=<span class=\"variable\">$(LDFLAGS)</span> &gt;&gt; .make-settings</span><br><span class=\"line\">\techo REDIS_CFLAGS=<span class=\"variable\">$(REDIS_CFLAGS)</span> &gt;&gt; .make-settings</span><br><span class=\"line\">\techo REDIS_LDFLAGS=<span class=\"variable\">$(REDIS_LDFLAGS)</span> &gt;&gt; .make-settings</span><br><span class=\"line\">\techo PREV_FINAL_CFLAGS=<span class=\"variable\">$(FINAL_CFLAGS)</span> &gt;&gt; .make-settings</span><br><span class=\"line\">\techo PREV_FINAL_LDFLAGS=<span class=\"variable\">$(FINAL_LDFLAGS)</span> &gt;&gt; .make-settings</span><br><span class=\"line\">\t-(cd ../deps &amp;&amp; <span class=\"variable\">$(MAKE)</span> <span class=\"variable\">$(DEPENDENCY_TARGETS)</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\"><span class=\"meta-keyword\">.PHONY</span>: persist-settings</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># Prerequisites target</span></span><br><span class=\"line\"><span class=\"section\">.make-prerequisites:</span></span><br><span class=\"line\">\t@touch <span class=\"variable\">$@</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Clean everything, persist settings and build dependencies if anything changed</span></span><br><span class=\"line\"><span class=\"comment\">#当设置有变化的时候清除并重新持久化设置</span></span><br><span class=\"line\"><span class=\"keyword\">ifneq</span> (<span class=\"variable\">$(<span class=\"built_in\">strip</span> <span class=\"variable\">$(PREV_FINAL_CFLAGS)</span>)</span>, <span class=\"variable\">$(<span class=\"built_in\">strip</span> <span class=\"variable\">$(FINAL_CFLAGS)</span>)</span>)</span><br><span class=\"line\"><span class=\"section\">.make-prerequisites: persist-settings</span></span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ifneq</span> (<span class=\"variable\">$(<span class=\"built_in\">strip</span> <span class=\"variable\">$(PREV_FINAL_LDFLAGS)</span>)</span>, <span class=\"variable\">$(<span class=\"built_in\">strip</span> <span class=\"variable\">$(FINAL_LDFLAGS)</span>)</span>)</span><br><span class=\"line\"><span class=\"section\">.make-prerequisites: persist-settings</span></span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># redis-server</span></span><br><span class=\"line\"><span class=\"comment\">#redis-server可执行程序的链接，需要链接的静态链接文件包括hiredi和lua,还有final_libs</span></span><br><span class=\"line\"><span class=\"variable\">$(REDIS_SERVER_NAME)</span>: <span class=\"variable\">$(REDIS_SERVER_OBJ)</span></span><br><span class=\"line\">\t<span class=\"variable\">$(REDIS_LD)</span> -o <span class=\"variable\">$@</span> <span class=\"variable\">$^</span> ../deps/hiredis/libhiredis.a ../deps/lua/src/liblua.a <span class=\"variable\">$(FINAL_LIBS)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># redis-sentinel</span></span><br><span class=\"line\"><span class=\"comment\">#redis-sentienl构建</span></span><br><span class=\"line\"><span class=\"variable\">$(REDIS_SENTINEL_NAME)</span>: <span class=\"variable\">$(REDIS_SERVER_NAME)</span></span><br><span class=\"line\">\t<span class=\"variable\">$(REDIS_INSTALL)</span> <span class=\"variable\">$(REDIS_SERVER_NAME)</span> <span class=\"variable\">$(REDIS_SENTINEL_NAME)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># redis-check-rdb</span></span><br><span class=\"line\"><span class=\"comment\">#redis-check-rdb的构建</span></span><br><span class=\"line\"><span class=\"variable\">$(REDIS_CHECK_RDB_NAME)</span>: <span class=\"variable\">$(REDIS_SERVER_NAME)</span></span><br><span class=\"line\">\t<span class=\"variable\">$(REDIS_INSTALL)</span> <span class=\"variable\">$(REDIS_SERVER_NAME)</span> <span class=\"variable\">$(REDIS_CHECK_RDB_NAME)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># redis-check-aof</span></span><br><span class=\"line\"><span class=\"comment\">#redis-check-aof的构建</span></span><br><span class=\"line\"><span class=\"variable\">$(REDIS_CHECK_AOF_NAME)</span>: <span class=\"variable\">$(REDIS_SERVER_NAME)</span></span><br><span class=\"line\">\t<span class=\"variable\">$(REDIS_INSTALL)</span> <span class=\"variable\">$(REDIS_SERVER_NAME)</span> <span class=\"variable\">$(REDIS_CHECK_AOF_NAME)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># redis-cli</span></span><br><span class=\"line\"><span class=\"comment\">#redis-cli的链接</span></span><br><span class=\"line\"><span class=\"variable\">$(REDIS_CLI_NAME)</span>: <span class=\"variable\">$(REDIS_CLI_OBJ)</span></span><br><span class=\"line\">\t<span class=\"variable\">$(REDIS_LD)</span> -o <span class=\"variable\">$@</span> <span class=\"variable\">$^</span> ../deps/hiredis/libhiredis.a ../deps/linenoise/linenoise.o <span class=\"variable\">$(FINAL_LIBS)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># redis-benchmark</span></span><br><span class=\"line\"><span class=\"comment\">#redis-benchmark的链接</span></span><br><span class=\"line\"><span class=\"variable\">$(REDIS_BENCHMARK_NAME)</span>: <span class=\"variable\">$(REDIS_BENCHMARK_OBJ)</span></span><br><span class=\"line\">\t<span class=\"variable\">$(REDIS_LD)</span> -o <span class=\"variable\">$@</span> <span class=\"variable\">$^</span> ../deps/hiredis/libhiredis.a <span class=\"variable\">$(FINAL_LIBS)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">dict-benchmark: dict.c zmalloc.c sds.c siphash.c</span></span><br><span class=\"line\">\t<span class=\"variable\">$(REDIS_CC)</span> <span class=\"variable\">$(FINAL_CFLAGS)</span> <span class=\"variable\">$^</span> -D DICT_BENCHMARK_MAIN -o <span class=\"variable\">$@</span> <span class=\"variable\">$(FINAL_LIBS)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Because the jemalloc.h header is generated as a part of the jemalloc build,</span></span><br><span class=\"line\"><span class=\"comment\"># building it should complete before building any other object. Instead of</span></span><br><span class=\"line\"><span class=\"comment\"># depending on a single artifact, build all dependencies first.</span></span><br><span class=\"line\"><span class=\"comment\">#将所有点c文件编译成.o文件 自动完成file.c 到file.o的对应</span></span><br><span class=\"line\"><span class=\"section\">%.o: %.c .make-prerequisites</span></span><br><span class=\"line\">\t<span class=\"variable\">$(REDIS_CC)</span> -c <span class=\"variable\">$&lt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">clean:</span></span><br><span class=\"line\">\trm -rf <span class=\"variable\">$(REDIS_SERVER_NAME)</span> <span class=\"variable\">$(REDIS_SENTINEL_NAME)</span> <span class=\"variable\">$(REDIS_CLI_NAME)</span> <span class=\"variable\">$(REDIS_BENCHMARK_NAME)</span> <span class=\"variable\">$(REDIS_CHECK_RDB_NAME)</span> <span class=\"variable\">$(REDIS_CHECK_AOF_NAME)</span> *.o *.gcda *.gcno *.gcov redis.info lcov-html Makefile.dep dict-benchmark</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\"><span class=\"meta-keyword\">.PHONY</span>: clean</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">distclean: clean</span></span><br><span class=\"line\">\t-(cd ../deps &amp;&amp; <span class=\"variable\">$(MAKE)</span> distclean)</span><br><span class=\"line\">\t-(rm -f .make-*)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\"><span class=\"meta-keyword\">.PHONY</span>: distclean</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">test: <span class=\"variable\">$(REDIS_SERVER_NAME)</span> <span class=\"variable\">$(REDIS_CHECK_AOF_NAME)</span></span></span><br><span class=\"line\">\t@(cd ..; ./runtest)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">test-sentinel: <span class=\"variable\">$(REDIS_SENTINEL_NAME)</span></span></span><br><span class=\"line\">\t@(cd ..; ./runtest-sentinel)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">check: test</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">lcov:</span></span><br><span class=\"line\">\t<span class=\"variable\">$(MAKE)</span> gcov</span><br><span class=\"line\">\t@(set -e; cd ..; ./runtest --clients 1)</span><br><span class=\"line\">\t@geninfo -o redis.info .</span><br><span class=\"line\">\t@genhtml --legend -o lcov-html redis.info</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">test-sds: sds.c sds.h</span></span><br><span class=\"line\">\t<span class=\"variable\">$(REDIS_CC)</span> sds.c zmalloc.c -DSDS_TEST_MAIN <span class=\"variable\">$(FINAL_LIBS)</span> -o /tmp/sds_test</span><br><span class=\"line\">\t/tmp/sds_test</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\"><span class=\"meta-keyword\">.PHONY</span>: lcov</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">bench: <span class=\"variable\">$(REDIS_BENCHMARK_NAME)</span></span></span><br><span class=\"line\">\t./<span class=\"variable\">$(REDIS_BENCHMARK_NAME)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">32bit:</span></span><br><span class=\"line\">\t@echo <span class=\"string\">\"\"</span></span><br><span class=\"line\">\t@echo <span class=\"string\">\"WARNING: if it fails under Linux you probably need to install libc6-dev-i386\"</span></span><br><span class=\"line\">\t@echo <span class=\"string\">\"\"</span></span><br><span class=\"line\">\t<span class=\"variable\">$(MAKE)</span> CFLAGS=<span class=\"string\">\"-m32\"</span> LDFLAGS=<span class=\"string\">\"-m32\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">gcov:</span></span><br><span class=\"line\">\t<span class=\"variable\">$(MAKE)</span> REDIS_CFLAGS=<span class=\"string\">\"-fprofile-arcs -ftest-coverage -DCOVERAGE_TEST\"</span> REDIS_LDFLAGS=<span class=\"string\">\"-fprofile-arcs -ftest-coverage\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">noopt:</span></span><br><span class=\"line\">\t<span class=\"variable\">$(MAKE)</span> OPTIMIZATION=<span class=\"string\">\"-O0\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">valgrind:</span></span><br><span class=\"line\">\t<span class=\"variable\">$(MAKE)</span> OPTIMIZATION=<span class=\"string\">\"-O0\"</span> MALLOC=<span class=\"string\">\"libc\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">helgrind:</span></span><br><span class=\"line\">\t<span class=\"variable\">$(MAKE)</span> OPTIMIZATION=<span class=\"string\">\"-O0\"</span> MALLOC=<span class=\"string\">\"libc\"</span> CFLAGS=<span class=\"string\">\"-D__ATOMIC_VAR_FORCE_SYNC_MACROS\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">src/help.h:</span></span><br><span class=\"line\">\t@../utils/generate-command-help.rb &gt; help.h</span><br><span class=\"line\"><span class=\"comment\">#将构建完成的可执行程序安装到指定的目录，-p选项自行创建多层目录</span></span><br><span class=\"line\"><span class=\"section\">install: all</span></span><br><span class=\"line\">\t@mkdir -p <span class=\"variable\">$(INSTALL_BIN)</span></span><br><span class=\"line\">\t<span class=\"variable\">$(REDIS_INSTALL)</span> <span class=\"variable\">$(REDIS_SERVER_NAME)</span> <span class=\"variable\">$(INSTALL_BIN)</span></span><br><span class=\"line\">\t<span class=\"variable\">$(REDIS_INSTALL)</span> <span class=\"variable\">$(REDIS_BENCHMARK_NAME)</span> <span class=\"variable\">$(INSTALL_BIN)</span></span><br><span class=\"line\">\t<span class=\"variable\">$(REDIS_INSTALL)</span> <span class=\"variable\">$(REDIS_CLI_NAME)</span> <span class=\"variable\">$(INSTALL_BIN)</span></span><br><span class=\"line\">\t<span class=\"variable\">$(REDIS_INSTALL)</span> <span class=\"variable\">$(REDIS_CHECK_RDB_NAME)</span> <span class=\"variable\">$(INSTALL_BIN)</span></span><br><span class=\"line\">\t<span class=\"variable\">$(REDIS_INSTALL)</span> <span class=\"variable\">$(REDIS_CHECK_AOF_NAME)</span> <span class=\"variable\">$(INSTALL_BIN)</span></span><br><span class=\"line\">\t@ln -sf <span class=\"variable\">$(REDIS_SERVER_NAME)</span> <span class=\"variable\">$(INSTALL_BIN)</span>/<span class=\"variable\">$(REDIS_SENTINEL_NAME)</span></span><br></pre></td></tr></table></figure>\n<p><code>uname_S := $(shell sh -c &#39;uname -s 2&gt;/dev/null || echo not&#39;)</code> 这一句-c让后面的字符串命令当成一个完成的命令来执行，从而避免向文件中写入东西的时候权限不够的问题。就算加上sudo也不行，因为里面的命令有&gt;,echo等很多个文件，所以只能用-c来当成一个整体来执行。<a href=\"https://blog.csdn.net/bobchill/article/details/84647575\" target=\"_blank\" rel=\"noopener\">参考</a></p>\n<h2 id=\"Makefile思路\"><a href=\"#Makefile思路\" class=\"headerlink\" title=\"Makefile思路\"></a>Makefile思路</h2><p>总结一下Redis Makefile的思路：</p>\n<ol>\n<li>在默认规则也就是第一条规则之前，通过变量设置好编译的相关选项：LDFLAGS，相应的对应关系REDIS_SERVER_OBJ，将规则的target用变量表示好（方便all规则里面用作前置条件），比如REDIS_SERVER_NAME。</li>\n<li>在第一条默认规则 all规则里面指定需要构建的东西</li>\n<li>在第一规则后面先完成链接，再完成编译的规则</li>\n<li>其他功能性规则如clean和distclean</li>\n</ol>\n<p>也就是从上到下的结构是总-分。显示整个项目 ，然后是各个模块如redis-server，redis-cli的链接，然后是从源文件到obj文件的编译。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://blog.csdn.net/bobchill/article/details/84647575\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/bobchill/article/details/84647575</a></p>\n","site":{"data":{}},"length":10300,"excerpt":"<h1 id=\"Redis-Makefile注解\"><a href=\"#Redis-Makefile注解\" class=\"headerlink\" title=\"Redis Makefile注解\"></a>Redis Makefile注解</h1><p>Redis的makefile是阅读源码的第一步，总共有292行，读起来也是头大，记录之。</p>","more":"<p>4.02版本源码为：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br><span class=\"line\">291</span><br><span class=\"line\">292</span><br><span class=\"line\">293</span><br><span class=\"line\">294</span><br><span class=\"line\">295</span><br><span class=\"line\">296</span><br><span class=\"line\">297</span><br><span class=\"line\">298</span><br><span class=\"line\">299</span><br><span class=\"line\">300</span><br><span class=\"line\">301</span><br><span class=\"line\">302</span><br><span class=\"line\">303</span><br><span class=\"line\">304</span><br><span class=\"line\">305</span><br><span class=\"line\">306</span><br><span class=\"line\">307</span><br><span class=\"line\">308</span><br><span class=\"line\">309</span><br><span class=\"line\">310</span><br><span class=\"line\">311</span><br><span class=\"line\">312</span><br><span class=\"line\">313</span><br><span class=\"line\">314</span><br><span class=\"line\">315</span><br><span class=\"line\">316</span><br><span class=\"line\">317</span><br><span class=\"line\">318</span><br><span class=\"line\">319</span><br><span class=\"line\">320</span><br><span class=\"line\">321</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Redis Makefile</span></span><br><span class=\"line\"><span class=\"comment\"># Copyright (C) 2009 Salvatore Sanfilippo &lt;antirez at gmail dot com&gt;</span></span><br><span class=\"line\"><span class=\"comment\"># This file is released under the BSD license, see the COPYING file</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># The Makefile composes the final FINAL_CFLAGS and FINAL_LDFLAGS using</span></span><br><span class=\"line\"><span class=\"comment\"># what is needed for Redis plus the standard CFLAGS and LDFLAGS passed.</span></span><br><span class=\"line\"><span class=\"comment\"># However when building the dependencies (Jemalloc, Lua, Hiredis, ...)</span></span><br><span class=\"line\"><span class=\"comment\"># CFLAGS and LDFLAGS are propagated to the dependencies, so to pass</span></span><br><span class=\"line\"><span class=\"comment\"># flags only to be used when compiling / linking Redis itself REDIS_CFLAGS</span></span><br><span class=\"line\"><span class=\"comment\"># and REDIS_LDFLAGS are used instead (this is the case of 'make gcov').</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># Dependencies are stored in the Makefile.dep file. To rebuild this file</span></span><br><span class=\"line\"><span class=\"comment\"># Just use 'make dep', but this is only needed by developers.</span></span><br><span class=\"line\"></span><br><span class=\"line\">release_hdr := <span class=\"variable\">$(<span class=\"built_in\">shell</span> sh -c './mkreleasehdr.sh')</span></span><br><span class=\"line\"><span class=\"comment\"># uname -s 获取操作系统的类型 Linux</span></span><br><span class=\"line\">uname_S := <span class=\"variable\">$(<span class=\"built_in\">shell</span> sh -c 'uname -s 2&gt;/dev/null || echo not')</span></span><br><span class=\"line\"><span class=\"comment\">#uname -m 获取机子的架构 x86_64</span></span><br><span class=\"line\">uname_M := <span class=\"variable\">$(<span class=\"built_in\">shell</span> sh -c 'uname -m 2&gt;/dev/null || echo not')</span></span><br><span class=\"line\"><span class=\"comment\"># 优化选项</span></span><br><span class=\"line\">OPTIMIZATION?=-O2</span><br><span class=\"line\"><span class=\"comment\"># 依赖目标</span></span><br><span class=\"line\">DEPENDENCY_TARGETS=hiredis linenoise lua</span><br><span class=\"line\">NODEPS:=clean distclean</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Default settings</span></span><br><span class=\"line\"><span class=\"comment\"># 使用c99标准编译，-pedantic 保证代码规范满足ISO C和ISO C++标准</span></span><br><span class=\"line\">STD=-std=c99 -pedantic -DREDIS_STATIC=''</span><br><span class=\"line\"><span class=\"comment\"># 输出所有编译警告信息 ，Wno-missing-field-initializers 不输出missing-的警告信息</span></span><br><span class=\"line\">WARN=-Wall -W -Wno-missing-field-initializers</span><br><span class=\"line\">OPT=<span class=\"variable\">$(OPTIMIZATION)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#默认目录</span></span><br><span class=\"line\">PREFIX?=/usr/local</span><br><span class=\"line\"><span class=\"comment\">#安装的默认目录</span></span><br><span class=\"line\">INSTALL_BIN=<span class=\"variable\">$(PREFIX)</span>/bin</span><br><span class=\"line\">INSTALL=install</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Default allocator defaults to Jemalloc if it's not an ARM</span></span><br><span class=\"line\"><span class=\"comment\">#内存分配器的指定 默认libc，linux系统而且架构不是armv61和71的时候则是jemalloc，</span></span><br><span class=\"line\">MALLOC=libc</span><br><span class=\"line\"><span class=\"keyword\">ifneq</span> (<span class=\"variable\">$(uname_M)</span>,armv6l)</span><br><span class=\"line\"><span class=\"keyword\">ifneq</span> (<span class=\"variable\">$(uname_M)</span>,armv7l)</span><br><span class=\"line\"><span class=\"keyword\">ifeq</span> (<span class=\"variable\">$(uname_S)</span>,Linux)</span><br><span class=\"line\">\tMALLOC=jemalloc</span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># To get ARM stack traces if Redis crashes we need a special C flag.</span></span><br><span class=\"line\"><span class=\"keyword\">ifneq</span> (,<span class=\"variable\">$(<span class=\"built_in\">findstring</span> armv,<span class=\"variable\">$(uname_M)</span>)</span>)</span><br><span class=\"line\">        CFLAGS+=-funwind-tables</span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Backwards compatibility for selecting an allocator</span></span><br><span class=\"line\"><span class=\"comment\">#编译的时候指定内存分配器</span></span><br><span class=\"line\"><span class=\"keyword\">ifeq</span> (<span class=\"variable\">$(USE_TCMALLOC)</span>,yes)</span><br><span class=\"line\">\tMALLOC=tcmalloc</span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ifeq</span> (<span class=\"variable\">$(USE_TCMALLOC_MINIMAL)</span>,yes)</span><br><span class=\"line\">\tMALLOC=tcmalloc_minimal</span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ifeq</span> (<span class=\"variable\">$(USE_JEMALLOC)</span>,yes)</span><br><span class=\"line\">\tMALLOC=jemalloc</span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ifeq</span> (<span class=\"variable\">$(USE_JEMALLOC)</span>,no)</span><br><span class=\"line\">\tMALLOC=libc</span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Override default settings if possible</span></span><br><span class=\"line\"><span class=\"keyword\">-include</span> .make-settings</span><br><span class=\"line\"><span class=\"comment\"># 最终的编译选项CFLAGS是-c的选项，LDFLAGS是链接的选项</span></span><br><span class=\"line\">FINAL_CFLAGS=<span class=\"variable\">$(STD)</span> <span class=\"variable\">$(WARN)</span> <span class=\"variable\">$(OPT)</span> <span class=\"variable\">$(DEBUG)</span> <span class=\"variable\">$(CFLAGS)</span> <span class=\"variable\">$(REDIS_CFLAGS)</span></span><br><span class=\"line\">FINAL_LDFLAGS=<span class=\"variable\">$(LDFLAGS)</span> <span class=\"variable\">$(REDIS_LDFLAGS)</span> <span class=\"variable\">$(DEBUG)</span></span><br><span class=\"line\"><span class=\"comment\"># m这个lib是libmath 也就是math的链接</span></span><br><span class=\"line\">FINAL_LIBS=-lm</span><br><span class=\"line\"><span class=\"comment\"># 调试信息</span></span><br><span class=\"line\">DEBUG=-g -ggdb</span><br><span class=\"line\"><span class=\"comment\">#根据操作系统继续指定编译选项</span></span><br><span class=\"line\"><span class=\"keyword\">ifeq</span> (<span class=\"variable\">$(uname_S)</span>,SunOS)</span><br><span class=\"line\">\t<span class=\"comment\"># SunOS</span></span><br><span class=\"line\">        <span class=\"keyword\">ifneq</span> ($(@@),32bit)</span><br><span class=\"line\">\t\tCFLAGS+= -m64</span><br><span class=\"line\">\t\tLDFLAGS+= -m64</span><br><span class=\"line\">\t<span class=\"keyword\">endif</span></span><br><span class=\"line\">\tDEBUG=-g</span><br><span class=\"line\">\tDEBUG_FLAGS=-g</span><br><span class=\"line\">\t<span class=\"keyword\">export</span> CFLAGS LDFLAGS DEBUG DEBUG_FLAGS</span><br><span class=\"line\">\tINSTALL=cp -pf</span><br><span class=\"line\">\tFINAL_CFLAGS+= -D__EXTENSIONS__ -D_XPG6</span><br><span class=\"line\">\tFINAL_LIBS+= -ldl -lnsl -lsocket -lresolv -lpthread -lrt</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\"><span class=\"keyword\">ifeq</span> (<span class=\"variable\">$(uname_S)</span>,Darwin)</span><br><span class=\"line\">\t<span class=\"comment\"># Darwin</span></span><br><span class=\"line\">\tFINAL_LIBS+= -ldl</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\"><span class=\"keyword\">ifeq</span> (<span class=\"variable\">$(uname_S)</span>,AIX)</span><br><span class=\"line\">        <span class=\"comment\"># AIX</span></span><br><span class=\"line\">        FINAL_LDFLAGS+= -Wl,-bexpall</span><br><span class=\"line\">        FINAL_LIBS+=-ldl -pthread -lcrypt -lbsd</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\"><span class=\"keyword\">ifeq</span> (<span class=\"variable\">$(uname_S)</span>,OpenBSD)</span><br><span class=\"line\">\t<span class=\"comment\"># OpenBSD</span></span><br><span class=\"line\">\tFINAL_LIBS+= -lpthread</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\"><span class=\"keyword\">ifeq</span> (<span class=\"variable\">$(uname_S)</span>,FreeBSD)</span><br><span class=\"line\">\t<span class=\"comment\"># FreeBSD</span></span><br><span class=\"line\">\tFINAL_LIBS+= -lpthread</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">\t<span class=\"comment\"># 特别是对Linux的指定</span></span><br><span class=\"line\">\t<span class=\"comment\"># All the other OSes (notably Linux)</span></span><br><span class=\"line\">\t<span class=\"comment\"># -rdynamic将链接器将所有符号添加到动态符号表</span></span><br><span class=\"line\">\tFINAL_LDFLAGS+= -rdynamic</span><br><span class=\"line\">\t<span class=\"comment\">#pthread库 用于多线程， dl是libdl 动态链接库</span></span><br><span class=\"line\">\tFINAL_LIBS+=-ldl -pthread</span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"><span class=\"comment\"># Include paths to dependencies</span></span><br><span class=\"line\"><span class=\"comment\"># -I 指定头文件的目录</span></span><br><span class=\"line\">FINAL_CFLAGS+= -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ifeq</span> (<span class=\"variable\">$(MALLOC)</span>,tcmalloc)</span><br><span class=\"line\">\tFINAL_CFLAGS+= -DUSE_TCMALLOC</span><br><span class=\"line\">\tFINAL_LIBS+= -ltcmalloc</span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ifeq</span> (<span class=\"variable\">$(MALLOC)</span>,tcmalloc_minimal)</span><br><span class=\"line\">\tFINAL_CFLAGS+= -DUSE_TCMALLOC</span><br><span class=\"line\">\tFINAL_LIBS+= -ltcmalloc_minimal</span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"><span class=\"comment\">#使用jemalloc的话 链接 libjemalloc.a -I指定jemalloc的头文件目录</span></span><br><span class=\"line\"><span class=\"keyword\">ifeq</span> (<span class=\"variable\">$(MALLOC)</span>,jemalloc)</span><br><span class=\"line\">\tDEPENDENCY_TARGETS+= jemalloc</span><br><span class=\"line\">\tFINAL_CFLAGS+= -DUSE_JEMALLOC -I../deps/jemalloc/<span class=\"keyword\">include</span></span><br><span class=\"line\">\tFINAL_LIBS+= ../deps/jemalloc/lib/libjemalloc.a</span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"><span class=\"comment\">#redis 的gcc -c 选项</span></span><br><span class=\"line\">REDIS_CC=<span class=\"variable\">$(QUIET_CC)</span><span class=\"variable\">$(CC)</span> <span class=\"variable\">$(FINAL_CFLAGS)</span></span><br><span class=\"line\"><span class=\"comment\">#redis的gcc 链接选项</span></span><br><span class=\"line\">REDIS_LD=<span class=\"variable\">$(QUIET_LINK)</span><span class=\"variable\">$(CC)</span> <span class=\"variable\">$(FINAL_LDFLAGS)</span></span><br><span class=\"line\"><span class=\"comment\">#redis的安装选项</span></span><br><span class=\"line\">REDIS_INSTALL=<span class=\"variable\">$(QUIET_INSTALL)</span><span class=\"variable\">$(INSTALL)</span></span><br><span class=\"line\"></span><br><span class=\"line\">CCCOLOR=<span class=\"string\">\"\\033[34m\"</span></span><br><span class=\"line\">LINKCOLOR=<span class=\"string\">\"\\033[34;1m\"</span></span><br><span class=\"line\">SRCCOLOR=<span class=\"string\">\"\\033[33m\"</span></span><br><span class=\"line\">BINCOLOR=<span class=\"string\">\"\\033[37;1m\"</span></span><br><span class=\"line\">MAKECOLOR=<span class=\"string\">\"\\033[32;1m\"</span></span><br><span class=\"line\">ENDCOLOR=<span class=\"string\">\"\\033[0m\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ifndef</span> V</span><br><span class=\"line\">QUIET_CC = @printf '    %b %b\\n' <span class=\"variable\">$(CCCOLOR)</span>CC<span class=\"variable\">$(ENDCOLOR)</span> <span class=\"variable\">$(SRCCOLOR)</span><span class=\"variable\">$@</span><span class=\"variable\">$(ENDCOLOR)</span> 1&gt;&amp;2;</span><br><span class=\"line\">QUIET_LINK = @printf '    %b %b\\n' <span class=\"variable\">$(LINKCOLOR)</span>LINK<span class=\"variable\">$(ENDCOLOR)</span> <span class=\"variable\">$(BINCOLOR)</span><span class=\"variable\">$@</span><span class=\"variable\">$(ENDCOLOR)</span> 1&gt;&amp;2;</span><br><span class=\"line\">QUIET_INSTALL = @printf '    %b %b\\n' <span class=\"variable\">$(LINKCOLOR)</span>INSTALL<span class=\"variable\">$(ENDCOLOR)</span> <span class=\"variable\">$(BINCOLOR)</span><span class=\"variable\">$@</span><span class=\"variable\">$(ENDCOLOR)</span> 1&gt;&amp;2;</span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"></span><br><span class=\"line\">REDIS_SERVER_NAME=redis-server</span><br><span class=\"line\">REDIS_SENTINEL_NAME=redis-sentinel</span><br><span class=\"line\"><span class=\"comment\"># redis-server的需要使用的对象文件，也就是各个模块</span></span><br><span class=\"line\">REDIS_SERVER_OBJ=adlist.o quicklist.o ae.o anet.o dict.o server.o sds.o zmalloc.o lzf_c.o lzf_d.o pqsort.o zipmap.o sha1.o ziplist.o release.o networking.o util.o object.o db.o replication.o rdb.o t_string.o t_list.o t_set.o t_zset.o t_hash.o config.o aof.o pubsub.o multi.o debug.o sort.o intset.o syncio.o cluster.o crc16.o endianconv.o slowlog.o scripting.o bio.o rio.o rand.o memtest.o crc64.o bitops.o sentinel.o notify.o setproctitle.o blocked.o hyperloglog.o latency.o sparkline.o redis-check-rdb.o redis-check-aof.o geo.o lazyfree.o module.o evict.o expire.o geohash.o geohash_helper.o childinfo.o defrag.o siphash.o rax.o</span><br><span class=\"line\">REDIS_CLI_NAME=redis-cli</span><br><span class=\"line\"><span class=\"comment\">#redis-cli 需要使用的对象文件</span></span><br><span class=\"line\">REDIS_CLI_OBJ=anet.o adlist.o redis-cli.o zmalloc.o release.o anet.o ae.o crc64.o</span><br><span class=\"line\">REDIS_BENCHMARK_NAME=redis-benchmark</span><br><span class=\"line\"><span class=\"comment\">#redis-benchmark需要使用的对象文件</span></span><br><span class=\"line\">REDIS_BENCHMARK_OBJ=ae.o anet.o redis-benchmark.o adlist.o zmalloc.o redis-benchmark.o</span><br><span class=\"line\">REDIS_CHECK_RDB_NAME=redis-check-rdb</span><br><span class=\"line\">REDIS_CHECK_AOF_NAME=redis-check-aof</span><br><span class=\"line\"><span class=\"comment\">#所有需要需要构建的对象，第一条规则也就是默认规则，不指定规则的话，从第一个规则执行</span></span><br><span class=\"line\"><span class=\"section\">all: <span class=\"variable\">$(REDIS_SERVER_NAME)</span> <span class=\"variable\">$(REDIS_SENTINEL_NAME)</span> <span class=\"variable\">$(REDIS_CLI_NAME)</span> <span class=\"variable\">$(REDIS_BENCHMARK_NAME)</span> <span class=\"variable\">$(REDIS_CHECK_RDB_NAME)</span> <span class=\"variable\">$(REDIS_CHECK_AOF_NAME)</span></span></span><br><span class=\"line\">\t@echo <span class=\"string\">\"\"</span></span><br><span class=\"line\">\t@echo <span class=\"string\">\"Hint: It's a good idea to run 'make test' ;)\"</span></span><br><span class=\"line\">\t@echo <span class=\"string\">\"\"</span></span><br><span class=\"line\"><span class=\"comment\">#Makefil.dep 的生成</span></span><br><span class=\"line\"><span class=\"section\">Makefile.dep:</span></span><br><span class=\"line\">\t-<span class=\"variable\">$(REDIS_CC)</span> -MM *.c &gt; Makefile.dep 2&gt; /dev/null || true</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ifeq</span> (0, <span class=\"variable\">$(words $(<span class=\"built_in\">findstring</span> <span class=\"variable\">$(MAKECMDGOALS)</span>, <span class=\"variable\">$(NODEPS)</span>)</span>))</span><br><span class=\"line\"><span class=\"keyword\">-include</span> Makefile.dep</span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\"><span class=\"meta-keyword\">.PHONY</span>: all</span></span><br><span class=\"line\"><span class=\"comment\">#先清除所有编译的输出然后，  将所有设置持久化</span></span><br><span class=\"line\"><span class=\"section\">persist-settings: distclean</span></span><br><span class=\"line\">\techo STD=<span class=\"variable\">$(STD)</span> &gt;&gt; .make-settings</span><br><span class=\"line\">\techo WARN=<span class=\"variable\">$(WARN)</span> &gt;&gt; .make-settings</span><br><span class=\"line\">\techo OPT=<span class=\"variable\">$(OPT)</span> &gt;&gt; .make-settings</span><br><span class=\"line\">\techo MALLOC=<span class=\"variable\">$(MALLOC)</span> &gt;&gt; .make-settings</span><br><span class=\"line\">\techo CFLAGS=<span class=\"variable\">$(CFLAGS)</span> &gt;&gt; .make-settings</span><br><span class=\"line\">\techo LDFLAGS=<span class=\"variable\">$(LDFLAGS)</span> &gt;&gt; .make-settings</span><br><span class=\"line\">\techo REDIS_CFLAGS=<span class=\"variable\">$(REDIS_CFLAGS)</span> &gt;&gt; .make-settings</span><br><span class=\"line\">\techo REDIS_LDFLAGS=<span class=\"variable\">$(REDIS_LDFLAGS)</span> &gt;&gt; .make-settings</span><br><span class=\"line\">\techo PREV_FINAL_CFLAGS=<span class=\"variable\">$(FINAL_CFLAGS)</span> &gt;&gt; .make-settings</span><br><span class=\"line\">\techo PREV_FINAL_LDFLAGS=<span class=\"variable\">$(FINAL_LDFLAGS)</span> &gt;&gt; .make-settings</span><br><span class=\"line\">\t-(cd ../deps &amp;&amp; <span class=\"variable\">$(MAKE)</span> <span class=\"variable\">$(DEPENDENCY_TARGETS)</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\"><span class=\"meta-keyword\">.PHONY</span>: persist-settings</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># Prerequisites target</span></span><br><span class=\"line\"><span class=\"section\">.make-prerequisites:</span></span><br><span class=\"line\">\t@touch <span class=\"variable\">$@</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Clean everything, persist settings and build dependencies if anything changed</span></span><br><span class=\"line\"><span class=\"comment\">#当设置有变化的时候清除并重新持久化设置</span></span><br><span class=\"line\"><span class=\"keyword\">ifneq</span> (<span class=\"variable\">$(<span class=\"built_in\">strip</span> <span class=\"variable\">$(PREV_FINAL_CFLAGS)</span>)</span>, <span class=\"variable\">$(<span class=\"built_in\">strip</span> <span class=\"variable\">$(FINAL_CFLAGS)</span>)</span>)</span><br><span class=\"line\"><span class=\"section\">.make-prerequisites: persist-settings</span></span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ifneq</span> (<span class=\"variable\">$(<span class=\"built_in\">strip</span> <span class=\"variable\">$(PREV_FINAL_LDFLAGS)</span>)</span>, <span class=\"variable\">$(<span class=\"built_in\">strip</span> <span class=\"variable\">$(FINAL_LDFLAGS)</span>)</span>)</span><br><span class=\"line\"><span class=\"section\">.make-prerequisites: persist-settings</span></span><br><span class=\"line\"><span class=\"keyword\">endif</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># redis-server</span></span><br><span class=\"line\"><span class=\"comment\">#redis-server可执行程序的链接，需要链接的静态链接文件包括hiredi和lua,还有final_libs</span></span><br><span class=\"line\"><span class=\"variable\">$(REDIS_SERVER_NAME)</span>: <span class=\"variable\">$(REDIS_SERVER_OBJ)</span></span><br><span class=\"line\">\t<span class=\"variable\">$(REDIS_LD)</span> -o <span class=\"variable\">$@</span> <span class=\"variable\">$^</span> ../deps/hiredis/libhiredis.a ../deps/lua/src/liblua.a <span class=\"variable\">$(FINAL_LIBS)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># redis-sentinel</span></span><br><span class=\"line\"><span class=\"comment\">#redis-sentienl构建</span></span><br><span class=\"line\"><span class=\"variable\">$(REDIS_SENTINEL_NAME)</span>: <span class=\"variable\">$(REDIS_SERVER_NAME)</span></span><br><span class=\"line\">\t<span class=\"variable\">$(REDIS_INSTALL)</span> <span class=\"variable\">$(REDIS_SERVER_NAME)</span> <span class=\"variable\">$(REDIS_SENTINEL_NAME)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># redis-check-rdb</span></span><br><span class=\"line\"><span class=\"comment\">#redis-check-rdb的构建</span></span><br><span class=\"line\"><span class=\"variable\">$(REDIS_CHECK_RDB_NAME)</span>: <span class=\"variable\">$(REDIS_SERVER_NAME)</span></span><br><span class=\"line\">\t<span class=\"variable\">$(REDIS_INSTALL)</span> <span class=\"variable\">$(REDIS_SERVER_NAME)</span> <span class=\"variable\">$(REDIS_CHECK_RDB_NAME)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># redis-check-aof</span></span><br><span class=\"line\"><span class=\"comment\">#redis-check-aof的构建</span></span><br><span class=\"line\"><span class=\"variable\">$(REDIS_CHECK_AOF_NAME)</span>: <span class=\"variable\">$(REDIS_SERVER_NAME)</span></span><br><span class=\"line\">\t<span class=\"variable\">$(REDIS_INSTALL)</span> <span class=\"variable\">$(REDIS_SERVER_NAME)</span> <span class=\"variable\">$(REDIS_CHECK_AOF_NAME)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># redis-cli</span></span><br><span class=\"line\"><span class=\"comment\">#redis-cli的链接</span></span><br><span class=\"line\"><span class=\"variable\">$(REDIS_CLI_NAME)</span>: <span class=\"variable\">$(REDIS_CLI_OBJ)</span></span><br><span class=\"line\">\t<span class=\"variable\">$(REDIS_LD)</span> -o <span class=\"variable\">$@</span> <span class=\"variable\">$^</span> ../deps/hiredis/libhiredis.a ../deps/linenoise/linenoise.o <span class=\"variable\">$(FINAL_LIBS)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># redis-benchmark</span></span><br><span class=\"line\"><span class=\"comment\">#redis-benchmark的链接</span></span><br><span class=\"line\"><span class=\"variable\">$(REDIS_BENCHMARK_NAME)</span>: <span class=\"variable\">$(REDIS_BENCHMARK_OBJ)</span></span><br><span class=\"line\">\t<span class=\"variable\">$(REDIS_LD)</span> -o <span class=\"variable\">$@</span> <span class=\"variable\">$^</span> ../deps/hiredis/libhiredis.a <span class=\"variable\">$(FINAL_LIBS)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">dict-benchmark: dict.c zmalloc.c sds.c siphash.c</span></span><br><span class=\"line\">\t<span class=\"variable\">$(REDIS_CC)</span> <span class=\"variable\">$(FINAL_CFLAGS)</span> <span class=\"variable\">$^</span> -D DICT_BENCHMARK_MAIN -o <span class=\"variable\">$@</span> <span class=\"variable\">$(FINAL_LIBS)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Because the jemalloc.h header is generated as a part of the jemalloc build,</span></span><br><span class=\"line\"><span class=\"comment\"># building it should complete before building any other object. Instead of</span></span><br><span class=\"line\"><span class=\"comment\"># depending on a single artifact, build all dependencies first.</span></span><br><span class=\"line\"><span class=\"comment\">#将所有点c文件编译成.o文件 自动完成file.c 到file.o的对应</span></span><br><span class=\"line\"><span class=\"section\">%.o: %.c .make-prerequisites</span></span><br><span class=\"line\">\t<span class=\"variable\">$(REDIS_CC)</span> -c <span class=\"variable\">$&lt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">clean:</span></span><br><span class=\"line\">\trm -rf <span class=\"variable\">$(REDIS_SERVER_NAME)</span> <span class=\"variable\">$(REDIS_SENTINEL_NAME)</span> <span class=\"variable\">$(REDIS_CLI_NAME)</span> <span class=\"variable\">$(REDIS_BENCHMARK_NAME)</span> <span class=\"variable\">$(REDIS_CHECK_RDB_NAME)</span> <span class=\"variable\">$(REDIS_CHECK_AOF_NAME)</span> *.o *.gcda *.gcno *.gcov redis.info lcov-html Makefile.dep dict-benchmark</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\"><span class=\"meta-keyword\">.PHONY</span>: clean</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">distclean: clean</span></span><br><span class=\"line\">\t-(cd ../deps &amp;&amp; <span class=\"variable\">$(MAKE)</span> distclean)</span><br><span class=\"line\">\t-(rm -f .make-*)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\"><span class=\"meta-keyword\">.PHONY</span>: distclean</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">test: <span class=\"variable\">$(REDIS_SERVER_NAME)</span> <span class=\"variable\">$(REDIS_CHECK_AOF_NAME)</span></span></span><br><span class=\"line\">\t@(cd ..; ./runtest)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">test-sentinel: <span class=\"variable\">$(REDIS_SENTINEL_NAME)</span></span></span><br><span class=\"line\">\t@(cd ..; ./runtest-sentinel)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">check: test</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">lcov:</span></span><br><span class=\"line\">\t<span class=\"variable\">$(MAKE)</span> gcov</span><br><span class=\"line\">\t@(set -e; cd ..; ./runtest --clients 1)</span><br><span class=\"line\">\t@geninfo -o redis.info .</span><br><span class=\"line\">\t@genhtml --legend -o lcov-html redis.info</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">test-sds: sds.c sds.h</span></span><br><span class=\"line\">\t<span class=\"variable\">$(REDIS_CC)</span> sds.c zmalloc.c -DSDS_TEST_MAIN <span class=\"variable\">$(FINAL_LIBS)</span> -o /tmp/sds_test</span><br><span class=\"line\">\t/tmp/sds_test</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\"><span class=\"meta-keyword\">.PHONY</span>: lcov</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">bench: <span class=\"variable\">$(REDIS_BENCHMARK_NAME)</span></span></span><br><span class=\"line\">\t./<span class=\"variable\">$(REDIS_BENCHMARK_NAME)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">32bit:</span></span><br><span class=\"line\">\t@echo <span class=\"string\">\"\"</span></span><br><span class=\"line\">\t@echo <span class=\"string\">\"WARNING: if it fails under Linux you probably need to install libc6-dev-i386\"</span></span><br><span class=\"line\">\t@echo <span class=\"string\">\"\"</span></span><br><span class=\"line\">\t<span class=\"variable\">$(MAKE)</span> CFLAGS=<span class=\"string\">\"-m32\"</span> LDFLAGS=<span class=\"string\">\"-m32\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">gcov:</span></span><br><span class=\"line\">\t<span class=\"variable\">$(MAKE)</span> REDIS_CFLAGS=<span class=\"string\">\"-fprofile-arcs -ftest-coverage -DCOVERAGE_TEST\"</span> REDIS_LDFLAGS=<span class=\"string\">\"-fprofile-arcs -ftest-coverage\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">noopt:</span></span><br><span class=\"line\">\t<span class=\"variable\">$(MAKE)</span> OPTIMIZATION=<span class=\"string\">\"-O0\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">valgrind:</span></span><br><span class=\"line\">\t<span class=\"variable\">$(MAKE)</span> OPTIMIZATION=<span class=\"string\">\"-O0\"</span> MALLOC=<span class=\"string\">\"libc\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">helgrind:</span></span><br><span class=\"line\">\t<span class=\"variable\">$(MAKE)</span> OPTIMIZATION=<span class=\"string\">\"-O0\"</span> MALLOC=<span class=\"string\">\"libc\"</span> CFLAGS=<span class=\"string\">\"-D__ATOMIC_VAR_FORCE_SYNC_MACROS\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">src/help.h:</span></span><br><span class=\"line\">\t@../utils/generate-command-help.rb &gt; help.h</span><br><span class=\"line\"><span class=\"comment\">#将构建完成的可执行程序安装到指定的目录，-p选项自行创建多层目录</span></span><br><span class=\"line\"><span class=\"section\">install: all</span></span><br><span class=\"line\">\t@mkdir -p <span class=\"variable\">$(INSTALL_BIN)</span></span><br><span class=\"line\">\t<span class=\"variable\">$(REDIS_INSTALL)</span> <span class=\"variable\">$(REDIS_SERVER_NAME)</span> <span class=\"variable\">$(INSTALL_BIN)</span></span><br><span class=\"line\">\t<span class=\"variable\">$(REDIS_INSTALL)</span> <span class=\"variable\">$(REDIS_BENCHMARK_NAME)</span> <span class=\"variable\">$(INSTALL_BIN)</span></span><br><span class=\"line\">\t<span class=\"variable\">$(REDIS_INSTALL)</span> <span class=\"variable\">$(REDIS_CLI_NAME)</span> <span class=\"variable\">$(INSTALL_BIN)</span></span><br><span class=\"line\">\t<span class=\"variable\">$(REDIS_INSTALL)</span> <span class=\"variable\">$(REDIS_CHECK_RDB_NAME)</span> <span class=\"variable\">$(INSTALL_BIN)</span></span><br><span class=\"line\">\t<span class=\"variable\">$(REDIS_INSTALL)</span> <span class=\"variable\">$(REDIS_CHECK_AOF_NAME)</span> <span class=\"variable\">$(INSTALL_BIN)</span></span><br><span class=\"line\">\t@ln -sf <span class=\"variable\">$(REDIS_SERVER_NAME)</span> <span class=\"variable\">$(INSTALL_BIN)</span>/<span class=\"variable\">$(REDIS_SENTINEL_NAME)</span></span><br></pre></td></tr></table></figure>\n<p><code>uname_S := $(shell sh -c &#39;uname -s 2&gt;/dev/null || echo not&#39;)</code> 这一句-c让后面的字符串命令当成一个完成的命令来执行，从而避免向文件中写入东西的时候权限不够的问题。就算加上sudo也不行，因为里面的命令有&gt;,echo等很多个文件，所以只能用-c来当成一个整体来执行。<a href=\"https://blog.csdn.net/bobchill/article/details/84647575\" target=\"_blank\" rel=\"noopener\">参考</a></p>\n<h2 id=\"Makefile思路\"><a href=\"#Makefile思路\" class=\"headerlink\" title=\"Makefile思路\"></a>Makefile思路</h2><p>总结一下Redis Makefile的思路：</p>\n<ol>\n<li>在默认规则也就是第一条规则之前，通过变量设置好编译的相关选项：LDFLAGS，相应的对应关系REDIS_SERVER_OBJ，将规则的target用变量表示好（方便all规则里面用作前置条件），比如REDIS_SERVER_NAME。</li>\n<li>在第一条默认规则 all规则里面指定需要构建的东西</li>\n<li>在第一规则后面先完成链接，再完成编译的规则</li>\n<li>其他功能性规则如clean和distclean</li>\n</ol>\n<p>也就是从上到下的结构是总-分。显示整个项目 ，然后是各个模块如redis-server，redis-cli的链接，然后是从源文件到obj文件的编译。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://blog.csdn.net/bobchill/article/details/84647575\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/bobchill/article/details/84647575</a></p>"},{"title":"实模式寻址方式","date":"2019-09-08T02:12:44.000Z","copyright":true,"_content":"\n# 实模式寻址方式\n\n在上《操作系统高级教程》课时有BIOS启动时的实模式，讲到 CS与IP这两个寄存器，但是始终不能理解为什么说CS:IP可以表示一个物理地址，查询后才理解到与实模式的寻址方式有关。\n\n<!--more-->\n\n## 8086的寻址方式\n\n为了理解实模式，首先需要理解Intel 8086这个16位CPU的寻址模式。\n\n8086的CPU是16位，即它的所有寄存器和寄存器之间的数据总线都是16位的，而其外部数据总线却是20位的。那么如何才能访问到20位也就是1MB的地址空间呢？显然一个寄存器是不够的所以就用两个寄存器来存储，这也就是段式寻址（内存分段）。段式寻址需要使用一个寄存器作为段寄存器比如CS代码段寄存器，使用另外一个寄存器比如IP指令指针寄存器作为偏移寄存器。计算物理地址的时候首先将段寄存器的16位地址向左移动4位（也就是最开始段寄存器的地址x16），然后将左移4位后的段地址与偏移地址相加就可以得到一个20位的物理地址了。也可以理解成最开始的段寄存器的地址默认后面还有4位，只是都省略成0，这样就可以放在16位寄存器中了。\n\n## 实模式寻址方式\n\n实模式（Real mode） 是Intel 80286和之后的80x86兼容CPU的操作模式，所有的80x86CPU的开机状态都是实模式。实模式的特性是一个20位的存储器地址空间（即1MB的存储器）可以被寻址。为了兼容，也为了解决最开始的启动问题，Intel将所有80x86系列的CPU（包括最新型号的64位CPU）的硬件都设计为加电即进入16位实模式状态运行。在实模式状态下寄存器是16位的，地址总线是20位的，也就是说实模式下寻址空间为1MB。因此与8086这个16位机器一样，为了实现20位寻址依然采取段式寻址方式。\n\n开机时的第一个操作就是执行BIOS程序，CPU的硬件逻辑被设计为加电瞬间强行将CS的值设置为0XF000,IP的值设置为0XFFF0，这样CS:IP 的地址就是CS值左移四位变成0xF0000后加上IP的偏移地址也就是0xF0000+0XFFF0 也就是0xFFFF0，而0xFFFF0这个地址也就是BIOS程序的地址，CPU将开始执行这个地址的BIOS代码，从而开始BIOS的启动。\n\n## 参考\n\n《Linux内核设计的艺术》第二版\n\n<https://zh.wikipedia.org/wiki/X86#%E7%9C%9F%E5%AF%A6%E6%A8%A1%E5%BC%8F> \n\n<https://zh.wikipedia.org/wiki/Intel_8086#%E5%86%85%E5%AD%98%E5%88%86%E6%AE%B5> \n\n<https://zhuanlan.zhihu.com/p/69504370> \n\n<https://blog.csdn.net/unix21/article/details/8450214> \n\n","source":"_posts/2019-09-08-实模式寻址方式.md","raw":"---\ntitle: 实模式寻址方式\ndate: 2019-09-08 10:12:44\ncategories: 计算机基础\ntags:\n- 内存寻址\n- 寄存器\n- BIOS\ncopyright: true\n---\n\n# 实模式寻址方式\n\n在上《操作系统高级教程》课时有BIOS启动时的实模式，讲到 CS与IP这两个寄存器，但是始终不能理解为什么说CS:IP可以表示一个物理地址，查询后才理解到与实模式的寻址方式有关。\n\n<!--more-->\n\n## 8086的寻址方式\n\n为了理解实模式，首先需要理解Intel 8086这个16位CPU的寻址模式。\n\n8086的CPU是16位，即它的所有寄存器和寄存器之间的数据总线都是16位的，而其外部数据总线却是20位的。那么如何才能访问到20位也就是1MB的地址空间呢？显然一个寄存器是不够的所以就用两个寄存器来存储，这也就是段式寻址（内存分段）。段式寻址需要使用一个寄存器作为段寄存器比如CS代码段寄存器，使用另外一个寄存器比如IP指令指针寄存器作为偏移寄存器。计算物理地址的时候首先将段寄存器的16位地址向左移动4位（也就是最开始段寄存器的地址x16），然后将左移4位后的段地址与偏移地址相加就可以得到一个20位的物理地址了。也可以理解成最开始的段寄存器的地址默认后面还有4位，只是都省略成0，这样就可以放在16位寄存器中了。\n\n## 实模式寻址方式\n\n实模式（Real mode） 是Intel 80286和之后的80x86兼容CPU的操作模式，所有的80x86CPU的开机状态都是实模式。实模式的特性是一个20位的存储器地址空间（即1MB的存储器）可以被寻址。为了兼容，也为了解决最开始的启动问题，Intel将所有80x86系列的CPU（包括最新型号的64位CPU）的硬件都设计为加电即进入16位实模式状态运行。在实模式状态下寄存器是16位的，地址总线是20位的，也就是说实模式下寻址空间为1MB。因此与8086这个16位机器一样，为了实现20位寻址依然采取段式寻址方式。\n\n开机时的第一个操作就是执行BIOS程序，CPU的硬件逻辑被设计为加电瞬间强行将CS的值设置为0XF000,IP的值设置为0XFFF0，这样CS:IP 的地址就是CS值左移四位变成0xF0000后加上IP的偏移地址也就是0xF0000+0XFFF0 也就是0xFFFF0，而0xFFFF0这个地址也就是BIOS程序的地址，CPU将开始执行这个地址的BIOS代码，从而开始BIOS的启动。\n\n## 参考\n\n《Linux内核设计的艺术》第二版\n\n<https://zh.wikipedia.org/wiki/X86#%E7%9C%9F%E5%AF%A6%E6%A8%A1%E5%BC%8F> \n\n<https://zh.wikipedia.org/wiki/Intel_8086#%E5%86%85%E5%AD%98%E5%88%86%E6%AE%B5> \n\n<https://zhuanlan.zhihu.com/p/69504370> \n\n<https://blog.csdn.net/unix21/article/details/8450214> \n\n","slug":"2019-09-08-实模式寻址方式","published":1,"updated":"2019-11-08T13:12:18.272Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2yelxhh0010m8tz2gxmt8sw","content":"<h1 id=\"实模式寻址方式\"><a href=\"#实模式寻址方式\" class=\"headerlink\" title=\"实模式寻址方式\"></a>实模式寻址方式</h1><p>在上《操作系统高级教程》课时有BIOS启动时的实模式，讲到 CS与IP这两个寄存器，但是始终不能理解为什么说CS:IP可以表示一个物理地址，查询后才理解到与实模式的寻址方式有关。</p>\n<a id=\"more\"></a>\n<h2 id=\"8086的寻址方式\"><a href=\"#8086的寻址方式\" class=\"headerlink\" title=\"8086的寻址方式\"></a>8086的寻址方式</h2><p>为了理解实模式，首先需要理解Intel 8086这个16位CPU的寻址模式。</p>\n<p>8086的CPU是16位，即它的所有寄存器和寄存器之间的数据总线都是16位的，而其外部数据总线却是20位的。那么如何才能访问到20位也就是1MB的地址空间呢？显然一个寄存器是不够的所以就用两个寄存器来存储，这也就是段式寻址（内存分段）。段式寻址需要使用一个寄存器作为段寄存器比如CS代码段寄存器，使用另外一个寄存器比如IP指令指针寄存器作为偏移寄存器。计算物理地址的时候首先将段寄存器的16位地址向左移动4位（也就是最开始段寄存器的地址x16），然后将左移4位后的段地址与偏移地址相加就可以得到一个20位的物理地址了。也可以理解成最开始的段寄存器的地址默认后面还有4位，只是都省略成0，这样就可以放在16位寄存器中了。</p>\n<h2 id=\"实模式寻址方式-1\"><a href=\"#实模式寻址方式-1\" class=\"headerlink\" title=\"实模式寻址方式\"></a>实模式寻址方式</h2><p>实模式（Real mode） 是Intel 80286和之后的80x86兼容CPU的操作模式，所有的80x86CPU的开机状态都是实模式。实模式的特性是一个20位的存储器地址空间（即1MB的存储器）可以被寻址。为了兼容，也为了解决最开始的启动问题，Intel将所有80x86系列的CPU（包括最新型号的64位CPU）的硬件都设计为加电即进入16位实模式状态运行。在实模式状态下寄存器是16位的，地址总线是20位的，也就是说实模式下寻址空间为1MB。因此与8086这个16位机器一样，为了实现20位寻址依然采取段式寻址方式。</p>\n<p>开机时的第一个操作就是执行BIOS程序，CPU的硬件逻辑被设计为加电瞬间强行将CS的值设置为0XF000,IP的值设置为0XFFF0，这样CS:IP 的地址就是CS值左移四位变成0xF0000后加上IP的偏移地址也就是0xF0000+0XFFF0 也就是0xFFFF0，而0xFFFF0这个地址也就是BIOS程序的地址，CPU将开始执行这个地址的BIOS代码，从而开始BIOS的启动。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>《Linux内核设计的艺术》第二版</p>\n<p><a href=\"https://zh.wikipedia.org/wiki/X86#%E7%9C%9F%E5%AF%A6%E6%A8%A1%E5%BC%8F\" target=\"_blank\" rel=\"noopener\">https://zh.wikipedia.org/wiki/X86#%E7%9C%9F%E5%AF%A6%E6%A8%A1%E5%BC%8F</a> </p>\n<p><a href=\"https://zh.wikipedia.org/wiki/Intel_8086#%E5%86%85%E5%AD%98%E5%88%86%E6%AE%B5\" target=\"_blank\" rel=\"noopener\">https://zh.wikipedia.org/wiki/Intel_8086#%E5%86%85%E5%AD%98%E5%88%86%E6%AE%B5</a> </p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/69504370\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/69504370</a> </p>\n<p><a href=\"https://blog.csdn.net/unix21/article/details/8450214\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/unix21/article/details/8450214</a> </p>\n","site":{"data":{}},"length":1160,"excerpt":"<h1 id=\"实模式寻址方式\"><a href=\"#实模式寻址方式\" class=\"headerlink\" title=\"实模式寻址方式\"></a>实模式寻址方式</h1><p>在上《操作系统高级教程》课时有BIOS启动时的实模式，讲到 CS与IP这两个寄存器，但是始终不能理解为什么说CS:IP可以表示一个物理地址，查询后才理解到与实模式的寻址方式有关。</p>","more":"<h2 id=\"8086的寻址方式\"><a href=\"#8086的寻址方式\" class=\"headerlink\" title=\"8086的寻址方式\"></a>8086的寻址方式</h2><p>为了理解实模式，首先需要理解Intel 8086这个16位CPU的寻址模式。</p>\n<p>8086的CPU是16位，即它的所有寄存器和寄存器之间的数据总线都是16位的，而其外部数据总线却是20位的。那么如何才能访问到20位也就是1MB的地址空间呢？显然一个寄存器是不够的所以就用两个寄存器来存储，这也就是段式寻址（内存分段）。段式寻址需要使用一个寄存器作为段寄存器比如CS代码段寄存器，使用另外一个寄存器比如IP指令指针寄存器作为偏移寄存器。计算物理地址的时候首先将段寄存器的16位地址向左移动4位（也就是最开始段寄存器的地址x16），然后将左移4位后的段地址与偏移地址相加就可以得到一个20位的物理地址了。也可以理解成最开始的段寄存器的地址默认后面还有4位，只是都省略成0，这样就可以放在16位寄存器中了。</p>\n<h2 id=\"实模式寻址方式-1\"><a href=\"#实模式寻址方式-1\" class=\"headerlink\" title=\"实模式寻址方式\"></a>实模式寻址方式</h2><p>实模式（Real mode） 是Intel 80286和之后的80x86兼容CPU的操作模式，所有的80x86CPU的开机状态都是实模式。实模式的特性是一个20位的存储器地址空间（即1MB的存储器）可以被寻址。为了兼容，也为了解决最开始的启动问题，Intel将所有80x86系列的CPU（包括最新型号的64位CPU）的硬件都设计为加电即进入16位实模式状态运行。在实模式状态下寄存器是16位的，地址总线是20位的，也就是说实模式下寻址空间为1MB。因此与8086这个16位机器一样，为了实现20位寻址依然采取段式寻址方式。</p>\n<p>开机时的第一个操作就是执行BIOS程序，CPU的硬件逻辑被设计为加电瞬间强行将CS的值设置为0XF000,IP的值设置为0XFFF0，这样CS:IP 的地址就是CS值左移四位变成0xF0000后加上IP的偏移地址也就是0xF0000+0XFFF0 也就是0xFFFF0，而0xFFFF0这个地址也就是BIOS程序的地址，CPU将开始执行这个地址的BIOS代码，从而开始BIOS的启动。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>《Linux内核设计的艺术》第二版</p>\n<p><a href=\"https://zh.wikipedia.org/wiki/X86#%E7%9C%9F%E5%AF%A6%E6%A8%A1%E5%BC%8F\" target=\"_blank\" rel=\"noopener\">https://zh.wikipedia.org/wiki/X86#%E7%9C%9F%E5%AF%A6%E6%A8%A1%E5%BC%8F</a> </p>\n<p><a href=\"https://zh.wikipedia.org/wiki/Intel_8086#%E5%86%85%E5%AD%98%E5%88%86%E6%AE%B5\" target=\"_blank\" rel=\"noopener\">https://zh.wikipedia.org/wiki/Intel_8086#%E5%86%85%E5%AD%98%E5%88%86%E6%AE%B5</a> </p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/69504370\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/69504370</a> </p>\n<p><a href=\"https://blog.csdn.net/unix21/article/details/8450214\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/unix21/article/details/8450214</a> </p>"},{"title":"shadowsocks的部署","date":"2019-08-24T04:59:32.000Z","copyright":true,"_content":"\n# shadowsocks 的部署\n\n部署shadowsocks主要有两个作用：\n\n1. 可以翻墙 \n2. 可以白嫖校园网的ipv6 \n\n<!--more-->\n\n## 1. 购买VPS服务器\n\n目前使用vultr的VPS服务器，5刀一个月，使用的CENTOS发行版。貌似日本的服务器网速最快，而且支持IPV6。在部署服务器的时候就需要开启IPV6。\n\n## 2. 服务器设置\n\n### 安装\n\n在/root/目录下创建文件夹\n\n```shell\nmkdir shadowsocks\ncd shadowsocks/\n```\n\n安装python和pip工具以及git\n\n```shell\nyum install python-setuptools && easy_install pip\nyum install git \n```\n\n使用pip通过git安装shadowsocks\n\n```\npip install git+https://github.com/shadowsocks/shadowsocks.git@master\nssserver\n```\n\nssserver 命令用来查看是否安装成功\n\n### 脚本\n\n```\n vi shadowsocks.json\n```\n\n脚本内容为：\n\n多端口账户脚本如下\n\n```json\n{\n    \"server\":\"::\",\n    \"local_address\": \"127.0.0.1\",\n    \"local_port\":1080,\n    \"port_password\":{\n    \"8388\":\"frankfurt123\",\n \t\"2343\":\"password\"\n},\n    \"timeout\":300,\n    \"method\":\"aes-256-cfb\",\n    \"fast_open\": false\n}\n```\n\n其中server:\"::\" 用两个:: 冒号来表示可以同时使用ipv4和ipv6来访问服务器，如果就只有ipv4的地址的话，只能使用ipv4来翻墙。\n\n通过脚本来启动shadowsocks\n\n```shell\n ssserver -c /root/shadowsocks/shadowsocks.json -d start\n ssserver -c /root/shadowsocks/shadowsocks.json -d status\n ssserver -c /root/shadowsocks/shadowsocks.json -d stop\n```\n\n至此通过添加服务器配置就应该可以使用shadowsocks+switchomega客户端了，如果还不可以的话，多半是因为防火墙的问题。\n\n### 防火墙设置\n\n将8388添加到防火墙白名单。\n\n```\nfirewall-cmd --zone=public --add-port=8388/tcp --permanent\nfirewall-cmd --reload\nfirewall-cmd --list-ports\n```\n\n## 客户端设置\n\n我使用的是win10 可以从：<https://github.com/shadowsocks/shadowsocks-windows> 下载\n\nMacOS：<https://github.com/shadowsocks/ShadowsocksX-NG/releases> \n\n在服务器设置界面依次添加IPV6的地址、端口、密码、加密方式就可以使用IPV6进行白嫖了。\n\n## 参考\n\n<https://github.com/shadowsocks/shadowsocks/tree/master> ","source":"_posts/2019-08-24-shadowsocks的部署.md","raw":"---\ntitle: shadowsocks的部署\ndate: 2019-08-24 12:59:32\ncategories: deploy\ntags:\n- shadowsocks\n- 翻墙\n- ipv6\ncopyright: true\n---\n\n# shadowsocks 的部署\n\n部署shadowsocks主要有两个作用：\n\n1. 可以翻墙 \n2. 可以白嫖校园网的ipv6 \n\n<!--more-->\n\n## 1. 购买VPS服务器\n\n目前使用vultr的VPS服务器，5刀一个月，使用的CENTOS发行版。貌似日本的服务器网速最快，而且支持IPV6。在部署服务器的时候就需要开启IPV6。\n\n## 2. 服务器设置\n\n### 安装\n\n在/root/目录下创建文件夹\n\n```shell\nmkdir shadowsocks\ncd shadowsocks/\n```\n\n安装python和pip工具以及git\n\n```shell\nyum install python-setuptools && easy_install pip\nyum install git \n```\n\n使用pip通过git安装shadowsocks\n\n```\npip install git+https://github.com/shadowsocks/shadowsocks.git@master\nssserver\n```\n\nssserver 命令用来查看是否安装成功\n\n### 脚本\n\n```\n vi shadowsocks.json\n```\n\n脚本内容为：\n\n多端口账户脚本如下\n\n```json\n{\n    \"server\":\"::\",\n    \"local_address\": \"127.0.0.1\",\n    \"local_port\":1080,\n    \"port_password\":{\n    \"8388\":\"frankfurt123\",\n \t\"2343\":\"password\"\n},\n    \"timeout\":300,\n    \"method\":\"aes-256-cfb\",\n    \"fast_open\": false\n}\n```\n\n其中server:\"::\" 用两个:: 冒号来表示可以同时使用ipv4和ipv6来访问服务器，如果就只有ipv4的地址的话，只能使用ipv4来翻墙。\n\n通过脚本来启动shadowsocks\n\n```shell\n ssserver -c /root/shadowsocks/shadowsocks.json -d start\n ssserver -c /root/shadowsocks/shadowsocks.json -d status\n ssserver -c /root/shadowsocks/shadowsocks.json -d stop\n```\n\n至此通过添加服务器配置就应该可以使用shadowsocks+switchomega客户端了，如果还不可以的话，多半是因为防火墙的问题。\n\n### 防火墙设置\n\n将8388添加到防火墙白名单。\n\n```\nfirewall-cmd --zone=public --add-port=8388/tcp --permanent\nfirewall-cmd --reload\nfirewall-cmd --list-ports\n```\n\n## 客户端设置\n\n我使用的是win10 可以从：<https://github.com/shadowsocks/shadowsocks-windows> 下载\n\nMacOS：<https://github.com/shadowsocks/ShadowsocksX-NG/releases> \n\n在服务器设置界面依次添加IPV6的地址、端口、密码、加密方式就可以使用IPV6进行白嫖了。\n\n## 参考\n\n<https://github.com/shadowsocks/shadowsocks/tree/master> ","slug":"2019-08-24-shadowsocks的部署","published":1,"updated":"2019-11-08T13:11:18.313Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2yelxhi0011m8tzbw62unnt","content":"<h1 id=\"shadowsocks-的部署\"><a href=\"#shadowsocks-的部署\" class=\"headerlink\" title=\"shadowsocks 的部署\"></a>shadowsocks 的部署</h1><p>部署shadowsocks主要有两个作用：</p>\n<ol>\n<li>可以翻墙 </li>\n<li>可以白嫖校园网的ipv6 </li>\n</ol>\n<a id=\"more\"></a>\n<h2 id=\"1-购买VPS服务器\"><a href=\"#1-购买VPS服务器\" class=\"headerlink\" title=\"1. 购买VPS服务器\"></a>1. 购买VPS服务器</h2><p>目前使用vultr的VPS服务器，5刀一个月，使用的CENTOS发行版。貌似日本的服务器网速最快，而且支持IPV6。在部署服务器的时候就需要开启IPV6。</p>\n<h2 id=\"2-服务器设置\"><a href=\"#2-服务器设置\" class=\"headerlink\" title=\"2. 服务器设置\"></a>2. 服务器设置</h2><h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>在/root/目录下创建文件夹</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir shadowsocks</span><br><span class=\"line\">cd shadowsocks/</span><br></pre></td></tr></table></figure>\n<p>安装python和pip工具以及git</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install python-setuptools &amp;&amp; easy_install pip</span><br><span class=\"line\">yum install git</span><br></pre></td></tr></table></figure>\n<p>使用pip通过git安装shadowsocks</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install git+https://github.com/shadowsocks/shadowsocks.git@master</span><br><span class=\"line\">ssserver</span><br></pre></td></tr></table></figure>\n<p>ssserver 命令用来查看是否安装成功</p>\n<h3 id=\"脚本\"><a href=\"#脚本\" class=\"headerlink\" title=\"脚本\"></a>脚本</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi shadowsocks.json</span><br></pre></td></tr></table></figure>\n<p>脚本内容为：</p>\n<p>多端口账户脚本如下</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"server\"</span>:<span class=\"string\">\"::\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"local_address\"</span>: <span class=\"string\">\"127.0.0.1\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"local_port\"</span>:<span class=\"number\">1080</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"port_password\"</span>:&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"8388\"</span>:<span class=\"string\">\"frankfurt123\"</span>,</span><br><span class=\"line\"> \t<span class=\"attr\">\"2343\"</span>:<span class=\"string\">\"password\"</span></span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">    <span class=\"attr\">\"timeout\"</span>:<span class=\"number\">300</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"method\"</span>:<span class=\"string\">\"aes-256-cfb\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"fast_open\"</span>: <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中server:”::” 用两个:: 冒号来表示可以同时使用ipv4和ipv6来访问服务器，如果就只有ipv4的地址的话，只能使用ipv4来翻墙。</p>\n<p>通过脚本来启动shadowsocks</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssserver -c /root/shadowsocks/shadowsocks.json -d start</span><br><span class=\"line\">ssserver -c /root/shadowsocks/shadowsocks.json -d status</span><br><span class=\"line\">ssserver -c /root/shadowsocks/shadowsocks.json -d stop</span><br></pre></td></tr></table></figure>\n<p>至此通过添加服务器配置就应该可以使用shadowsocks+switchomega客户端了，如果还不可以的话，多半是因为防火墙的问题。</p>\n<h3 id=\"防火墙设置\"><a href=\"#防火墙设置\" class=\"headerlink\" title=\"防火墙设置\"></a>防火墙设置</h3><p>将8388添加到防火墙白名单。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">firewall-cmd --zone=public --add-port=8388/tcp --permanent</span><br><span class=\"line\">firewall-cmd --reload</span><br><span class=\"line\">firewall-cmd --list-ports</span><br></pre></td></tr></table></figure>\n<h2 id=\"客户端设置\"><a href=\"#客户端设置\" class=\"headerlink\" title=\"客户端设置\"></a>客户端设置</h2><p>我使用的是win10 可以从：<a href=\"https://github.com/shadowsocks/shadowsocks-windows\" target=\"_blank\" rel=\"noopener\">https://github.com/shadowsocks/shadowsocks-windows</a> 下载</p>\n<p>MacOS：<a href=\"https://github.com/shadowsocks/ShadowsocksX-NG/releases\" target=\"_blank\" rel=\"noopener\">https://github.com/shadowsocks/ShadowsocksX-NG/releases</a> </p>\n<p>在服务器设置界面依次添加IPV6的地址、端口、密码、加密方式就可以使用IPV6进行白嫖了。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://github.com/shadowsocks/shadowsocks/tree/master\" target=\"_blank\" rel=\"noopener\">https://github.com/shadowsocks/shadowsocks/tree/master</a> </p>\n","site":{"data":{}},"length":1313,"excerpt":"<h1 id=\"shadowsocks-的部署\"><a href=\"#shadowsocks-的部署\" class=\"headerlink\" title=\"shadowsocks 的部署\"></a>shadowsocks 的部署</h1><p>部署shadowsocks主要有两个作用：</p>\n<ol>\n<li>可以翻墙 </li>\n<li>可以白嫖校园网的ipv6 </li>\n</ol>","more":"<h2 id=\"1-购买VPS服务器\"><a href=\"#1-购买VPS服务器\" class=\"headerlink\" title=\"1. 购买VPS服务器\"></a>1. 购买VPS服务器</h2><p>目前使用vultr的VPS服务器，5刀一个月，使用的CENTOS发行版。貌似日本的服务器网速最快，而且支持IPV6。在部署服务器的时候就需要开启IPV6。</p>\n<h2 id=\"2-服务器设置\"><a href=\"#2-服务器设置\" class=\"headerlink\" title=\"2. 服务器设置\"></a>2. 服务器设置</h2><h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>在/root/目录下创建文件夹</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir shadowsocks</span><br><span class=\"line\">cd shadowsocks/</span><br></pre></td></tr></table></figure>\n<p>安装python和pip工具以及git</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install python-setuptools &amp;&amp; easy_install pip</span><br><span class=\"line\">yum install git</span><br></pre></td></tr></table></figure>\n<p>使用pip通过git安装shadowsocks</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install git+https://github.com/shadowsocks/shadowsocks.git@master</span><br><span class=\"line\">ssserver</span><br></pre></td></tr></table></figure>\n<p>ssserver 命令用来查看是否安装成功</p>\n<h3 id=\"脚本\"><a href=\"#脚本\" class=\"headerlink\" title=\"脚本\"></a>脚本</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi shadowsocks.json</span><br></pre></td></tr></table></figure>\n<p>脚本内容为：</p>\n<p>多端口账户脚本如下</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"server\"</span>:<span class=\"string\">\"::\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"local_address\"</span>: <span class=\"string\">\"127.0.0.1\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"local_port\"</span>:<span class=\"number\">1080</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"port_password\"</span>:&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"8388\"</span>:<span class=\"string\">\"frankfurt123\"</span>,</span><br><span class=\"line\"> \t<span class=\"attr\">\"2343\"</span>:<span class=\"string\">\"password\"</span></span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">    <span class=\"attr\">\"timeout\"</span>:<span class=\"number\">300</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"method\"</span>:<span class=\"string\">\"aes-256-cfb\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"fast_open\"</span>: <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中server:”::” 用两个:: 冒号来表示可以同时使用ipv4和ipv6来访问服务器，如果就只有ipv4的地址的话，只能使用ipv4来翻墙。</p>\n<p>通过脚本来启动shadowsocks</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssserver -c /root/shadowsocks/shadowsocks.json -d start</span><br><span class=\"line\">ssserver -c /root/shadowsocks/shadowsocks.json -d status</span><br><span class=\"line\">ssserver -c /root/shadowsocks/shadowsocks.json -d stop</span><br></pre></td></tr></table></figure>\n<p>至此通过添加服务器配置就应该可以使用shadowsocks+switchomega客户端了，如果还不可以的话，多半是因为防火墙的问题。</p>\n<h3 id=\"防火墙设置\"><a href=\"#防火墙设置\" class=\"headerlink\" title=\"防火墙设置\"></a>防火墙设置</h3><p>将8388添加到防火墙白名单。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">firewall-cmd --zone=public --add-port=8388/tcp --permanent</span><br><span class=\"line\">firewall-cmd --reload</span><br><span class=\"line\">firewall-cmd --list-ports</span><br></pre></td></tr></table></figure>\n<h2 id=\"客户端设置\"><a href=\"#客户端设置\" class=\"headerlink\" title=\"客户端设置\"></a>客户端设置</h2><p>我使用的是win10 可以从：<a href=\"https://github.com/shadowsocks/shadowsocks-windows\" target=\"_blank\" rel=\"noopener\">https://github.com/shadowsocks/shadowsocks-windows</a> 下载</p>\n<p>MacOS：<a href=\"https://github.com/shadowsocks/ShadowsocksX-NG/releases\" target=\"_blank\" rel=\"noopener\">https://github.com/shadowsocks/ShadowsocksX-NG/releases</a> </p>\n<p>在服务器设置界面依次添加IPV6的地址、端口、密码、加密方式就可以使用IPV6进行白嫖了。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://github.com/shadowsocks/shadowsocks/tree/master\" target=\"_blank\" rel=\"noopener\">https://github.com/shadowsocks/shadowsocks/tree/master</a> </p>"},{"title":"逆序对的计数","date":"2019-10-07T03:07:35.000Z","copyright":true,"mathjax":true,"_content":"\n# 逆序对的计数\n\nleetcode#493题，给定一个数组A，寻找i<j，但是有A[i]>A[j]的数目。变种为重要逆序对的寻找即寻找A[i]>kA[j]的数目。\n\n题目来源：https://leetcode.com/problems/reverse-pairs/\n\n<!--more-->\n\n## 解题思路\n\n基本的逆序对与重要逆序对思路一致，因此只对逆序对进行讲解。\n\n### 暴力枚举\n\n从前往后遍历数组，枚举出所有(A[i],A[j])，然后统计符合条件的重要逆序对的数目，很明显所需要的时间复杂度为\n\n$O(n^2)$\n\n### 分治\n\n#### 分析\n\n先考虑最简单的情况：\n\n如果input的数组长度为n=1，则输出为0，不存在逆序对。会做\n\nn=2的时候，可以分解成两个n=1的情况。因为左右两边都是一个元素自然都不存在逆序对，考虑一个元素在左边，一个在右边的情况可以得出(8,4)一个逆序对的情况，所以输出为1。会做\n\nn=4的时候：同样的可以分解成两个n=2的情况，因为我们已经解决了n=2的问题。这时候左边数组存在一个(8,4)的逆序对，右边数组存在一个(3,2)的逆序对。这时候主要考虑的是交叉的情况，如果左右两个数组都是没有结构的，那么只能用两个指针来挨个遍历左右两边的数组了时间复杂度为$O(n^2)$ 。如果左右两边数组都是有序的情况下，就可以减少很多冗余的比较操作了，当$L_i>R_j$ 时，左边数组位于$L_i$ 后面的元素肯定都会大于$R_j$ ，因此就不用在比较$L_i$ 后面的元素了,将右边数组指针+1寻找更大的元素来进行比较。当$L_i<R_j$时，需要将左边的指针+1，寻找一个更大的左边元素进行比较。因为左右指针总共的移动次数不超过数组长度，所以这时的复杂度为$O(n)$。以图中的例子来说明，当有4大于3的时候，就不需要比较8是否大于3了。\n\n一个形象的比喻是两个人打牌，一个人L拿的是左边的数组，另一个人R是右边的数组，牌已经从小到大整理好了。如果L最小的牌比R的最小的牌都大，那么L手中所有的牌都比R的最小的牌大。R要找到比L当前牌更大的牌只能向后寻找，如果找不到说明，L所有的牌都比R大，如果找到了是$R_j$那么L就向后面再找一个新的比$R_j$的牌大的新牌$L_i$ 。规则就是从左到右出牌，牌小的先出，最后谁的牌出完那么游戏结束，结束逆序对的统计。\n\n![](https://res.cloudinary.com/bravey/image/upload/v1570434502/blog/reversepairs.jpg)\n\n#### 归纳\n\n可以看到，在上述分析过程中我们可以将输入为n的数组不断划分为原来的一半直至最后n=1的情况，从n=1的情况再向上合并得到上层问题的答案，也就是归并排序的过程中加上了逆序对的统计，这是一个很典型的分治策略。\n\n**Divide** 将输入数组A划分为左边A[0, n/2] 与右边A[n/2+1, n-1]两个数组\n\n**Conquer** 左边的逆序对数目与右边的逆序对数目分别再各自递归的调用函数求解，同时对其排序。\n\n**Merge** 统计逆序对元素交叉在左右两边的情况，并将两个排好序的子数组合并成一个新的有序数组\n\n#### 复杂度\n\n将规模为n的问题分解成两个两个$\\frac{n}{2}$ 的子问题问题，同时对两个子问题进行合并的复杂度为O(n)，所以有递推公式：\n\n\n$$\nT(n)=\\left\\{\n  \\begin{array}{**lr**}  \n             1 &  n=1\\\\\\\\  \n             2T(\\frac{n}{2})+O(n)\n             \\end{array}  \n\\right.\n$$\n根据主定理有最后的复杂度为$O(n\\log(n))$\n\n### 代码\n\n```c++\n/*\nhttps://leetcode.com/problems/reverse-pairs/\n */\n#include <iostream>\n#include <vector>\nusing namespace std;\nclass Solution {\n\tvector<int> tmp_vec;//把tmp_vec设置成共有变量，而不在函数中设置为临时变量可以减少多次对其创建与销毁，提高效率\npublic:\n    int reversePairs(vector<int>& nums) {\n    \tint size = nums.size();\n    \ttmp_vec.resize(nums.size());\n        return MergeSort(nums, 0, size-1); // 不用全局变量否则，多线程的时候会被修改。\n    }\n\nprivate:\n\tint MergeSort(vector<int>& vec, int lo, int hi){\n\t\tif(lo>=hi) return 0;// base case 递归必备\n\t\tint mid = lo + (hi -lo)/2; //防止两个超级大的int相加后造成溢出\n\t\tint ans = 0;\n\t\tans += MergeSort(vec, lo, mid); //左边merge的计数\n\t\tans += MergeSort(vec, mid+1, hi); //右边merge的计数\n\t\tans += Merge(vec, lo, hi, mid);// 返回什么？ 本次merge的技术 也就是split 的情况\n\t\treturn ans;\n\t}\n\n\tint Merge(vector<int>& vec, int lo, int hi, int mid){ //采用双指针来一次把左右两边的小值冒泡出来放到合并后的数组中，同时完成对逆序数目的统计\n\t\tint p = lo;\n\t\tint q = mid + 1;\n\t\tint count = 0;//记录逆序数目\n\t\tint index = lo;\n\t\twhile(p<=mid&&q<=hi){\n\t\t\tif((long)vec[p] > (long)vec[q]*3){\n\t\t\t\tcount += mid-p+1;\n\t\t\t\tq++;\n\t\t\t}else{\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\t\t//正常的merge操作\n\t\tp = lo ;\n\t\tq = mid + 1;\n\t\twhile(p<=mid&&q<=hi){\n\t\t\tif(vec[p]>=vec[q]) tmp_vec[index++]=vec[q++];\n\t\t\telse tmp_vec[index++]=vec[p++];\n\t\t}\n\t\twhile(p<=mid) tmp_vec[index++]=vec[p++];\n\t\twhile(q<=hi) tmp_vec[index++]=vec[q++];\n\t\tfor(int i=lo; i<=hi; i++){\n\t\t\tvec[i] = tmp_vec[i];\n\t\t}\n\t\treturn count;\n\t}    \n};\n\nint main(){\n\tSolution Sol;\n\tvector<int> vec;\n\tint n ;\n\twhile(cin>>n){\n\t\t//int tmp = n;\n\t\tint element;\n\t\twhile(n--){\n\t\t\tcin>>element;\n\t\t\tvec.push_back(element);\n\t\t}\n\t\tcout<<Sol.reversePairs(vec)<<endl;\n\t}\n\t\n}\n```\n\n","source":"_posts/2019-10-07-逆序对的计数.md","raw":"---\ntitle: 逆序对的计数\ndate: 2019-10-07 11:07:35\ncategories: 题解\ntags:\n- leetcode\n- 归并排序\n- 分治\ncopyright: true\nmathjax: true\n---\n\n# 逆序对的计数\n\nleetcode#493题，给定一个数组A，寻找i<j，但是有A[i]>A[j]的数目。变种为重要逆序对的寻找即寻找A[i]>kA[j]的数目。\n\n题目来源：https://leetcode.com/problems/reverse-pairs/\n\n<!--more-->\n\n## 解题思路\n\n基本的逆序对与重要逆序对思路一致，因此只对逆序对进行讲解。\n\n### 暴力枚举\n\n从前往后遍历数组，枚举出所有(A[i],A[j])，然后统计符合条件的重要逆序对的数目，很明显所需要的时间复杂度为\n\n$O(n^2)$\n\n### 分治\n\n#### 分析\n\n先考虑最简单的情况：\n\n如果input的数组长度为n=1，则输出为0，不存在逆序对。会做\n\nn=2的时候，可以分解成两个n=1的情况。因为左右两边都是一个元素自然都不存在逆序对，考虑一个元素在左边，一个在右边的情况可以得出(8,4)一个逆序对的情况，所以输出为1。会做\n\nn=4的时候：同样的可以分解成两个n=2的情况，因为我们已经解决了n=2的问题。这时候左边数组存在一个(8,4)的逆序对，右边数组存在一个(3,2)的逆序对。这时候主要考虑的是交叉的情况，如果左右两个数组都是没有结构的，那么只能用两个指针来挨个遍历左右两边的数组了时间复杂度为$O(n^2)$ 。如果左右两边数组都是有序的情况下，就可以减少很多冗余的比较操作了，当$L_i>R_j$ 时，左边数组位于$L_i$ 后面的元素肯定都会大于$R_j$ ，因此就不用在比较$L_i$ 后面的元素了,将右边数组指针+1寻找更大的元素来进行比较。当$L_i<R_j$时，需要将左边的指针+1，寻找一个更大的左边元素进行比较。因为左右指针总共的移动次数不超过数组长度，所以这时的复杂度为$O(n)$。以图中的例子来说明，当有4大于3的时候，就不需要比较8是否大于3了。\n\n一个形象的比喻是两个人打牌，一个人L拿的是左边的数组，另一个人R是右边的数组，牌已经从小到大整理好了。如果L最小的牌比R的最小的牌都大，那么L手中所有的牌都比R的最小的牌大。R要找到比L当前牌更大的牌只能向后寻找，如果找不到说明，L所有的牌都比R大，如果找到了是$R_j$那么L就向后面再找一个新的比$R_j$的牌大的新牌$L_i$ 。规则就是从左到右出牌，牌小的先出，最后谁的牌出完那么游戏结束，结束逆序对的统计。\n\n![](https://res.cloudinary.com/bravey/image/upload/v1570434502/blog/reversepairs.jpg)\n\n#### 归纳\n\n可以看到，在上述分析过程中我们可以将输入为n的数组不断划分为原来的一半直至最后n=1的情况，从n=1的情况再向上合并得到上层问题的答案，也就是归并排序的过程中加上了逆序对的统计，这是一个很典型的分治策略。\n\n**Divide** 将输入数组A划分为左边A[0, n/2] 与右边A[n/2+1, n-1]两个数组\n\n**Conquer** 左边的逆序对数目与右边的逆序对数目分别再各自递归的调用函数求解，同时对其排序。\n\n**Merge** 统计逆序对元素交叉在左右两边的情况，并将两个排好序的子数组合并成一个新的有序数组\n\n#### 复杂度\n\n将规模为n的问题分解成两个两个$\\frac{n}{2}$ 的子问题问题，同时对两个子问题进行合并的复杂度为O(n)，所以有递推公式：\n\n\n$$\nT(n)=\\left\\{\n  \\begin{array}{**lr**}  \n             1 &  n=1\\\\\\\\  \n             2T(\\frac{n}{2})+O(n)\n             \\end{array}  \n\\right.\n$$\n根据主定理有最后的复杂度为$O(n\\log(n))$\n\n### 代码\n\n```c++\n/*\nhttps://leetcode.com/problems/reverse-pairs/\n */\n#include <iostream>\n#include <vector>\nusing namespace std;\nclass Solution {\n\tvector<int> tmp_vec;//把tmp_vec设置成共有变量，而不在函数中设置为临时变量可以减少多次对其创建与销毁，提高效率\npublic:\n    int reversePairs(vector<int>& nums) {\n    \tint size = nums.size();\n    \ttmp_vec.resize(nums.size());\n        return MergeSort(nums, 0, size-1); // 不用全局变量否则，多线程的时候会被修改。\n    }\n\nprivate:\n\tint MergeSort(vector<int>& vec, int lo, int hi){\n\t\tif(lo>=hi) return 0;// base case 递归必备\n\t\tint mid = lo + (hi -lo)/2; //防止两个超级大的int相加后造成溢出\n\t\tint ans = 0;\n\t\tans += MergeSort(vec, lo, mid); //左边merge的计数\n\t\tans += MergeSort(vec, mid+1, hi); //右边merge的计数\n\t\tans += Merge(vec, lo, hi, mid);// 返回什么？ 本次merge的技术 也就是split 的情况\n\t\treturn ans;\n\t}\n\n\tint Merge(vector<int>& vec, int lo, int hi, int mid){ //采用双指针来一次把左右两边的小值冒泡出来放到合并后的数组中，同时完成对逆序数目的统计\n\t\tint p = lo;\n\t\tint q = mid + 1;\n\t\tint count = 0;//记录逆序数目\n\t\tint index = lo;\n\t\twhile(p<=mid&&q<=hi){\n\t\t\tif((long)vec[p] > (long)vec[q]*3){\n\t\t\t\tcount += mid-p+1;\n\t\t\t\tq++;\n\t\t\t}else{\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\t\t//正常的merge操作\n\t\tp = lo ;\n\t\tq = mid + 1;\n\t\twhile(p<=mid&&q<=hi){\n\t\t\tif(vec[p]>=vec[q]) tmp_vec[index++]=vec[q++];\n\t\t\telse tmp_vec[index++]=vec[p++];\n\t\t}\n\t\twhile(p<=mid) tmp_vec[index++]=vec[p++];\n\t\twhile(q<=hi) tmp_vec[index++]=vec[q++];\n\t\tfor(int i=lo; i<=hi; i++){\n\t\t\tvec[i] = tmp_vec[i];\n\t\t}\n\t\treturn count;\n\t}    \n};\n\nint main(){\n\tSolution Sol;\n\tvector<int> vec;\n\tint n ;\n\twhile(cin>>n){\n\t\t//int tmp = n;\n\t\tint element;\n\t\twhile(n--){\n\t\t\tcin>>element;\n\t\t\tvec.push_back(element);\n\t\t}\n\t\tcout<<Sol.reversePairs(vec)<<endl;\n\t}\n\t\n}\n```\n\n","slug":"2019-10-07-逆序对的计数","published":1,"updated":"2019-11-13T16:47:53.243Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2yelxhk0014m8tzqxcxl1qh","content":"<h1 id=\"逆序对的计数\"><a href=\"#逆序对的计数\" class=\"headerlink\" title=\"逆序对的计数\"></a>逆序对的计数</h1><p>leetcode#493题，给定一个数组A，寻找i<j，但是有a[i]>A[j]的数目。变种为重要逆序对的寻找即寻找A[i]&gt;kA[j]的数目。</j，但是有a[i]></p>\n<p>题目来源：<a href=\"https://leetcode.com/problems/reverse-pairs/\" target=\"_blank\" rel=\"noopener\">https://leetcode.com/problems/reverse-pairs/</a></p>\n<a id=\"more\"></a>\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>基本的逆序对与重要逆序对思路一致，因此只对逆序对进行讲解。</p>\n<h3 id=\"暴力枚举\"><a href=\"#暴力枚举\" class=\"headerlink\" title=\"暴力枚举\"></a>暴力枚举</h3><p>从前往后遍历数组，枚举出所有(A[i],A[j])，然后统计符合条件的重要逆序对的数目，很明显所需要的时间复杂度为</p>\n<p>$O(n^2)$</p>\n<h3 id=\"分治\"><a href=\"#分治\" class=\"headerlink\" title=\"分治\"></a>分治</h3><h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><p>先考虑最简单的情况：</p>\n<p>如果input的数组长度为n=1，则输出为0，不存在逆序对。会做</p>\n<p>n=2的时候，可以分解成两个n=1的情况。因为左右两边都是一个元素自然都不存在逆序对，考虑一个元素在左边，一个在右边的情况可以得出(8,4)一个逆序对的情况，所以输出为1。会做</p>\n<p>n=4的时候：同样的可以分解成两个n=2的情况，因为我们已经解决了n=2的问题。这时候左边数组存在一个(8,4)的逆序对，右边数组存在一个(3,2)的逆序对。这时候主要考虑的是交叉的情况，如果左右两个数组都是没有结构的，那么只能用两个指针来挨个遍历左右两边的数组了时间复杂度为$O(n^2)$ 。如果左右两边数组都是有序的情况下，就可以减少很多冗余的比较操作了，当$L_i&gt;R_j$ 时，左边数组位于$L_i$ 后面的元素肯定都会大于$R_j$ ，因此就不用在比较$L_i$ 后面的元素了,将右边数组指针+1寻找更大的元素来进行比较。当$L_i&lt;R_j$时，需要将左边的指针+1，寻找一个更大的左边元素进行比较。因为左右指针总共的移动次数不超过数组长度，所以这时的复杂度为$O(n)$。以图中的例子来说明，当有4大于3的时候，就不需要比较8是否大于3了。</p>\n<p>一个形象的比喻是两个人打牌，一个人L拿的是左边的数组，另一个人R是右边的数组，牌已经从小到大整理好了。如果L最小的牌比R的最小的牌都大，那么L手中所有的牌都比R的最小的牌大。R要找到比L当前牌更大的牌只能向后寻找，如果找不到说明，L所有的牌都比R大，如果找到了是$R_j$那么L就向后面再找一个新的比$R_j$的牌大的新牌$L_i$ 。规则就是从左到右出牌，牌小的先出，最后谁的牌出完那么游戏结束，结束逆序对的统计。</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1570434502/blog/reversepairs.jpg\" alt=\"\"></p>\n<h4 id=\"归纳\"><a href=\"#归纳\" class=\"headerlink\" title=\"归纳\"></a>归纳</h4><p>可以看到，在上述分析过程中我们可以将输入为n的数组不断划分为原来的一半直至最后n=1的情况，从n=1的情况再向上合并得到上层问题的答案，也就是归并排序的过程中加上了逆序对的统计，这是一个很典型的分治策略。</p>\n<p><strong>Divide</strong> 将输入数组A划分为左边A[0, n/2] 与右边A[n/2+1, n-1]两个数组</p>\n<p><strong>Conquer</strong> 左边的逆序对数目与右边的逆序对数目分别再各自递归的调用函数求解，同时对其排序。</p>\n<p><strong>Merge</strong> 统计逆序对元素交叉在左右两边的情况，并将两个排好序的子数组合并成一个新的有序数组</p>\n<h4 id=\"复杂度\"><a href=\"#复杂度\" class=\"headerlink\" title=\"复杂度\"></a>复杂度</h4><p>将规模为n的问题分解成两个两个$\\frac{n}{2}$ 的子问题问题，同时对两个子问题进行合并的复杂度为O(n)，所以有递推公式：</p>\n<script type=\"math/tex; mode=display\">\nT(n)=\\left\\{\n  \\begin{array}{**lr**}  \n             1 &  n=1\\\\\\\\  \n             2T(\\frac{n}{2})+O(n)\n             \\end{array}  \n\\right.</script><p>根据主定理有最后的复杂度为$O(n\\log(n))$</p>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">https://leetcode.com/problems/reverse-pairs/</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; tmp_vec;<span class=\"comment\">//把tmp_vec设置成共有变量，而不在函数中设置为临时变量可以减少多次对其创建与销毁，提高效率</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">reversePairs</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">int</span> size = nums.size();</span><br><span class=\"line\">    \ttmp_vec.resize(nums.size());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> MergeSort(nums, <span class=\"number\">0</span>, size<span class=\"number\">-1</span>); <span class=\"comment\">// 不用全局变量否则，多线程的时候会被修改。</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">MergeSort</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; vec, <span class=\"keyword\">int</span> lo, <span class=\"keyword\">int</span> hi)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(lo&gt;=hi) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;<span class=\"comment\">// base case 递归必备</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> mid = lo + (hi -lo)/<span class=\"number\">2</span>; <span class=\"comment\">//防止两个超级大的int相加后造成溢出</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tans += MergeSort(vec, lo, mid); <span class=\"comment\">//左边merge的计数</span></span><br><span class=\"line\">\t\tans += MergeSort(vec, mid+<span class=\"number\">1</span>, hi); <span class=\"comment\">//右边merge的计数</span></span><br><span class=\"line\">\t\tans += Merge(vec, lo, hi, mid);<span class=\"comment\">// 返回什么？ 本次merge的技术 也就是split 的情况</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Merge</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; vec, <span class=\"keyword\">int</span> lo, <span class=\"keyword\">int</span> hi, <span class=\"keyword\">int</span> mid)</span></span>&#123; <span class=\"comment\">//采用双指针来一次把左右两边的小值冒泡出来放到合并后的数组中，同时完成对逆序数目的统计</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> p = lo;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> q = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;<span class=\"comment\">//记录逆序数目</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> index = lo;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(p&lt;=mid&amp;&amp;q&lt;=hi)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>((<span class=\"keyword\">long</span>)vec[p] &gt; (<span class=\"keyword\">long</span>)vec[q]*<span class=\"number\">3</span>)&#123;</span><br><span class=\"line\">\t\t\t\tcount += mid-p+<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t\tq++;</span><br><span class=\"line\">\t\t\t&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t\tp++;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//正常的merge操作</span></span><br><span class=\"line\">\t\tp = lo ;</span><br><span class=\"line\">\t\tq = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(p&lt;=mid&amp;&amp;q&lt;=hi)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(vec[p]&gt;=vec[q]) tmp_vec[index++]=vec[q++];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> tmp_vec[index++]=vec[p++];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(p&lt;=mid) tmp_vec[index++]=vec[p++];</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(q&lt;=hi) tmp_vec[index++]=vec[q++];</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=lo; i&lt;=hi; i++)&#123;</span><br><span class=\"line\">\t\t\tvec[i] = tmp_vec[i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> count;</span><br><span class=\"line\">\t&#125;    </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tSolution Sol;</span><br><span class=\"line\">\t<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; vec;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> n ;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span>&gt;&gt;n)&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//int tmp = n;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> element;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(n--)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">cin</span>&gt;&gt;element;</span><br><span class=\"line\">\t\t\tvec.push_back(element);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span>&lt;&lt;Sol.reversePairs(vec)&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"length":2971,"excerpt":"<h1 id=\"逆序对的计数\"><a href=\"#逆序对的计数\" class=\"headerlink\" title=\"逆序对的计数\"></a>逆序对的计数</h1><p>leetcode#493题，给定一个数组A，寻找i<j，但是有a[i]>A[j]的数目。变种为重要逆序对的寻找即寻找A[i]&gt;kA[j]的数目。</j，但是有a[i]></p>\n<p>题目来源：<a href=\"https://leetcode.com/problems/reverse-pairs/\" target=\"_blank\" rel=\"noopener\">https://leetcode.com/problems/reverse-pairs/</a></p>","more":"<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>基本的逆序对与重要逆序对思路一致，因此只对逆序对进行讲解。</p>\n<h3 id=\"暴力枚举\"><a href=\"#暴力枚举\" class=\"headerlink\" title=\"暴力枚举\"></a>暴力枚举</h3><p>从前往后遍历数组，枚举出所有(A[i],A[j])，然后统计符合条件的重要逆序对的数目，很明显所需要的时间复杂度为</p>\n<p>$O(n^2)$</p>\n<h3 id=\"分治\"><a href=\"#分治\" class=\"headerlink\" title=\"分治\"></a>分治</h3><h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><p>先考虑最简单的情况：</p>\n<p>如果input的数组长度为n=1，则输出为0，不存在逆序对。会做</p>\n<p>n=2的时候，可以分解成两个n=1的情况。因为左右两边都是一个元素自然都不存在逆序对，考虑一个元素在左边，一个在右边的情况可以得出(8,4)一个逆序对的情况，所以输出为1。会做</p>\n<p>n=4的时候：同样的可以分解成两个n=2的情况，因为我们已经解决了n=2的问题。这时候左边数组存在一个(8,4)的逆序对，右边数组存在一个(3,2)的逆序对。这时候主要考虑的是交叉的情况，如果左右两个数组都是没有结构的，那么只能用两个指针来挨个遍历左右两边的数组了时间复杂度为$O(n^2)$ 。如果左右两边数组都是有序的情况下，就可以减少很多冗余的比较操作了，当$L_i&gt;R_j$ 时，左边数组位于$L_i$ 后面的元素肯定都会大于$R_j$ ，因此就不用在比较$L_i$ 后面的元素了,将右边数组指针+1寻找更大的元素来进行比较。当$L_i&lt;R_j$时，需要将左边的指针+1，寻找一个更大的左边元素进行比较。因为左右指针总共的移动次数不超过数组长度，所以这时的复杂度为$O(n)$。以图中的例子来说明，当有4大于3的时候，就不需要比较8是否大于3了。</p>\n<p>一个形象的比喻是两个人打牌，一个人L拿的是左边的数组，另一个人R是右边的数组，牌已经从小到大整理好了。如果L最小的牌比R的最小的牌都大，那么L手中所有的牌都比R的最小的牌大。R要找到比L当前牌更大的牌只能向后寻找，如果找不到说明，L所有的牌都比R大，如果找到了是$R_j$那么L就向后面再找一个新的比$R_j$的牌大的新牌$L_i$ 。规则就是从左到右出牌，牌小的先出，最后谁的牌出完那么游戏结束，结束逆序对的统计。</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1570434502/blog/reversepairs.jpg\" alt=\"\"></p>\n<h4 id=\"归纳\"><a href=\"#归纳\" class=\"headerlink\" title=\"归纳\"></a>归纳</h4><p>可以看到，在上述分析过程中我们可以将输入为n的数组不断划分为原来的一半直至最后n=1的情况，从n=1的情况再向上合并得到上层问题的答案，也就是归并排序的过程中加上了逆序对的统计，这是一个很典型的分治策略。</p>\n<p><strong>Divide</strong> 将输入数组A划分为左边A[0, n/2] 与右边A[n/2+1, n-1]两个数组</p>\n<p><strong>Conquer</strong> 左边的逆序对数目与右边的逆序对数目分别再各自递归的调用函数求解，同时对其排序。</p>\n<p><strong>Merge</strong> 统计逆序对元素交叉在左右两边的情况，并将两个排好序的子数组合并成一个新的有序数组</p>\n<h4 id=\"复杂度\"><a href=\"#复杂度\" class=\"headerlink\" title=\"复杂度\"></a>复杂度</h4><p>将规模为n的问题分解成两个两个$\\frac{n}{2}$ 的子问题问题，同时对两个子问题进行合并的复杂度为O(n)，所以有递推公式：</p>\n<script type=\"math/tex; mode=display\">\nT(n)=\\left\\{\n  \\begin{array}{**lr**}  \n             1 &  n=1\\\\\\\\  \n             2T(\\frac{n}{2})+O(n)\n             \\end{array}  \n\\right.</script><p>根据主定理有最后的复杂度为$O(n\\log(n))$</p>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">https://leetcode.com/problems/reverse-pairs/</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; tmp_vec;<span class=\"comment\">//把tmp_vec设置成共有变量，而不在函数中设置为临时变量可以减少多次对其创建与销毁，提高效率</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">reversePairs</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">int</span> size = nums.size();</span><br><span class=\"line\">    \ttmp_vec.resize(nums.size());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> MergeSort(nums, <span class=\"number\">0</span>, size<span class=\"number\">-1</span>); <span class=\"comment\">// 不用全局变量否则，多线程的时候会被修改。</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">MergeSort</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; vec, <span class=\"keyword\">int</span> lo, <span class=\"keyword\">int</span> hi)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(lo&gt;=hi) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;<span class=\"comment\">// base case 递归必备</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> mid = lo + (hi -lo)/<span class=\"number\">2</span>; <span class=\"comment\">//防止两个超级大的int相加后造成溢出</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tans += MergeSort(vec, lo, mid); <span class=\"comment\">//左边merge的计数</span></span><br><span class=\"line\">\t\tans += MergeSort(vec, mid+<span class=\"number\">1</span>, hi); <span class=\"comment\">//右边merge的计数</span></span><br><span class=\"line\">\t\tans += Merge(vec, lo, hi, mid);<span class=\"comment\">// 返回什么？ 本次merge的技术 也就是split 的情况</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Merge</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; vec, <span class=\"keyword\">int</span> lo, <span class=\"keyword\">int</span> hi, <span class=\"keyword\">int</span> mid)</span></span>&#123; <span class=\"comment\">//采用双指针来一次把左右两边的小值冒泡出来放到合并后的数组中，同时完成对逆序数目的统计</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> p = lo;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> q = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;<span class=\"comment\">//记录逆序数目</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> index = lo;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(p&lt;=mid&amp;&amp;q&lt;=hi)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>((<span class=\"keyword\">long</span>)vec[p] &gt; (<span class=\"keyword\">long</span>)vec[q]*<span class=\"number\">3</span>)&#123;</span><br><span class=\"line\">\t\t\t\tcount += mid-p+<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t\tq++;</span><br><span class=\"line\">\t\t\t&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t\tp++;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//正常的merge操作</span></span><br><span class=\"line\">\t\tp = lo ;</span><br><span class=\"line\">\t\tq = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(p&lt;=mid&amp;&amp;q&lt;=hi)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(vec[p]&gt;=vec[q]) tmp_vec[index++]=vec[q++];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> tmp_vec[index++]=vec[p++];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(p&lt;=mid) tmp_vec[index++]=vec[p++];</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(q&lt;=hi) tmp_vec[index++]=vec[q++];</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=lo; i&lt;=hi; i++)&#123;</span><br><span class=\"line\">\t\t\tvec[i] = tmp_vec[i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> count;</span><br><span class=\"line\">\t&#125;    </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tSolution Sol;</span><br><span class=\"line\">\t<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; vec;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> n ;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span>&gt;&gt;n)&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//int tmp = n;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> element;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(n--)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">cin</span>&gt;&gt;element;</span><br><span class=\"line\">\t\t\tvec.push_back(element);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span>&lt;&lt;Sol.reversePairs(vec)&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"数组中的第K大的数","date":"2019-09-19T13:06:01.000Z","copyright":true,"_content":"\n# 数组中的第K大的数\n\nleetcode#215题，给定一个数组，要求找出其第K大的个数。\n\n<!--more-->\n\n题目来源：\n\n<https://leetcode.com/problems/kth-largest-element-in-an-array/> \n\n## 解题思路\n\n简单：（1）通过对数组排序后可以直接对升序排序后的数组返回下标为len-k（降序就直接返回下标为k）。(2) 选择排序算法中时间复杂度比较低的快排进行排序，可以直接使用<algorithm>库中的sort()函数进行排序。\n\n优化： 仔细分析快排的思路：在分割的过程中每次返回一个主元pivot,主元左边的元素都小于pivot,右边的元素都大于piovt，然后再分别对两边递归排序。因为题目要求的只是返回一个第k大的数，所以不需要完整地对执行完所有递归。当寻找到的主元pivot的坐标刚好等于len-k时，就可以直接返回；如果pivot<len-k说明要找的数目在右边，则只用对右边进行快排；如果pivot>len-k，说明要寻找的数字在左边，则只用对左半边进行快排。\n\n## 代码\n\n```c++\n/*\nhttps://leetcode.com/problems/kth-largest-element-in-an-array/\n */\n#include <iostream>\n#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nclass Solution{\n\tprivate:\n\t\t\n\tpublic:\n\t\tint ans;\n\t\tvoid quicksort(vector<int>& vec, int lo, int hi, int k){\n\t\t\tif(lo>=hi) { //正常情况下退出时相等的情况，为了避免其他逻辑错误因此再加上lo大于hi的情况\n\t\t\t\tans = vec[hi]; // 递归到最后还没有找到说明就是最后的这个元素就是要找的第k大，不考虑k大len的情况。\n\t\t\t\treturn; // base case 递归必备，有个出口只有一个元素的时候不会再递归。\n\t\t\t}\n\t\t\tint piv = partition(vec, lo, hi);\n\t\t\tif(piv==k){\n\t\t\t\tans = vec[k];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse if(k<piv) quicksort(vec,lo,piv-1,k);//左边递归 piv不再参与两边的快排,因为已经找到它的位置了。\n\t\t\telse quicksort(vec,piv+1,hi,k);//右边递归\n\t\t}\n\n\t\tint partition(vector<int>&vec,int lo, int hi){\n\t\t\tint loNow = lo - 1;\n\t\t\tint piov = hi;\n\t\t\tfor(int i = lo; i<=hi-1; i++){ // 必须小于等于，因为hi是下标而不是数组长度，\n\t\t\t\t\t\t\t\t\t\t\t//如果是长度的话i<len-1,会访问到倒数第二个，下标的话就不会。\n\t\t\t\tif(vec[i]<=vec[piov]){\n\t\t\t\t\tloNow++;\n\t\t\t\t\tswap(vec, loNow, i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tswap(vec, loNow+1, piov);\n\t\t\tpiov = loNow+1;\n\t\t\treturn piov;\n\t\t}\n\n\t\tvoid swap(vector<int>& vec, int a, int b){\n\t\t\tint tmp = vec[a];\n\t\t\tvec[a] = vec[b];\n\t\t\tvec[b] = tmp;\n\t\t}\n};\n\n\nint main()\n{\n\tint len, k;\n\tSolution Sol;\n\tvector<int> vec;\n\t//while(cin>>len>>k)\n\twhile(scanf(\"%d %d\", &len, &k)!=EOF)\n\t{\n\t\tint tmp_len = len ;\n\t\twhile(tmp_len--) {\n\t\t\tint element;\n\t\t\tscanf(\"%d\",&element);\n\t\t\tvec.push_back(element);\n\t\t}\n\t\tSol.quicksort(vec, 0, len-1, len-k);\n\t\tcout<<Sol.ans<<endl;\n\t}\n \treturn 0;\n}\n```\n\n","source":"_posts/2019-09-19-数组中的第K大的数.md","raw":"---\ntitle: 数组中的第K大的数\ndate: 2019-09-19 21:06:01\ncategories: 题解\ntags:\n- 快排\n- leetcode\ncopyright: true\n---\n\n# 数组中的第K大的数\n\nleetcode#215题，给定一个数组，要求找出其第K大的个数。\n\n<!--more-->\n\n题目来源：\n\n<https://leetcode.com/problems/kth-largest-element-in-an-array/> \n\n## 解题思路\n\n简单：（1）通过对数组排序后可以直接对升序排序后的数组返回下标为len-k（降序就直接返回下标为k）。(2) 选择排序算法中时间复杂度比较低的快排进行排序，可以直接使用<algorithm>库中的sort()函数进行排序。\n\n优化： 仔细分析快排的思路：在分割的过程中每次返回一个主元pivot,主元左边的元素都小于pivot,右边的元素都大于piovt，然后再分别对两边递归排序。因为题目要求的只是返回一个第k大的数，所以不需要完整地对执行完所有递归。当寻找到的主元pivot的坐标刚好等于len-k时，就可以直接返回；如果pivot<len-k说明要找的数目在右边，则只用对右边进行快排；如果pivot>len-k，说明要寻找的数字在左边，则只用对左半边进行快排。\n\n## 代码\n\n```c++\n/*\nhttps://leetcode.com/problems/kth-largest-element-in-an-array/\n */\n#include <iostream>\n#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nclass Solution{\n\tprivate:\n\t\t\n\tpublic:\n\t\tint ans;\n\t\tvoid quicksort(vector<int>& vec, int lo, int hi, int k){\n\t\t\tif(lo>=hi) { //正常情况下退出时相等的情况，为了避免其他逻辑错误因此再加上lo大于hi的情况\n\t\t\t\tans = vec[hi]; // 递归到最后还没有找到说明就是最后的这个元素就是要找的第k大，不考虑k大len的情况。\n\t\t\t\treturn; // base case 递归必备，有个出口只有一个元素的时候不会再递归。\n\t\t\t}\n\t\t\tint piv = partition(vec, lo, hi);\n\t\t\tif(piv==k){\n\t\t\t\tans = vec[k];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse if(k<piv) quicksort(vec,lo,piv-1,k);//左边递归 piv不再参与两边的快排,因为已经找到它的位置了。\n\t\t\telse quicksort(vec,piv+1,hi,k);//右边递归\n\t\t}\n\n\t\tint partition(vector<int>&vec,int lo, int hi){\n\t\t\tint loNow = lo - 1;\n\t\t\tint piov = hi;\n\t\t\tfor(int i = lo; i<=hi-1; i++){ // 必须小于等于，因为hi是下标而不是数组长度，\n\t\t\t\t\t\t\t\t\t\t\t//如果是长度的话i<len-1,会访问到倒数第二个，下标的话就不会。\n\t\t\t\tif(vec[i]<=vec[piov]){\n\t\t\t\t\tloNow++;\n\t\t\t\t\tswap(vec, loNow, i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tswap(vec, loNow+1, piov);\n\t\t\tpiov = loNow+1;\n\t\t\treturn piov;\n\t\t}\n\n\t\tvoid swap(vector<int>& vec, int a, int b){\n\t\t\tint tmp = vec[a];\n\t\t\tvec[a] = vec[b];\n\t\t\tvec[b] = tmp;\n\t\t}\n};\n\n\nint main()\n{\n\tint len, k;\n\tSolution Sol;\n\tvector<int> vec;\n\t//while(cin>>len>>k)\n\twhile(scanf(\"%d %d\", &len, &k)!=EOF)\n\t{\n\t\tint tmp_len = len ;\n\t\twhile(tmp_len--) {\n\t\t\tint element;\n\t\t\tscanf(\"%d\",&element);\n\t\t\tvec.push_back(element);\n\t\t}\n\t\tSol.quicksort(vec, 0, len-1, len-k);\n\t\tcout<<Sol.ans<<endl;\n\t}\n \treturn 0;\n}\n```\n\n","slug":"2019-09-19-数组中的第K大的数","published":1,"updated":"2019-11-11T03:49:53.617Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2yelxhl0018m8tz4cy2jmwh","content":"<h1 id=\"数组中的第K大的数\"><a href=\"#数组中的第K大的数\" class=\"headerlink\" title=\"数组中的第K大的数\"></a>数组中的第K大的数</h1><p>leetcode#215题，给定一个数组，要求找出其第K大的个数。</p>\n<a id=\"more\"></a>\n<p>题目来源：</p>\n<p><a href=\"https://leetcode.com/problems/kth-largest-element-in-an-array/\" target=\"_blank\" rel=\"noopener\">https://leetcode.com/problems/kth-largest-element-in-an-array/</a> </p>\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>简单：（1）通过对数组排序后可以直接对升序排序后的数组返回下标为len-k（降序就直接返回下标为k）。(2) 选择排序算法中时间复杂度比较低的快排进行排序，可以直接使用<algorithm>库中的sort()函数进行排序。</algorithm></p>\n<p>优化： 仔细分析快排的思路：在分割的过程中每次返回一个主元pivot,主元左边的元素都小于pivot,右边的元素都大于piovt，然后再分别对两边递归排序。因为题目要求的只是返回一个第k大的数，所以不需要完整地对执行完所有递归。当寻找到的主元pivot的坐标刚好等于len-k时，就可以直接返回；如果pivot<len-k说明要找的数目在右边，则只用对右边进行快排；如果pivot>len-k，说明要寻找的数字在左边，则只用对左半边进行快排。</len-k说明要找的数目在右边，则只用对右边进行快排；如果pivot></p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">https://leetcode.com/problems/kth-largest-element-in-an-array/</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t<span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> ans;</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">quicksort</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; vec, <span class=\"keyword\">int</span> lo, <span class=\"keyword\">int</span> hi, <span class=\"keyword\">int</span> k)</span></span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(lo&gt;=hi) &#123; <span class=\"comment\">//正常情况下退出时相等的情况，为了避免其他逻辑错误因此再加上lo大于hi的情况</span></span><br><span class=\"line\">\t\t\t\tans = vec[hi]; <span class=\"comment\">// 递归到最后还没有找到说明就是最后的这个元素就是要找的第k大，不考虑k大len的情况。</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span>; <span class=\"comment\">// base case 递归必备，有个出口只有一个元素的时候不会再递归。</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> piv = partition(vec, lo, hi);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(piv==k)&#123;</span><br><span class=\"line\">\t\t\t\tans = vec[k];</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(k&lt;piv) quicksort(vec,lo,piv<span class=\"number\">-1</span>,k);<span class=\"comment\">//左边递归 piv不再参与两边的快排,因为已经找到它的位置了。</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> quicksort(vec,piv+<span class=\"number\">1</span>,hi,k);<span class=\"comment\">//右边递归</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">partition</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp;vec,<span class=\"keyword\">int</span> lo, <span class=\"keyword\">int</span> hi)</span></span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> loNow = lo - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> piov = hi;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = lo; i&lt;=hi<span class=\"number\">-1</span>; i++)&#123; <span class=\"comment\">// 必须小于等于，因为hi是下标而不是数组长度，</span></span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t<span class=\"comment\">//如果是长度的话i&lt;len-1,会访问到倒数第二个，下标的话就不会。</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(vec[i]&lt;=vec[piov])&#123;</span><br><span class=\"line\">\t\t\t\t\tloNow++;</span><br><span class=\"line\">\t\t\t\t\tswap(vec, loNow, i);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tswap(vec, loNow+<span class=\"number\">1</span>, piov);</span><br><span class=\"line\">\t\t\tpiov = loNow+<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> piov;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; vec, <span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span></span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> tmp = vec[a];</span><br><span class=\"line\">\t\t\tvec[a] = vec[b];</span><br><span class=\"line\">\t\t\tvec[b] = tmp;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> len, k;</span><br><span class=\"line\">\tSolution Sol;</span><br><span class=\"line\">\t<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; vec;</span><br><span class=\"line\">\t<span class=\"comment\">//while(cin&gt;&gt;len&gt;&gt;k)</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;len, &amp;k)!=EOF)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> tmp_len = len ;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(tmp_len--) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> element;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;element);</span><br><span class=\"line\">\t\t\tvec.push_back(element);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tSol.quicksort(vec, <span class=\"number\">0</span>, len<span class=\"number\">-1</span>, len-k);</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span>&lt;&lt;Sol.ans&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> \t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"length":1853,"excerpt":"<h1 id=\"数组中的第K大的数\"><a href=\"#数组中的第K大的数\" class=\"headerlink\" title=\"数组中的第K大的数\"></a>数组中的第K大的数</h1><p>leetcode#215题，给定一个数组，要求找出其第K大的个数。</p>","more":"<p>题目来源：</p>\n<p><a href=\"https://leetcode.com/problems/kth-largest-element-in-an-array/\" target=\"_blank\" rel=\"noopener\">https://leetcode.com/problems/kth-largest-element-in-an-array/</a> </p>\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>简单：（1）通过对数组排序后可以直接对升序排序后的数组返回下标为len-k（降序就直接返回下标为k）。(2) 选择排序算法中时间复杂度比较低的快排进行排序，可以直接使用<algorithm>库中的sort()函数进行排序。</algorithm></p>\n<p>优化： 仔细分析快排的思路：在分割的过程中每次返回一个主元pivot,主元左边的元素都小于pivot,右边的元素都大于piovt，然后再分别对两边递归排序。因为题目要求的只是返回一个第k大的数，所以不需要完整地对执行完所有递归。当寻找到的主元pivot的坐标刚好等于len-k时，就可以直接返回；如果pivot<len-k说明要找的数目在右边，则只用对右边进行快排；如果pivot>len-k，说明要寻找的数字在左边，则只用对左半边进行快排。</len-k说明要找的数目在右边，则只用对右边进行快排；如果pivot></p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">https://leetcode.com/problems/kth-largest-element-in-an-array/</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t<span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> ans;</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">quicksort</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; vec, <span class=\"keyword\">int</span> lo, <span class=\"keyword\">int</span> hi, <span class=\"keyword\">int</span> k)</span></span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(lo&gt;=hi) &#123; <span class=\"comment\">//正常情况下退出时相等的情况，为了避免其他逻辑错误因此再加上lo大于hi的情况</span></span><br><span class=\"line\">\t\t\t\tans = vec[hi]; <span class=\"comment\">// 递归到最后还没有找到说明就是最后的这个元素就是要找的第k大，不考虑k大len的情况。</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span>; <span class=\"comment\">// base case 递归必备，有个出口只有一个元素的时候不会再递归。</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> piv = partition(vec, lo, hi);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(piv==k)&#123;</span><br><span class=\"line\">\t\t\t\tans = vec[k];</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(k&lt;piv) quicksort(vec,lo,piv<span class=\"number\">-1</span>,k);<span class=\"comment\">//左边递归 piv不再参与两边的快排,因为已经找到它的位置了。</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> quicksort(vec,piv+<span class=\"number\">1</span>,hi,k);<span class=\"comment\">//右边递归</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">partition</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp;vec,<span class=\"keyword\">int</span> lo, <span class=\"keyword\">int</span> hi)</span></span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> loNow = lo - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> piov = hi;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = lo; i&lt;=hi<span class=\"number\">-1</span>; i++)&#123; <span class=\"comment\">// 必须小于等于，因为hi是下标而不是数组长度，</span></span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t<span class=\"comment\">//如果是长度的话i&lt;len-1,会访问到倒数第二个，下标的话就不会。</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(vec[i]&lt;=vec[piov])&#123;</span><br><span class=\"line\">\t\t\t\t\tloNow++;</span><br><span class=\"line\">\t\t\t\t\tswap(vec, loNow, i);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tswap(vec, loNow+<span class=\"number\">1</span>, piov);</span><br><span class=\"line\">\t\t\tpiov = loNow+<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> piov;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; vec, <span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span></span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> tmp = vec[a];</span><br><span class=\"line\">\t\t\tvec[a] = vec[b];</span><br><span class=\"line\">\t\t\tvec[b] = tmp;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> len, k;</span><br><span class=\"line\">\tSolution Sol;</span><br><span class=\"line\">\t<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; vec;</span><br><span class=\"line\">\t<span class=\"comment\">//while(cin&gt;&gt;len&gt;&gt;k)</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>, &amp;len, &amp;k)!=EOF)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> tmp_len = len ;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(tmp_len--) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> element;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;element);</span><br><span class=\"line\">\t\t\tvec.push_back(element);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tSol.quicksort(vec, <span class=\"number\">0</span>, len<span class=\"number\">-1</span>, len-k);</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span>&lt;&lt;Sol.ans&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> \t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"内嵌汇编","date":"2019-10-31T08:39:47.000Z","copyright":true,"_content":"\n# 内嵌汇编\n\n操作系统高级教程上面需要阅读Linux内核0.11的源码，其中在书《Linux内核设计的一书》第2.5节异常处理类中段服务程序挂接的部分，遇到了嵌入在C语言中的汇编代码，之前从来没有学习过汇编，因此记录下。\n\n<!--more-->\n\n\n\n## AT&T基础知识\n\n内嵌汇编使用的是AT&T汇编，所以首先稍微讲解下AT&T的汇编指令的基础知识。\n\n### 操作数前缀\n\n```assembly\nmovl   $8,%eax \nmovl   $0xffff,%ebx \nint     $0x80 \n```\n\n看到在AT%T汇编中诸如\"%eax\"、\"%ebx\"之类的寄存器名字前都要加上\"%\"；\"$8\"、\"$0xffff\"这样的立即数之前都要加上\"$\"。  \n\n### 源/目的操作数顺序 \n\n   在Intel语法中，第一个操作数是目的操作数，第二个操作数源操作数。而在AT&T中，第一个数是源操作数，第二个数是目的操作数。 \n\n```assembly\n// INTEL语法\nMOV EAX,8 //EAX是目的操作数， 8是源操作数\n// AT&T语法\nmovl   $8,%eax //8是源操作数 EAX是目的操作数\n```\n\n### 标识长度的操作码后缀 \n\n在AT&T的操作码后面有时还会有一个后缀，其含义就是指出操作码的大小。“l”表示长整数（32位），“w”表示字（16位），“b”表示字节（8位）。\n\n```assembly\nmovb    %bl,%al\nmovw   %bx,%ax\nmovl     %ebx,%eax\nmovl     (%ebx),%eax\n```\n\n## GCC内嵌汇编\n\nLinux操作系统内核代码绝大部分使用C语言编写，只有一小部分使用汇编语言编写，例如与特定体系结构相关的代码和对性能影响很大的代码。GCC提供了内嵌汇编的功能，可以在C代码中直接内嵌汇编语言语句，大大方便了程序设计。 \n\n### 基本行内汇编\n\n基本行内汇编很容易理解，一般是按照下面的格式：\n\n  ``` asm(“statements”); ```\n\n在“asm”后面有时也会加上“__volatile__”表示编译器不要优化代码，后面的指令保留原样 \n\n ```__asm__  __volatile__(\"hlt\");``` \n\n如果有很多行汇编，则每一行后要加上“\\n\\t” ：\n\n```assembly\n asm( \"pushl %eax\\n\\t\"\n \"movl $0,%eax\\n\\t\"\n\"popl %eax\"); \n```\n\n或者我们也可以分成几行来写，如： \n\n```assembly\nasm(\"movl %eax,%ebx\");\nasm(\"xorl %ebx,%edx\");\nasm(\"movl $0,_booga); \n```\n\n通常使用汇编语句最方便的方式是把它们放在一个宏内，而宏语句需要在一行上定义，因此使用反斜杠`\\`将这些语句连成一行，所以上述语句如果在宏中定义的话就是：\n\n```c\n asm( \"pushl %eax; \\\n movl $0,%eax; \\\npopl %eax\"); \n```\n\n### 扩展的行内汇编\n\n在扩展的行内汇编中，可以将C语言表达式（比如C语言中的变量）指定为汇编指令的操作数，而且不用去管如何将C语言表达式的值读入寄存器，以及如何将计算结果写回C变量，你只要告诉程序中C语言表达式与汇编指令操作数之间的对应关系即可， GCC会自动插入代码完成必要的操作。 \n\n使用内嵌汇编，要先编写汇编指令模板，然后将C语言表达式与指令的操作数相关联，并告诉GCC对这些操作有哪些限制条件。例如下面的内嵌汇编语句： \n\n```c\nint main(){\n\tint input = 8;\n\tint result = 0;\n    __asm__ __violate__  (\"movl %1,%0\" : \"=r\" (result) : \"r\" (input));\n    printf(\"%d\\n\",result);\n    return 0;\n}\n \n```\n\n`“movl %1,%0”`是指令模板；“%0”和“%1”代表指令的操作数，称为占位符，“=r”代表它之后是输入变量且需用到寄存器，指令模板后面用小括号括起来的是C语言表达式 ，其中input是输入变量，该指令会完成把input的值复制到result中的操作 。\n\n### 扩展的行内汇编的语法 \n\n内嵌汇编语法如下：\n\n  ```\n asm(\"汇编语句模块\"\n\n      :输出寄存器 \n\n      :输入寄存器 \n\n      :会被修改的寄存器);\n  ```\n\n即格式为`asm ( \"statements\" : output_regs : input_regs : clobbered_regs) `\n\n汇编语句模块必不可少，其他三部分可选，如果使用了后面的部分，而前面部分为空，也需要用“:”格开，相应部分内容为空。 \n\n#### 汇编语句模块\n\n汇编语句模块由汇编语句序列组成，语句之间使用“;”、“\\n”或“\\n\\t”分开。指令中的操作数可以使用占位符引用C语言变量，**操作数占位符**最多10个，名称如下：%0，%1…，%9。指令中使用占位符表示的操作数，总被视为long型（4，个字节），但对其施加的操作根据指令可以是字或者字节，当把操作数当作字或者字节使用时，默认为低字或者低字节。对字节操作可以显式的指明是低字节还是次字节。方法是在%和序号之间插入一个字母，“b”代表低字节，“h”代表高字节，例如：%h1。 \n\n占位符的理解：将汇编输出寄存器与输入寄存器从输出寄存器行开始左到右从上到下进行编号分别为：%0，%1…，%9。比如有代码：\n\n```assembly\n#define get_seg_byte(seg,addr) \\\n({ \\\nregister char __res; \\\n__asm__(\"push %%fs; \\\nmov %%ax,%%fs; \\\nmovb %%fs:%2,%%al; \\\npop %%fs\" \\\n:\"=a\" (__res) \\\n:\"\" (seg),\"m\" (*(addr))); \\\n__res;})\n```\n\n输出寄存器\"=a\"eax记为%0,输入寄存器\"\"(依然是eax)记为%1,输入寄存器\"m\"为%2。\n\n#### 输出寄存器\n\n描述输出操作数，不同的操作数描述符之间用逗号格开，每个操作数描述符由**限定字符串和C语言变量**组成。每个**输出操作数的限定字符串必须包含“=”**，表示它是一个输出操作数。例如：\n\n```__asm__   __volatile__ (\"pushfl ; popl %0 ; cli\":\"=g\" (x) )```\n\n在这里“x”便是最终存放输出结果的C程序变量，而“=g”则是限定字符串，限定字符串表示了对它之后的变量的限制条件 。\n\n#### 输入寄存器\n\n描述输入操作数，不同的操作数描述符之间使用逗号格开，每个操作数描述符同样也由限定字符串和C语言表达式或者C语言变量组成。例：\n\n```c\n__asm__ volatile__ (\"lidt %0\" : : \"m\" (real_mode_idt));\n```\n\n其中%0是占位操作符，而输出寄存器为空，输入寄存器的值为C语言表达式real_mode_idt。\n\n#### 限定字符串\n\n又叫做寄存器加载代码\n\n| 限定字符      | 描述           | 限定字符 | 描述 |\n| ------------- | -------------- | -------- | ---- |\n| a             | 使用寄存器eax  | m | 使用内存地址 |\n| b      | 使用寄存器ebx | o | 使用内存地址并可以加偏移值 |\n| m、o、V、p    | 使用寄存器ecx | I | 使用常数0~31 立即数 |\n| g、X          | 寄存器或内存   | J | 使用常数0~63 立即数 |\n| I、J、N、i、n | 立即数         | K | 使用常数0~255立即数 |\n| D         | 使用edi | L | 使用常数0~65535 立即数 |\n| q | 使用动态分配字节可寻址寄存器（eax、ebx、ecx或edx） | M | 使用常数0~3  立即数 |\n| r | 使用任意动态分配的寄存器 | N | 使用1字节常数（0~255）立即数 |\n| g | 使用通用有效的地址即可（eax、ebx、ecx、edx或内存变量） | O | 使用常数0~31 立即数 |\n| A | 使用eax与edx联合（64位） | i | 立即数 |\n\n## 例子\n\n直接摘抄自《Linux内核完全注释》第5.2.2 traps.c程序的第82页\n\n- 例子1：\n\n```assembly\n01 #define get_seg_byte(seg,addr) \\\n02 ({ \\\n03 register char __res; \\\n04 __asm__(\"push %%fs; \\\n05 mov %%ax,%%fs; \\\n06 movb %%fs:%2,%%al; \\\n07 pop %%fs\" \\\n08 :\"=a\" (__res) \\\n09 :\"\" (seg),\"m\" (*(addr))); \\\n10 __res;})\n```\n\n 第1 行定义了宏的名称，也即是宏函数名称 `get_seg_byte(seg,addr)` 。第 3 行定义了一个寄存器变量 res 。第 4 行上的 `__asm__ `表示嵌入汇编语句的开始。从第 4 行到第 7 行的 4 条语句是 AT&T 格式的汇编语句。\n\n第 8 行即是输出寄存器，这句的含义是在这段代码运行结束后将 eax 所代表的寄存器的值放入` __res`变量中，作为本函数的输出值， \"=a\" 中的 \"a\" 称为加载代码， \"=\" 表示这是输出寄存器。第 9 行表示在这段代码开始运行时将 seg 放到 eax 寄存器中， \"\" 表示使用与上面同个位置的输出相同的寄存器。而 (*(addr))表示一个内存偏移地址值。为了在上面汇编语句中使用该地址值，嵌入汇编程序规定把输出和输入寄存器统一按顺序编号，顺序是从输出寄存器序列从左到右从上到下以 \"%0\" 开始，分别记为 %0 、 %1 、 …%9 。因此，输出寄存器的编号是 %0 （这里只有一个输出寄存器），输入寄存器前一部分 (\"\" (seg)) 的编号是 %1 ，而后部分的编号是 %2 。上面第 6 行上的 %2 即代表 (*(addr)) 这个内存偏移量。现在我们来研究 4—7 行上的代码的作用。第一句将 fs 段寄存器的内容入栈；第二句将 eax 中的段值赋给 fs 段寄存器；第三句是把 fs:(*(addr)) 所指定的字节放入 al 寄存器中。当执行完汇编语句后，输出寄存器 eax 的值将被放入 `__res` ，作为该宏函数（块结构表达式）的返回值。\n\n通过上面分析，我们知道，宏名称中的 seg 代表一指定的内存段值，而 addr 表示一内存偏移地址量。到现在为止，我们应该很清楚这段程序的功能了吧！该宏函数的功能是从指定段和偏移值的内存地址处取一个字节。\n\n通过上面的例子说明，阅读这段代码时应该像CPU处理指令时的逻辑一样，先从输出输入寄存器语句开始知道输入输出是什么，然后再阅读汇编语句，处理完后再看最后的返回是什么。\n\n- 例子2\n\n再来看下Linux 内核中main()中对中断异常挂接的trap_init()中的设计到的一个GCC内嵌汇编。代码路径为；include\\asm\\system.h\n\n```assembly\n1 #define _set_gate(gate_addr,type,dpl,addr) \\\n2 __asm__ (\"movw %%dx,%%ax\\n\\t\" \\\n3\t\"movw %0,%%dx\\n\\t\" \\\n4\t\"movl %%eax,%1\\n\\t\" \\\n5\t\"movl %%edx,%2\" \\\n6\t: \\\n7\t: \"i\" ((short) (0x8000+(dpl<<13)+(type<<8))), \\\n8\t\"o\" (*((char *) (gate_addr))), \\\n9\t\"o\" (*(4+(char *) (gate_addr))), \\\n10\t\"d\" ((char *) (addr)),\"a\" (0x00080000)) \n```\n\n首先从第6行输出寄存器开始阅读：输出寄存器为空。然后是第7至10行的输入寄存器。第%0个输入寄存器使用“i”表示输入立即数，第%1个输入寄存器使用“o”表示使用内存地址并可以加偏移值，第%2个输入寄存器依然使用“o”代码，第%3个寄存器使用“d”表示使用寄存器edx，第%4个寄存器使用“a”表示使用寄存器eax。\n\n之后再看下汇编语句：依次进行值得传递。\n\n## 参考\n\n《Linux内核设计的艺术》新设计团队 著\n\n《Linux内核完全注释》赵炯 编著","source":"_posts/2019-10-31-内嵌汇编.md","raw":"---\ntitle: 内嵌汇编\ndate: 2019-10-31 16:39:47\ncategories: 编程语言\ntags: \n- 汇编\n- C语言\ncopyright: true\n---\n\n# 内嵌汇编\n\n操作系统高级教程上面需要阅读Linux内核0.11的源码，其中在书《Linux内核设计的一书》第2.5节异常处理类中段服务程序挂接的部分，遇到了嵌入在C语言中的汇编代码，之前从来没有学习过汇编，因此记录下。\n\n<!--more-->\n\n\n\n## AT&T基础知识\n\n内嵌汇编使用的是AT&T汇编，所以首先稍微讲解下AT&T的汇编指令的基础知识。\n\n### 操作数前缀\n\n```assembly\nmovl   $8,%eax \nmovl   $0xffff,%ebx \nint     $0x80 \n```\n\n看到在AT%T汇编中诸如\"%eax\"、\"%ebx\"之类的寄存器名字前都要加上\"%\"；\"$8\"、\"$0xffff\"这样的立即数之前都要加上\"$\"。  \n\n### 源/目的操作数顺序 \n\n   在Intel语法中，第一个操作数是目的操作数，第二个操作数源操作数。而在AT&T中，第一个数是源操作数，第二个数是目的操作数。 \n\n```assembly\n// INTEL语法\nMOV EAX,8 //EAX是目的操作数， 8是源操作数\n// AT&T语法\nmovl   $8,%eax //8是源操作数 EAX是目的操作数\n```\n\n### 标识长度的操作码后缀 \n\n在AT&T的操作码后面有时还会有一个后缀，其含义就是指出操作码的大小。“l”表示长整数（32位），“w”表示字（16位），“b”表示字节（8位）。\n\n```assembly\nmovb    %bl,%al\nmovw   %bx,%ax\nmovl     %ebx,%eax\nmovl     (%ebx),%eax\n```\n\n## GCC内嵌汇编\n\nLinux操作系统内核代码绝大部分使用C语言编写，只有一小部分使用汇编语言编写，例如与特定体系结构相关的代码和对性能影响很大的代码。GCC提供了内嵌汇编的功能，可以在C代码中直接内嵌汇编语言语句，大大方便了程序设计。 \n\n### 基本行内汇编\n\n基本行内汇编很容易理解，一般是按照下面的格式：\n\n  ``` asm(“statements”); ```\n\n在“asm”后面有时也会加上“__volatile__”表示编译器不要优化代码，后面的指令保留原样 \n\n ```__asm__  __volatile__(\"hlt\");``` \n\n如果有很多行汇编，则每一行后要加上“\\n\\t” ：\n\n```assembly\n asm( \"pushl %eax\\n\\t\"\n \"movl $0,%eax\\n\\t\"\n\"popl %eax\"); \n```\n\n或者我们也可以分成几行来写，如： \n\n```assembly\nasm(\"movl %eax,%ebx\");\nasm(\"xorl %ebx,%edx\");\nasm(\"movl $0,_booga); \n```\n\n通常使用汇编语句最方便的方式是把它们放在一个宏内，而宏语句需要在一行上定义，因此使用反斜杠`\\`将这些语句连成一行，所以上述语句如果在宏中定义的话就是：\n\n```c\n asm( \"pushl %eax; \\\n movl $0,%eax; \\\npopl %eax\"); \n```\n\n### 扩展的行内汇编\n\n在扩展的行内汇编中，可以将C语言表达式（比如C语言中的变量）指定为汇编指令的操作数，而且不用去管如何将C语言表达式的值读入寄存器，以及如何将计算结果写回C变量，你只要告诉程序中C语言表达式与汇编指令操作数之间的对应关系即可， GCC会自动插入代码完成必要的操作。 \n\n使用内嵌汇编，要先编写汇编指令模板，然后将C语言表达式与指令的操作数相关联，并告诉GCC对这些操作有哪些限制条件。例如下面的内嵌汇编语句： \n\n```c\nint main(){\n\tint input = 8;\n\tint result = 0;\n    __asm__ __violate__  (\"movl %1,%0\" : \"=r\" (result) : \"r\" (input));\n    printf(\"%d\\n\",result);\n    return 0;\n}\n \n```\n\n`“movl %1,%0”`是指令模板；“%0”和“%1”代表指令的操作数，称为占位符，“=r”代表它之后是输入变量且需用到寄存器，指令模板后面用小括号括起来的是C语言表达式 ，其中input是输入变量，该指令会完成把input的值复制到result中的操作 。\n\n### 扩展的行内汇编的语法 \n\n内嵌汇编语法如下：\n\n  ```\n asm(\"汇编语句模块\"\n\n      :输出寄存器 \n\n      :输入寄存器 \n\n      :会被修改的寄存器);\n  ```\n\n即格式为`asm ( \"statements\" : output_regs : input_regs : clobbered_regs) `\n\n汇编语句模块必不可少，其他三部分可选，如果使用了后面的部分，而前面部分为空，也需要用“:”格开，相应部分内容为空。 \n\n#### 汇编语句模块\n\n汇编语句模块由汇编语句序列组成，语句之间使用“;”、“\\n”或“\\n\\t”分开。指令中的操作数可以使用占位符引用C语言变量，**操作数占位符**最多10个，名称如下：%0，%1…，%9。指令中使用占位符表示的操作数，总被视为long型（4，个字节），但对其施加的操作根据指令可以是字或者字节，当把操作数当作字或者字节使用时，默认为低字或者低字节。对字节操作可以显式的指明是低字节还是次字节。方法是在%和序号之间插入一个字母，“b”代表低字节，“h”代表高字节，例如：%h1。 \n\n占位符的理解：将汇编输出寄存器与输入寄存器从输出寄存器行开始左到右从上到下进行编号分别为：%0，%1…，%9。比如有代码：\n\n```assembly\n#define get_seg_byte(seg,addr) \\\n({ \\\nregister char __res; \\\n__asm__(\"push %%fs; \\\nmov %%ax,%%fs; \\\nmovb %%fs:%2,%%al; \\\npop %%fs\" \\\n:\"=a\" (__res) \\\n:\"\" (seg),\"m\" (*(addr))); \\\n__res;})\n```\n\n输出寄存器\"=a\"eax记为%0,输入寄存器\"\"(依然是eax)记为%1,输入寄存器\"m\"为%2。\n\n#### 输出寄存器\n\n描述输出操作数，不同的操作数描述符之间用逗号格开，每个操作数描述符由**限定字符串和C语言变量**组成。每个**输出操作数的限定字符串必须包含“=”**，表示它是一个输出操作数。例如：\n\n```__asm__   __volatile__ (\"pushfl ; popl %0 ; cli\":\"=g\" (x) )```\n\n在这里“x”便是最终存放输出结果的C程序变量，而“=g”则是限定字符串，限定字符串表示了对它之后的变量的限制条件 。\n\n#### 输入寄存器\n\n描述输入操作数，不同的操作数描述符之间使用逗号格开，每个操作数描述符同样也由限定字符串和C语言表达式或者C语言变量组成。例：\n\n```c\n__asm__ volatile__ (\"lidt %0\" : : \"m\" (real_mode_idt));\n```\n\n其中%0是占位操作符，而输出寄存器为空，输入寄存器的值为C语言表达式real_mode_idt。\n\n#### 限定字符串\n\n又叫做寄存器加载代码\n\n| 限定字符      | 描述           | 限定字符 | 描述 |\n| ------------- | -------------- | -------- | ---- |\n| a             | 使用寄存器eax  | m | 使用内存地址 |\n| b      | 使用寄存器ebx | o | 使用内存地址并可以加偏移值 |\n| m、o、V、p    | 使用寄存器ecx | I | 使用常数0~31 立即数 |\n| g、X          | 寄存器或内存   | J | 使用常数0~63 立即数 |\n| I、J、N、i、n | 立即数         | K | 使用常数0~255立即数 |\n| D         | 使用edi | L | 使用常数0~65535 立即数 |\n| q | 使用动态分配字节可寻址寄存器（eax、ebx、ecx或edx） | M | 使用常数0~3  立即数 |\n| r | 使用任意动态分配的寄存器 | N | 使用1字节常数（0~255）立即数 |\n| g | 使用通用有效的地址即可（eax、ebx、ecx、edx或内存变量） | O | 使用常数0~31 立即数 |\n| A | 使用eax与edx联合（64位） | i | 立即数 |\n\n## 例子\n\n直接摘抄自《Linux内核完全注释》第5.2.2 traps.c程序的第82页\n\n- 例子1：\n\n```assembly\n01 #define get_seg_byte(seg,addr) \\\n02 ({ \\\n03 register char __res; \\\n04 __asm__(\"push %%fs; \\\n05 mov %%ax,%%fs; \\\n06 movb %%fs:%2,%%al; \\\n07 pop %%fs\" \\\n08 :\"=a\" (__res) \\\n09 :\"\" (seg),\"m\" (*(addr))); \\\n10 __res;})\n```\n\n 第1 行定义了宏的名称，也即是宏函数名称 `get_seg_byte(seg,addr)` 。第 3 行定义了一个寄存器变量 res 。第 4 行上的 `__asm__ `表示嵌入汇编语句的开始。从第 4 行到第 7 行的 4 条语句是 AT&T 格式的汇编语句。\n\n第 8 行即是输出寄存器，这句的含义是在这段代码运行结束后将 eax 所代表的寄存器的值放入` __res`变量中，作为本函数的输出值， \"=a\" 中的 \"a\" 称为加载代码， \"=\" 表示这是输出寄存器。第 9 行表示在这段代码开始运行时将 seg 放到 eax 寄存器中， \"\" 表示使用与上面同个位置的输出相同的寄存器。而 (*(addr))表示一个内存偏移地址值。为了在上面汇编语句中使用该地址值，嵌入汇编程序规定把输出和输入寄存器统一按顺序编号，顺序是从输出寄存器序列从左到右从上到下以 \"%0\" 开始，分别记为 %0 、 %1 、 …%9 。因此，输出寄存器的编号是 %0 （这里只有一个输出寄存器），输入寄存器前一部分 (\"\" (seg)) 的编号是 %1 ，而后部分的编号是 %2 。上面第 6 行上的 %2 即代表 (*(addr)) 这个内存偏移量。现在我们来研究 4—7 行上的代码的作用。第一句将 fs 段寄存器的内容入栈；第二句将 eax 中的段值赋给 fs 段寄存器；第三句是把 fs:(*(addr)) 所指定的字节放入 al 寄存器中。当执行完汇编语句后，输出寄存器 eax 的值将被放入 `__res` ，作为该宏函数（块结构表达式）的返回值。\n\n通过上面分析，我们知道，宏名称中的 seg 代表一指定的内存段值，而 addr 表示一内存偏移地址量。到现在为止，我们应该很清楚这段程序的功能了吧！该宏函数的功能是从指定段和偏移值的内存地址处取一个字节。\n\n通过上面的例子说明，阅读这段代码时应该像CPU处理指令时的逻辑一样，先从输出输入寄存器语句开始知道输入输出是什么，然后再阅读汇编语句，处理完后再看最后的返回是什么。\n\n- 例子2\n\n再来看下Linux 内核中main()中对中断异常挂接的trap_init()中的设计到的一个GCC内嵌汇编。代码路径为；include\\asm\\system.h\n\n```assembly\n1 #define _set_gate(gate_addr,type,dpl,addr) \\\n2 __asm__ (\"movw %%dx,%%ax\\n\\t\" \\\n3\t\"movw %0,%%dx\\n\\t\" \\\n4\t\"movl %%eax,%1\\n\\t\" \\\n5\t\"movl %%edx,%2\" \\\n6\t: \\\n7\t: \"i\" ((short) (0x8000+(dpl<<13)+(type<<8))), \\\n8\t\"o\" (*((char *) (gate_addr))), \\\n9\t\"o\" (*(4+(char *) (gate_addr))), \\\n10\t\"d\" ((char *) (addr)),\"a\" (0x00080000)) \n```\n\n首先从第6行输出寄存器开始阅读：输出寄存器为空。然后是第7至10行的输入寄存器。第%0个输入寄存器使用“i”表示输入立即数，第%1个输入寄存器使用“o”表示使用内存地址并可以加偏移值，第%2个输入寄存器依然使用“o”代码，第%3个寄存器使用“d”表示使用寄存器edx，第%4个寄存器使用“a”表示使用寄存器eax。\n\n之后再看下汇编语句：依次进行值得传递。\n\n## 参考\n\n《Linux内核设计的艺术》新设计团队 著\n\n《Linux内核完全注释》赵炯 编著","slug":"2019-10-31-内嵌汇编","published":1,"updated":"2019-11-09T03:10:05.388Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2yelxhn001cm8tz9xdq8iyi","content":"<h1 id=\"内嵌汇编\"><a href=\"#内嵌汇编\" class=\"headerlink\" title=\"内嵌汇编\"></a>内嵌汇编</h1><p>操作系统高级教程上面需要阅读Linux内核0.11的源码，其中在书《Linux内核设计的一书》第2.5节异常处理类中段服务程序挂接的部分，遇到了嵌入在C语言中的汇编代码，之前从来没有学习过汇编，因此记录下。</p>\n<a id=\"more\"></a>\n<h2 id=\"AT-amp-T基础知识\"><a href=\"#AT-amp-T基础知识\" class=\"headerlink\" title=\"AT&amp;T基础知识\"></a>AT&amp;T基础知识</h2><p>内嵌汇编使用的是AT&amp;T汇编，所以首先稍微讲解下AT&amp;T的汇编指令的基础知识。</p>\n<h3 id=\"操作数前缀\"><a href=\"#操作数前缀\" class=\"headerlink\" title=\"操作数前缀\"></a>操作数前缀</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">movl   $8,%eax </span><br><span class=\"line\">movl   $0xffff,%ebx </span><br><span class=\"line\">int     $0x80</span><br></pre></td></tr></table></figure>\n<p>看到在AT%T汇编中诸如”%eax”、”%ebx”之类的寄存器名字前都要加上”%”；”$8”、”$0xffff”这样的立即数之前都要加上”$”。  </p>\n<h3 id=\"源-目的操作数顺序\"><a href=\"#源-目的操作数顺序\" class=\"headerlink\" title=\"源/目的操作数顺序\"></a>源/目的操作数顺序</h3><p>   在Intel语法中，第一个操作数是目的操作数，第二个操作数源操作数。而在AT&amp;T中，第一个数是源操作数，第二个数是目的操作数。 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// INTEL语法</span><br><span class=\"line\">MOV EAX,8 //EAX是目的操作数， 8是源操作数</span><br><span class=\"line\">// AT&amp;T语法</span><br><span class=\"line\">movl   $8,%eax //8是源操作数 EAX是目的操作数</span><br></pre></td></tr></table></figure>\n<h3 id=\"标识长度的操作码后缀\"><a href=\"#标识长度的操作码后缀\" class=\"headerlink\" title=\"标识长度的操作码后缀\"></a>标识长度的操作码后缀</h3><p>在AT&amp;T的操作码后面有时还会有一个后缀，其含义就是指出操作码的大小。“l”表示长整数（32位），“w”表示字（16位），“b”表示字节（8位）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">movb    %bl,%al</span><br><span class=\"line\">movw   %bx,%ax</span><br><span class=\"line\">movl     %ebx,%eax</span><br><span class=\"line\">movl     (%ebx),%eax</span><br></pre></td></tr></table></figure>\n<h2 id=\"GCC内嵌汇编\"><a href=\"#GCC内嵌汇编\" class=\"headerlink\" title=\"GCC内嵌汇编\"></a>GCC内嵌汇编</h2><p>Linux操作系统内核代码绝大部分使用C语言编写，只有一小部分使用汇编语言编写，例如与特定体系结构相关的代码和对性能影响很大的代码。GCC提供了内嵌汇编的功能，可以在C代码中直接内嵌汇编语言语句，大大方便了程序设计。 </p>\n<h3 id=\"基本行内汇编\"><a href=\"#基本行内汇编\" class=\"headerlink\" title=\"基本行内汇编\"></a>基本行内汇编</h3><p>基本行内汇编很容易理解，一般是按照下面的格式：</p>\n  <figure class=\"highlight plain\"><figcaption><span>```</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">在“asm”后面有时也会加上“__volatile__”表示编译器不要优化代码，后面的指令保留原样 </span><br><span class=\"line\"></span><br><span class=\"line\"> ```__asm__  __volatile__(&quot;hlt&quot;);``` </span><br><span class=\"line\"></span><br><span class=\"line\">如果有很多行汇编，则每一行后要加上“\\n\\t” ：</span><br><span class=\"line\"></span><br><span class=\"line\">```assembly</span><br><span class=\"line\"> asm( &quot;pushl %eax\\n\\t&quot;</span><br><span class=\"line\"> &quot;movl $0,%eax\\n\\t&quot;</span><br><span class=\"line\">&quot;popl %eax&quot;);</span><br></pre></td></tr></table></figure>\n<p>或者我们也可以分成几行来写，如： </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">asm(&quot;movl %eax,%ebx&quot;);</span><br><span class=\"line\">asm(&quot;xorl %ebx,%edx&quot;);</span><br><span class=\"line\">asm(&quot;movl $0,_booga);</span><br></pre></td></tr></table></figure>\n<p>通常使用汇编语句最方便的方式是把它们放在一个宏内，而宏语句需要在一行上定义，因此使用反斜杠<code>\\</code>将这些语句连成一行，所以上述语句如果在宏中定义的话就是：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">asm</span>( <span class=\"string\">\"pushl %eax; \\</span></span><br><span class=\"line\"><span class=\"string\"> movl $0,%eax; \\</span></span><br><span class=\"line\"><span class=\"string\">popl %eax\"</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"扩展的行内汇编\"><a href=\"#扩展的行内汇编\" class=\"headerlink\" title=\"扩展的行内汇编\"></a>扩展的行内汇编</h3><p>在扩展的行内汇编中，可以将C语言表达式（比如C语言中的变量）指定为汇编指令的操作数，而且不用去管如何将C语言表达式的值读入寄存器，以及如何将计算结果写回C变量，你只要告诉程序中C语言表达式与汇编指令操作数之间的对应关系即可， GCC会自动插入代码完成必要的操作。 </p>\n<p>使用内嵌汇编，要先编写汇编指令模板，然后将C语言表达式与指令的操作数相关联，并告诉GCC对这些操作有哪些限制条件。例如下面的内嵌汇编语句： </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> input = <span class=\"number\">8</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> result = <span class=\"number\">0</span>;</span><br><span class=\"line\">    __asm__ __violate__  (<span class=\"string\">\"movl %1,%0\"</span> : <span class=\"string\">\"=r\"</span> (result) : <span class=\"string\">\"r\"</span> (input));</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>,result);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>“movl %1,%0”</code>是指令模板；“%0”和“%1”代表指令的操作数，称为占位符，“=r”代表它之后是输入变量且需用到寄存器，指令模板后面用小括号括起来的是C语言表达式 ，其中input是输入变量，该指令会完成把input的值复制到result中的操作 。</p>\n<h3 id=\"扩展的行内汇编的语法\"><a href=\"#扩展的行内汇编的语法\" class=\"headerlink\" title=\"扩展的行内汇编的语法\"></a>扩展的行内汇编的语法</h3><p>内嵌汇编语法如下：</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">asm(&quot;汇编语句模块&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">     :输出寄存器 </span><br><span class=\"line\"></span><br><span class=\"line\">     :输入寄存器 </span><br><span class=\"line\"></span><br><span class=\"line\">     :会被修改的寄存器);</span><br></pre></td></tr></table></figure>\n<p>即格式为<code>asm ( &quot;statements&quot; : output_regs : input_regs : clobbered_regs)</code></p>\n<p>汇编语句模块必不可少，其他三部分可选，如果使用了后面的部分，而前面部分为空，也需要用“:”格开，相应部分内容为空。 </p>\n<h4 id=\"汇编语句模块\"><a href=\"#汇编语句模块\" class=\"headerlink\" title=\"汇编语句模块\"></a>汇编语句模块</h4><p>汇编语句模块由汇编语句序列组成，语句之间使用“;”、“\\n”或“\\n\\t”分开。指令中的操作数可以使用占位符引用C语言变量，<strong>操作数占位符</strong>最多10个，名称如下：%0，%1…，%9。指令中使用占位符表示的操作数，总被视为long型（4，个字节），但对其施加的操作根据指令可以是字或者字节，当把操作数当作字或者字节使用时，默认为低字或者低字节。对字节操作可以显式的指明是低字节还是次字节。方法是在%和序号之间插入一个字母，“b”代表低字节，“h”代表高字节，例如：%h1。 </p>\n<p>占位符的理解：将汇编输出寄存器与输入寄存器从输出寄存器行开始左到右从上到下进行编号分别为：%0，%1…，%9。比如有代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define get_seg_byte(seg,addr) \\</span><br><span class=\"line\">(&#123; \\</span><br><span class=\"line\">register char __res; \\</span><br><span class=\"line\">__asm__(&quot;push %%fs; \\</span><br><span class=\"line\">mov %%ax,%%fs; \\</span><br><span class=\"line\">movb %%fs:%2,%%al; \\</span><br><span class=\"line\">pop %%fs&quot; \\</span><br><span class=\"line\">:&quot;=a&quot; (__res) \\</span><br><span class=\"line\">:&quot;&quot; (seg),&quot;m&quot; (*(addr))); \\</span><br><span class=\"line\">__res;&#125;)</span><br></pre></td></tr></table></figure>\n<p>输出寄存器”=a”eax记为%0,输入寄存器””(依然是eax)记为%1,输入寄存器”m”为%2。</p>\n<h4 id=\"输出寄存器\"><a href=\"#输出寄存器\" class=\"headerlink\" title=\"输出寄存器\"></a>输出寄存器</h4><p>描述输出操作数，不同的操作数描述符之间用逗号格开，每个操作数描述符由<strong>限定字符串和C语言变量</strong>组成。每个<strong>输出操作数的限定字符串必须包含“=”</strong>，表示它是一个输出操作数。例如：</p>\n<figure class=\"highlight plain\"><figcaption><span>__volatile__ (\"pushfl ; popl %0 ; cli\":\"</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">在这里“x”便是最终存放输出结果的C程序变量，而“=g”则是限定字符串，限定字符串表示了对它之后的变量的限制条件 。</span><br><span class=\"line\"></span><br><span class=\"line\">#### 输入寄存器</span><br><span class=\"line\"></span><br><span class=\"line\">描述输入操作数，不同的操作数描述符之间使用逗号格开，每个操作数描述符同样也由限定字符串和C语言表达式或者C语言变量组成。例：</span><br><span class=\"line\"></span><br><span class=\"line\">```c</span><br><span class=\"line\">__asm__ volatile__ (&quot;lidt %0&quot; : : &quot;m&quot; (real_mode_idt));</span><br></pre></td></tr></table></figure>\n<p>其中%0是占位操作符，而输出寄存器为空，输入寄存器的值为C语言表达式real_mode_idt。</p>\n<h4 id=\"限定字符串\"><a href=\"#限定字符串\" class=\"headerlink\" title=\"限定字符串\"></a>限定字符串</h4><p>又叫做寄存器加载代码</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>限定字符</th>\n<th>描述</th>\n<th>限定字符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a</td>\n<td>使用寄存器eax</td>\n<td>m</td>\n<td>使用内存地址</td>\n</tr>\n<tr>\n<td>b</td>\n<td>使用寄存器ebx</td>\n<td>o</td>\n<td>使用内存地址并可以加偏移值</td>\n</tr>\n<tr>\n<td>m、o、V、p</td>\n<td>使用寄存器ecx</td>\n<td>I</td>\n<td>使用常数0~31 立即数</td>\n</tr>\n<tr>\n<td>g、X</td>\n<td>寄存器或内存</td>\n<td>J</td>\n<td>使用常数0~63 立即数</td>\n</tr>\n<tr>\n<td>I、J、N、i、n</td>\n<td>立即数</td>\n<td>K</td>\n<td>使用常数0~255立即数</td>\n</tr>\n<tr>\n<td>D</td>\n<td>使用edi</td>\n<td>L</td>\n<td>使用常数0~65535 立即数</td>\n</tr>\n<tr>\n<td>q</td>\n<td>使用动态分配字节可寻址寄存器（eax、ebx、ecx或edx）</td>\n<td>M</td>\n<td>使用常数0~3  立即数</td>\n</tr>\n<tr>\n<td>r</td>\n<td>使用任意动态分配的寄存器</td>\n<td>N</td>\n<td>使用1字节常数（0~255）立即数</td>\n</tr>\n<tr>\n<td>g</td>\n<td>使用通用有效的地址即可（eax、ebx、ecx、edx或内存变量）</td>\n<td>O</td>\n<td>使用常数0~31 立即数</td>\n</tr>\n<tr>\n<td>A</td>\n<td>使用eax与edx联合（64位）</td>\n<td>i</td>\n<td>立即数</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p>直接摘抄自《Linux内核完全注释》第5.2.2 traps.c程序的第82页</p>\n<ul>\n<li>例子1：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">01 #define get_seg_byte(seg,addr) \\</span><br><span class=\"line\">02 (&#123; \\</span><br><span class=\"line\">03 register char __res; \\</span><br><span class=\"line\">04 __asm__(&quot;push %%fs; \\</span><br><span class=\"line\">05 mov %%ax,%%fs; \\</span><br><span class=\"line\">06 movb %%fs:%2,%%al; \\</span><br><span class=\"line\">07 pop %%fs&quot; \\</span><br><span class=\"line\">08 :&quot;=a&quot; (__res) \\</span><br><span class=\"line\">09 :&quot;&quot; (seg),&quot;m&quot; (*(addr))); \\</span><br><span class=\"line\">10 __res;&#125;)</span><br></pre></td></tr></table></figure>\n<p> 第1 行定义了宏的名称，也即是宏函数名称 <code>get_seg_byte(seg,addr)</code> 。第 3 行定义了一个寄存器变量 res 。第 4 行上的 <code>__asm__</code>表示嵌入汇编语句的开始。从第 4 行到第 7 行的 4 条语句是 AT&amp;T 格式的汇编语句。</p>\n<p>第 8 行即是输出寄存器，这句的含义是在这段代码运行结束后将 eax 所代表的寄存器的值放入<code>__res</code>变量中，作为本函数的输出值， “=a” 中的 “a” 称为加载代码， “=” 表示这是输出寄存器。第 9 行表示在这段代码开始运行时将 seg 放到 eax 寄存器中， “” 表示使用与上面同个位置的输出相同的寄存器。而 (<em>(addr))表示一个内存偏移地址值。为了在上面汇编语句中使用该地址值，嵌入汇编程序规定把输出和输入寄存器统一按顺序编号，顺序是从输出寄存器序列从左到右从上到下以 “%0” 开始，分别记为 %0 、 %1 、 …%9 。因此，输出寄存器的编号是 %0 （这里只有一个输出寄存器），输入寄存器前一部分 (“” (seg)) 的编号是 %1 ，而后部分的编号是 %2 。上面第 6 行上的 %2 即代表 (</em>(addr)) 这个内存偏移量。现在我们来研究 4—7 行上的代码的作用。第一句将 fs 段寄存器的内容入栈；第二句将 eax 中的段值赋给 fs 段寄存器；第三句是把 fs:(*(addr)) 所指定的字节放入 al 寄存器中。当执行完汇编语句后，输出寄存器 eax 的值将被放入 <code>__res</code> ，作为该宏函数（块结构表达式）的返回值。</p>\n<p>通过上面分析，我们知道，宏名称中的 seg 代表一指定的内存段值，而 addr 表示一内存偏移地址量。到现在为止，我们应该很清楚这段程序的功能了吧！该宏函数的功能是从指定段和偏移值的内存地址处取一个字节。</p>\n<p>通过上面的例子说明，阅读这段代码时应该像CPU处理指令时的逻辑一样，先从输出输入寄存器语句开始知道输入输出是什么，然后再阅读汇编语句，处理完后再看最后的返回是什么。</p>\n<ul>\n<li>例子2</li>\n</ul>\n<p>再来看下Linux 内核中main()中对中断异常挂接的trap_init()中的设计到的一个GCC内嵌汇编。代码路径为；include\\asm\\system.h</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 #define _set_gate(gate_addr,type,dpl,addr) \\</span><br><span class=\"line\">2 __asm__ (&quot;movw %%dx,%%ax\\n\\t&quot; \\</span><br><span class=\"line\">3\t&quot;movw %0,%%dx\\n\\t&quot; \\</span><br><span class=\"line\">4\t&quot;movl %%eax,%1\\n\\t&quot; \\</span><br><span class=\"line\">5\t&quot;movl %%edx,%2&quot; \\</span><br><span class=\"line\">6\t: \\</span><br><span class=\"line\">7\t: &quot;i&quot; ((short) (0x8000+(dpl&lt;&lt;13)+(type&lt;&lt;8))), \\</span><br><span class=\"line\">8\t&quot;o&quot; (*((char *) (gate_addr))), \\</span><br><span class=\"line\">9\t&quot;o&quot; (*(4+(char *) (gate_addr))), \\</span><br><span class=\"line\">10\t&quot;d&quot; ((char *) (addr)),&quot;a&quot; (0x00080000))</span><br></pre></td></tr></table></figure>\n<p>首先从第6行输出寄存器开始阅读：输出寄存器为空。然后是第7至10行的输入寄存器。第%0个输入寄存器使用“i”表示输入立即数，第%1个输入寄存器使用“o”表示使用内存地址并可以加偏移值，第%2个输入寄存器依然使用“o”代码，第%3个寄存器使用“d”表示使用寄存器edx，第%4个寄存器使用“a”表示使用寄存器eax。</p>\n<p>之后再看下汇编语句：依次进行值得传递。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>《Linux内核设计的艺术》新设计团队 著</p>\n<p>《Linux内核完全注释》赵炯 编著</p>\n","site":{"data":{}},"length":4810,"excerpt":"<h1 id=\"内嵌汇编\"><a href=\"#内嵌汇编\" class=\"headerlink\" title=\"内嵌汇编\"></a>内嵌汇编</h1><p>操作系统高级教程上面需要阅读Linux内核0.11的源码，其中在书《Linux内核设计的一书》第2.5节异常处理类中段服务程序挂接的部分，遇到了嵌入在C语言中的汇编代码，之前从来没有学习过汇编，因此记录下。</p>","more":"<h2 id=\"AT-amp-T基础知识\"><a href=\"#AT-amp-T基础知识\" class=\"headerlink\" title=\"AT&amp;T基础知识\"></a>AT&amp;T基础知识</h2><p>内嵌汇编使用的是AT&amp;T汇编，所以首先稍微讲解下AT&amp;T的汇编指令的基础知识。</p>\n<h3 id=\"操作数前缀\"><a href=\"#操作数前缀\" class=\"headerlink\" title=\"操作数前缀\"></a>操作数前缀</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">movl   $8,%eax </span><br><span class=\"line\">movl   $0xffff,%ebx </span><br><span class=\"line\">int     $0x80</span><br></pre></td></tr></table></figure>\n<p>看到在AT%T汇编中诸如”%eax”、”%ebx”之类的寄存器名字前都要加上”%”；”$8”、”$0xffff”这样的立即数之前都要加上”$”。  </p>\n<h3 id=\"源-目的操作数顺序\"><a href=\"#源-目的操作数顺序\" class=\"headerlink\" title=\"源/目的操作数顺序\"></a>源/目的操作数顺序</h3><p>   在Intel语法中，第一个操作数是目的操作数，第二个操作数源操作数。而在AT&amp;T中，第一个数是源操作数，第二个数是目的操作数。 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// INTEL语法</span><br><span class=\"line\">MOV EAX,8 //EAX是目的操作数， 8是源操作数</span><br><span class=\"line\">// AT&amp;T语法</span><br><span class=\"line\">movl   $8,%eax //8是源操作数 EAX是目的操作数</span><br></pre></td></tr></table></figure>\n<h3 id=\"标识长度的操作码后缀\"><a href=\"#标识长度的操作码后缀\" class=\"headerlink\" title=\"标识长度的操作码后缀\"></a>标识长度的操作码后缀</h3><p>在AT&amp;T的操作码后面有时还会有一个后缀，其含义就是指出操作码的大小。“l”表示长整数（32位），“w”表示字（16位），“b”表示字节（8位）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">movb    %bl,%al</span><br><span class=\"line\">movw   %bx,%ax</span><br><span class=\"line\">movl     %ebx,%eax</span><br><span class=\"line\">movl     (%ebx),%eax</span><br></pre></td></tr></table></figure>\n<h2 id=\"GCC内嵌汇编\"><a href=\"#GCC内嵌汇编\" class=\"headerlink\" title=\"GCC内嵌汇编\"></a>GCC内嵌汇编</h2><p>Linux操作系统内核代码绝大部分使用C语言编写，只有一小部分使用汇编语言编写，例如与特定体系结构相关的代码和对性能影响很大的代码。GCC提供了内嵌汇编的功能，可以在C代码中直接内嵌汇编语言语句，大大方便了程序设计。 </p>\n<h3 id=\"基本行内汇编\"><a href=\"#基本行内汇编\" class=\"headerlink\" title=\"基本行内汇编\"></a>基本行内汇编</h3><p>基本行内汇编很容易理解，一般是按照下面的格式：</p>\n  <figure class=\"highlight plain\"><figcaption><span>```</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">在“asm”后面有时也会加上“__volatile__”表示编译器不要优化代码，后面的指令保留原样 </span><br><span class=\"line\"></span><br><span class=\"line\"> ```__asm__  __volatile__(&quot;hlt&quot;);``` </span><br><span class=\"line\"></span><br><span class=\"line\">如果有很多行汇编，则每一行后要加上“\\n\\t” ：</span><br><span class=\"line\"></span><br><span class=\"line\">```assembly</span><br><span class=\"line\"> asm( &quot;pushl %eax\\n\\t&quot;</span><br><span class=\"line\"> &quot;movl $0,%eax\\n\\t&quot;</span><br><span class=\"line\">&quot;popl %eax&quot;);</span><br></pre></td></tr></table></figure>\n<p>或者我们也可以分成几行来写，如： </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">asm(&quot;movl %eax,%ebx&quot;);</span><br><span class=\"line\">asm(&quot;xorl %ebx,%edx&quot;);</span><br><span class=\"line\">asm(&quot;movl $0,_booga);</span><br></pre></td></tr></table></figure>\n<p>通常使用汇编语句最方便的方式是把它们放在一个宏内，而宏语句需要在一行上定义，因此使用反斜杠<code>\\</code>将这些语句连成一行，所以上述语句如果在宏中定义的话就是：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">asm</span>( <span class=\"string\">\"pushl %eax; \\</span></span><br><span class=\"line\"><span class=\"string\"> movl $0,%eax; \\</span></span><br><span class=\"line\"><span class=\"string\">popl %eax\"</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"扩展的行内汇编\"><a href=\"#扩展的行内汇编\" class=\"headerlink\" title=\"扩展的行内汇编\"></a>扩展的行内汇编</h3><p>在扩展的行内汇编中，可以将C语言表达式（比如C语言中的变量）指定为汇编指令的操作数，而且不用去管如何将C语言表达式的值读入寄存器，以及如何将计算结果写回C变量，你只要告诉程序中C语言表达式与汇编指令操作数之间的对应关系即可， GCC会自动插入代码完成必要的操作。 </p>\n<p>使用内嵌汇编，要先编写汇编指令模板，然后将C语言表达式与指令的操作数相关联，并告诉GCC对这些操作有哪些限制条件。例如下面的内嵌汇编语句： </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> input = <span class=\"number\">8</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> result = <span class=\"number\">0</span>;</span><br><span class=\"line\">    __asm__ __violate__  (<span class=\"string\">\"movl %1,%0\"</span> : <span class=\"string\">\"=r\"</span> (result) : <span class=\"string\">\"r\"</span> (input));</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>,result);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>“movl %1,%0”</code>是指令模板；“%0”和“%1”代表指令的操作数，称为占位符，“=r”代表它之后是输入变量且需用到寄存器，指令模板后面用小括号括起来的是C语言表达式 ，其中input是输入变量，该指令会完成把input的值复制到result中的操作 。</p>\n<h3 id=\"扩展的行内汇编的语法\"><a href=\"#扩展的行内汇编的语法\" class=\"headerlink\" title=\"扩展的行内汇编的语法\"></a>扩展的行内汇编的语法</h3><p>内嵌汇编语法如下：</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">asm(&quot;汇编语句模块&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">     :输出寄存器 </span><br><span class=\"line\"></span><br><span class=\"line\">     :输入寄存器 </span><br><span class=\"line\"></span><br><span class=\"line\">     :会被修改的寄存器);</span><br></pre></td></tr></table></figure>\n<p>即格式为<code>asm ( &quot;statements&quot; : output_regs : input_regs : clobbered_regs)</code></p>\n<p>汇编语句模块必不可少，其他三部分可选，如果使用了后面的部分，而前面部分为空，也需要用“:”格开，相应部分内容为空。 </p>\n<h4 id=\"汇编语句模块\"><a href=\"#汇编语句模块\" class=\"headerlink\" title=\"汇编语句模块\"></a>汇编语句模块</h4><p>汇编语句模块由汇编语句序列组成，语句之间使用“;”、“\\n”或“\\n\\t”分开。指令中的操作数可以使用占位符引用C语言变量，<strong>操作数占位符</strong>最多10个，名称如下：%0，%1…，%9。指令中使用占位符表示的操作数，总被视为long型（4，个字节），但对其施加的操作根据指令可以是字或者字节，当把操作数当作字或者字节使用时，默认为低字或者低字节。对字节操作可以显式的指明是低字节还是次字节。方法是在%和序号之间插入一个字母，“b”代表低字节，“h”代表高字节，例如：%h1。 </p>\n<p>占位符的理解：将汇编输出寄存器与输入寄存器从输出寄存器行开始左到右从上到下进行编号分别为：%0，%1…，%9。比如有代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define get_seg_byte(seg,addr) \\</span><br><span class=\"line\">(&#123; \\</span><br><span class=\"line\">register char __res; \\</span><br><span class=\"line\">__asm__(&quot;push %%fs; \\</span><br><span class=\"line\">mov %%ax,%%fs; \\</span><br><span class=\"line\">movb %%fs:%2,%%al; \\</span><br><span class=\"line\">pop %%fs&quot; \\</span><br><span class=\"line\">:&quot;=a&quot; (__res) \\</span><br><span class=\"line\">:&quot;&quot; (seg),&quot;m&quot; (*(addr))); \\</span><br><span class=\"line\">__res;&#125;)</span><br></pre></td></tr></table></figure>\n<p>输出寄存器”=a”eax记为%0,输入寄存器””(依然是eax)记为%1,输入寄存器”m”为%2。</p>\n<h4 id=\"输出寄存器\"><a href=\"#输出寄存器\" class=\"headerlink\" title=\"输出寄存器\"></a>输出寄存器</h4><p>描述输出操作数，不同的操作数描述符之间用逗号格开，每个操作数描述符由<strong>限定字符串和C语言变量</strong>组成。每个<strong>输出操作数的限定字符串必须包含“=”</strong>，表示它是一个输出操作数。例如：</p>\n<figure class=\"highlight plain\"><figcaption><span>__volatile__ (\"pushfl ; popl %0 ; cli\":\"</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">在这里“x”便是最终存放输出结果的C程序变量，而“=g”则是限定字符串，限定字符串表示了对它之后的变量的限制条件 。</span><br><span class=\"line\"></span><br><span class=\"line\">#### 输入寄存器</span><br><span class=\"line\"></span><br><span class=\"line\">描述输入操作数，不同的操作数描述符之间使用逗号格开，每个操作数描述符同样也由限定字符串和C语言表达式或者C语言变量组成。例：</span><br><span class=\"line\"></span><br><span class=\"line\">```c</span><br><span class=\"line\">__asm__ volatile__ (&quot;lidt %0&quot; : : &quot;m&quot; (real_mode_idt));</span><br></pre></td></tr></table></figure>\n<p>其中%0是占位操作符，而输出寄存器为空，输入寄存器的值为C语言表达式real_mode_idt。</p>\n<h4 id=\"限定字符串\"><a href=\"#限定字符串\" class=\"headerlink\" title=\"限定字符串\"></a>限定字符串</h4><p>又叫做寄存器加载代码</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>限定字符</th>\n<th>描述</th>\n<th>限定字符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a</td>\n<td>使用寄存器eax</td>\n<td>m</td>\n<td>使用内存地址</td>\n</tr>\n<tr>\n<td>b</td>\n<td>使用寄存器ebx</td>\n<td>o</td>\n<td>使用内存地址并可以加偏移值</td>\n</tr>\n<tr>\n<td>m、o、V、p</td>\n<td>使用寄存器ecx</td>\n<td>I</td>\n<td>使用常数0~31 立即数</td>\n</tr>\n<tr>\n<td>g、X</td>\n<td>寄存器或内存</td>\n<td>J</td>\n<td>使用常数0~63 立即数</td>\n</tr>\n<tr>\n<td>I、J、N、i、n</td>\n<td>立即数</td>\n<td>K</td>\n<td>使用常数0~255立即数</td>\n</tr>\n<tr>\n<td>D</td>\n<td>使用edi</td>\n<td>L</td>\n<td>使用常数0~65535 立即数</td>\n</tr>\n<tr>\n<td>q</td>\n<td>使用动态分配字节可寻址寄存器（eax、ebx、ecx或edx）</td>\n<td>M</td>\n<td>使用常数0~3  立即数</td>\n</tr>\n<tr>\n<td>r</td>\n<td>使用任意动态分配的寄存器</td>\n<td>N</td>\n<td>使用1字节常数（0~255）立即数</td>\n</tr>\n<tr>\n<td>g</td>\n<td>使用通用有效的地址即可（eax、ebx、ecx、edx或内存变量）</td>\n<td>O</td>\n<td>使用常数0~31 立即数</td>\n</tr>\n<tr>\n<td>A</td>\n<td>使用eax与edx联合（64位）</td>\n<td>i</td>\n<td>立即数</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p>直接摘抄自《Linux内核完全注释》第5.2.2 traps.c程序的第82页</p>\n<ul>\n<li>例子1：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">01 #define get_seg_byte(seg,addr) \\</span><br><span class=\"line\">02 (&#123; \\</span><br><span class=\"line\">03 register char __res; \\</span><br><span class=\"line\">04 __asm__(&quot;push %%fs; \\</span><br><span class=\"line\">05 mov %%ax,%%fs; \\</span><br><span class=\"line\">06 movb %%fs:%2,%%al; \\</span><br><span class=\"line\">07 pop %%fs&quot; \\</span><br><span class=\"line\">08 :&quot;=a&quot; (__res) \\</span><br><span class=\"line\">09 :&quot;&quot; (seg),&quot;m&quot; (*(addr))); \\</span><br><span class=\"line\">10 __res;&#125;)</span><br></pre></td></tr></table></figure>\n<p> 第1 行定义了宏的名称，也即是宏函数名称 <code>get_seg_byte(seg,addr)</code> 。第 3 行定义了一个寄存器变量 res 。第 4 行上的 <code>__asm__</code>表示嵌入汇编语句的开始。从第 4 行到第 7 行的 4 条语句是 AT&amp;T 格式的汇编语句。</p>\n<p>第 8 行即是输出寄存器，这句的含义是在这段代码运行结束后将 eax 所代表的寄存器的值放入<code>__res</code>变量中，作为本函数的输出值， “=a” 中的 “a” 称为加载代码， “=” 表示这是输出寄存器。第 9 行表示在这段代码开始运行时将 seg 放到 eax 寄存器中， “” 表示使用与上面同个位置的输出相同的寄存器。而 (<em>(addr))表示一个内存偏移地址值。为了在上面汇编语句中使用该地址值，嵌入汇编程序规定把输出和输入寄存器统一按顺序编号，顺序是从输出寄存器序列从左到右从上到下以 “%0” 开始，分别记为 %0 、 %1 、 …%9 。因此，输出寄存器的编号是 %0 （这里只有一个输出寄存器），输入寄存器前一部分 (“” (seg)) 的编号是 %1 ，而后部分的编号是 %2 。上面第 6 行上的 %2 即代表 (</em>(addr)) 这个内存偏移量。现在我们来研究 4—7 行上的代码的作用。第一句将 fs 段寄存器的内容入栈；第二句将 eax 中的段值赋给 fs 段寄存器；第三句是把 fs:(*(addr)) 所指定的字节放入 al 寄存器中。当执行完汇编语句后，输出寄存器 eax 的值将被放入 <code>__res</code> ，作为该宏函数（块结构表达式）的返回值。</p>\n<p>通过上面分析，我们知道，宏名称中的 seg 代表一指定的内存段值，而 addr 表示一内存偏移地址量。到现在为止，我们应该很清楚这段程序的功能了吧！该宏函数的功能是从指定段和偏移值的内存地址处取一个字节。</p>\n<p>通过上面的例子说明，阅读这段代码时应该像CPU处理指令时的逻辑一样，先从输出输入寄存器语句开始知道输入输出是什么，然后再阅读汇编语句，处理完后再看最后的返回是什么。</p>\n<ul>\n<li>例子2</li>\n</ul>\n<p>再来看下Linux 内核中main()中对中断异常挂接的trap_init()中的设计到的一个GCC内嵌汇编。代码路径为；include\\asm\\system.h</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 #define _set_gate(gate_addr,type,dpl,addr) \\</span><br><span class=\"line\">2 __asm__ (&quot;movw %%dx,%%ax\\n\\t&quot; \\</span><br><span class=\"line\">3\t&quot;movw %0,%%dx\\n\\t&quot; \\</span><br><span class=\"line\">4\t&quot;movl %%eax,%1\\n\\t&quot; \\</span><br><span class=\"line\">5\t&quot;movl %%edx,%2&quot; \\</span><br><span class=\"line\">6\t: \\</span><br><span class=\"line\">7\t: &quot;i&quot; ((short) (0x8000+(dpl&lt;&lt;13)+(type&lt;&lt;8))), \\</span><br><span class=\"line\">8\t&quot;o&quot; (*((char *) (gate_addr))), \\</span><br><span class=\"line\">9\t&quot;o&quot; (*(4+(char *) (gate_addr))), \\</span><br><span class=\"line\">10\t&quot;d&quot; ((char *) (addr)),&quot;a&quot; (0x00080000))</span><br></pre></td></tr></table></figure>\n<p>首先从第6行输出寄存器开始阅读：输出寄存器为空。然后是第7至10行的输入寄存器。第%0个输入寄存器使用“i”表示输入立即数，第%1个输入寄存器使用“o”表示使用内存地址并可以加偏移值，第%2个输入寄存器依然使用“o”代码，第%3个寄存器使用“d”表示使用寄存器edx，第%4个寄存器使用“a”表示使用寄存器eax。</p>\n<p>之后再看下汇编语句：依次进行值得传递。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>《Linux内核设计的艺术》新设计团队 著</p>\n<p>《Linux内核完全注释》赵炯 编著</p>"},{"title":"数组中的主要元素","date":"2019-10-14T02:46:11.000Z","copyright":true,"mathjax":true,"_content":"\n# 数组中的主要元素\n\nleetcode#169题，找出一个数组中出现次数超过$\\lfloor \\dfrac{n}{2}\\rfloor$ 次数的元素，也就是过半的主要元素。题目来源：\n\n<https://leetcode.com/problems/majority-element/> \n\n<!--more-->\n\n## 解题思路\n\n### 哈希表\n\n遍历一次数组然后将每个元素出现的次数放在哈希表中，key是元素，value是出现的次数。然后输出哈希表中值大于$\\lfloor \\dfrac{n}{2}\\rfloor$ 的元素。\n\n#### 复杂度\n\n遍历数组的时间复杂度为O(n)，新建一个哈希表造成的空间复杂度为O(n)。\n\n#### 代码\n\n第一个是自己写的,输入是为了自己调试和算法课程作业的UOJ，这个OJ有个卡内存的坑后面讲。\n\n```c++\n#include<iostream>\n#include<vector>\n#include<map>\n#include <stdio.h>\n\nusing namespace std;\nclass Solution {\npublic:\n    int majorityElement(vector<int>& nums) {\n        map<int, int> m;\n        for(int i=0; i<nums.size(); i++){\n            m[nums[i]]++;\n        }\n        int major = 0;\n        int max = 0;\n        for(map<int, int>::iterator it= m.begin(); it!=m.end(); it++){\n            if(it->second>=max){\n                max = it->second;\n                major = it->first;\n            }\n        }\n        return major;\n    }\n};\n\nint main(int argc, char const *argv[])\n{\n    // Solution sol;\n    // std::vector<int> vec={3,2,3};\n    // int ans = sol.majorityElement(vec);\n    // cout<<ans<<endl;\n    // cin>>ans;\n    ios::sync_with_stdio(false);\n    int len;\n    Solution Sol;\n    int ans;\n    while(cin>>len){\n        vector<int> vec(len);\n        for(int i = 0; i < len; i++) {\n            cin>>vec[i];\n        }\n        ans = Sol.majorityElement(vec);\n        cout<<ans<<endl;\n    }\n    return 0;\n}\n```\n\n然后再来看看花花大神写的：\n\n```c++\n// Author: Huahua\n// Runtime : 23 ms\nclass Solution {\npublic:\n    int majorityElement(vector<int>& nums) {\n        unordered_map<int, int> count;\n        const int n = nums.size();\n        for (const int num : nums)\n            if (++count[num] > n / 2) return num;\n        return -1;\n    }\n};\n```\n\n我自己写的代码多了一步冗余操作，就是完整的把count哈希表给建立完毕之后又多次一举的进行遍历寻找最大值。实际上在对原来的数组进行遍历的同时一定会出现主要元素的计数大于$\\lfloor \\dfrac{n}{2}\\rfloor$，这个时候直接返回就可以了。\n\n### 分治\n\n首先考虑最简单的情况，当n=1的时候，这个唯一的元素就是主要元素，这是一个最简单的子问题。那么是否所有自问都能正确返回主要元素呢？很明显当n=2的时候，如果A[0]!=A[1]，这个时候A是没有主要元素的。因为如果使用分治的话，子问题一定要有一个解得，所以当出现两个子问题的主要元素不一致的时候，如何来得到原问题的解呢？这时只能通过遍历，统计两个子问题对应的主要元素在更大的局部中出现的次数来解决。如果左边的主要元素在原问题的数组中出现的次数大于右边的主要元素那么答案就是左边的主要元素，否则的话就是右边的元素（需要注意的是返回右边的时候是包含右边的主要元素次数等于左边的情况，不过无所谓，因为后面的上一层还是要遍历统计的）。总结一下：\n\n**Divide** 将输入数组A划分为左边A[0, n/2] 与右边A[n/2+1, n-1]两个数组\n\n**Conquer** 左边的主要元素与右边的主要元素分别再各自递归的调用函数求解。\n\n**Merge** 如果左边与右边的主要元素相等，那么就直接返回这个主要元素。如果不等那就统计这两个主要元素在A中的出现次数，然后返回较大的那个，次数相等的话左右两个主要元素随便返回其中一个。\n\n#### 复杂度\n\n根据上面的思路可以写出递推式：首先是考虑最好的情况:就是每次都有左右两个子数组的主要元素相同，不需要判别，此时有递推公式：\n$$\n\\begin{equation}\\nonumber\n\\begin{split}\nT(n)&=2T[{\\lfloor\\frac{n}{2}\\rfloor]+Cn}\\\\\\\\\n&=2^2T[{\\lfloor\\frac{n}{2^2}\\rfloor]+C+2C}\\\\\\\\\n&=2^3T[{\\lfloor\\frac{n}{2^3}\\rfloor]+C+2C+2C}\\\\\\\\\n\\dots\\\\\\\\\n&=2^kT[{\\lfloor\\frac{n}{2^k}\\rfloor]+(2k-1)C}\\\\\\\\\n\\end{split} \n\\end{equation}\n$$\n每次分解后规模变为左右两个子树，因此下降到$\\lfloor\\frac{n}{2}\\rfloor$,而每次比较左右两个子树最大深度与更新最大路径长度所需的时间为常数C。设当第k次的时候下降到规模为1的叶子节点，因此有$\\frac{n}{2^k}=1$推出$k=\\log_2n$所以有$T(n)=n+(2\\log_2n-1)C=O(n)$,所以时间复杂度为O(n)。\n\n考虑最坏的情况：每次都需要重新遍历来确定主要元素，也就是递归树中的每一层都需要遍历数组也就是O(n)的成本。所以有递推公式\n$$\nT(n)=2T[{\\lfloor\\frac{n}{2}\\rfloor]+Cn}\n$$\n根据主定理可以得出算法的最坏时间复杂度为$O(nlogn)$\n\n空间复杂度因为可以使用左右的索引来进行划分，不需要额外的空间所以是O(1)。\n\n#### 代码\n\n```c++\n#include<iostream>\n#include<vector>\n#include<map>\n#include <stdio.h>\n\nusing namespace std;\nclass Solution {\nprivate:\n    int dc_majority(std::vector<int>&vec, int lo, int hi){\n        if(lo>=hi) return vec[lo];\n        int mid = lo + (hi-lo)/2;\n        int l_ans = dc_majority(vec, lo, mid);\n        int r_ans = dc_majority(vec, mid+1, hi);\n        if(l_ans==r_ans) return l_ans;\n        int l_ans_nums=0, r_ans_nums = 0;\n        for(int i=lo; i<=hi; i++){\n            if(vec[i]==l_ans) l_ans_nums++;\n            if(vec[i]==r_ans) r_ans_nums++;\n        }\n        return l_ans_nums>r_ans_nums ? l_ans : r_ans;\n    }\npublic:\n    int majorityElement(vector<int>& nums) {\n        int major=dc_majority(nums, 0, nums.size()-1);\n        return major;\n    }\n};\n\nint main(int argc, char const *argv[])\n{\n    // Solution sol;\n    // std::vector<int> vec={3,2,3};\n    // int ans = sol.majorityElement(vec);\n    // cout<<ans<<endl;\n    // cin>>ans;\n    ios::sync_with_stdio(false);\n    int len;\n    Solution Sol;\n    int ans;\n    while(cin>>len){\n        vector<int> vec(len);\n        for(int i = 0; i < len; i++) {\n            cin>>vec[i];\n        }\n        ans = Sol.majorityElement(vec);\n        cout<<ans<<endl;\n    }\n    return 0;\n}\t\n```\n\n### 摩尔投票\n\n每次从数组中删除一对不同的元素，按照题意到最后一定会剩下至少一个元素（假设每次不同的元素都是由一个主要元素和非主要元素组成的，这样的话最终仍然剩下主要元素，假设每次不同的元素都是非主要元素构成，最后肯定也会剩下多余的主要元素。也可以理解成捉对厮杀，因为主要元素的占比超过一半，其他非主要元素小于一半，所以最后一相减一定有主要元素剩下。）\n\n#### 代码\n\n直接用的花花大神的：\n\n```c++\nclass Solution {\npublic:\n    int majorityElement(vector<int>& nums) {\n        int majority = nums.front();\n        int count = 0;\n        \n        for (const int num : nums) {\n            if (num == majority) ++count;\n            else if (--count == 0) {\n                count = 1;\n                majority = num;\n            }\n        }\n        \n        return majority;\n    }\n};\n```\n\n#### 复杂度\n\n根据代码分析很容易得出时间复杂度为O(n), 空间复杂度为O(1)。\n\n\n\n## OJ的输入\n\n这道题最开始是在UOJ上面的课程作业，我最开始做的时候不管怎么调，用什么方法，包括摩尔投票都会爆内存超过限制，后面分析出来的原因是：\n\n```c++\nint main(){\n\tSolution Sol;\n\tvector<int> vec;\n\tint n ;\n\twhile(cin>>n){\n\t\t//int tmp = n;\n\t\tint element;\n\t\twhile(n--){\n\t\t\tcin>>element;\n\t\t\tvec.push_back(element);\n\t\t}\n\t\tcout<<Sol.majorityElement(vec)<<endl;\n\t}\n\t\n}\n```\n\n我的输入是用push_back()来输入进vector中的，而vector的内存是动态申请的，不足的话会申请原来的两倍，所以造成了内存超过限制的原因，比如只需要11m的，假设上一次的vector申请到的是10m，所以下次就申请了20m造成了内存超过限制。\n\n## 参考\n\n<http://zxi.mytechroad.com/blog/divide-and-conquer/leetcode-169-majority-element/> ","source":"_posts/2019-10-14-数组中的主要元素.md","raw":"---\ntitle: 数组中的主要元素\ndate: 2019-10-14 10:46:11\ncategories: 题解\ntags:\n- 分治\n- 哈希\n- 摩尔投票\n- leetcode\ncopyright: true\nmathjax: true\n---\n\n# 数组中的主要元素\n\nleetcode#169题，找出一个数组中出现次数超过$\\lfloor \\dfrac{n}{2}\\rfloor$ 次数的元素，也就是过半的主要元素。题目来源：\n\n<https://leetcode.com/problems/majority-element/> \n\n<!--more-->\n\n## 解题思路\n\n### 哈希表\n\n遍历一次数组然后将每个元素出现的次数放在哈希表中，key是元素，value是出现的次数。然后输出哈希表中值大于$\\lfloor \\dfrac{n}{2}\\rfloor$ 的元素。\n\n#### 复杂度\n\n遍历数组的时间复杂度为O(n)，新建一个哈希表造成的空间复杂度为O(n)。\n\n#### 代码\n\n第一个是自己写的,输入是为了自己调试和算法课程作业的UOJ，这个OJ有个卡内存的坑后面讲。\n\n```c++\n#include<iostream>\n#include<vector>\n#include<map>\n#include <stdio.h>\n\nusing namespace std;\nclass Solution {\npublic:\n    int majorityElement(vector<int>& nums) {\n        map<int, int> m;\n        for(int i=0; i<nums.size(); i++){\n            m[nums[i]]++;\n        }\n        int major = 0;\n        int max = 0;\n        for(map<int, int>::iterator it= m.begin(); it!=m.end(); it++){\n            if(it->second>=max){\n                max = it->second;\n                major = it->first;\n            }\n        }\n        return major;\n    }\n};\n\nint main(int argc, char const *argv[])\n{\n    // Solution sol;\n    // std::vector<int> vec={3,2,3};\n    // int ans = sol.majorityElement(vec);\n    // cout<<ans<<endl;\n    // cin>>ans;\n    ios::sync_with_stdio(false);\n    int len;\n    Solution Sol;\n    int ans;\n    while(cin>>len){\n        vector<int> vec(len);\n        for(int i = 0; i < len; i++) {\n            cin>>vec[i];\n        }\n        ans = Sol.majorityElement(vec);\n        cout<<ans<<endl;\n    }\n    return 0;\n}\n```\n\n然后再来看看花花大神写的：\n\n```c++\n// Author: Huahua\n// Runtime : 23 ms\nclass Solution {\npublic:\n    int majorityElement(vector<int>& nums) {\n        unordered_map<int, int> count;\n        const int n = nums.size();\n        for (const int num : nums)\n            if (++count[num] > n / 2) return num;\n        return -1;\n    }\n};\n```\n\n我自己写的代码多了一步冗余操作，就是完整的把count哈希表给建立完毕之后又多次一举的进行遍历寻找最大值。实际上在对原来的数组进行遍历的同时一定会出现主要元素的计数大于$\\lfloor \\dfrac{n}{2}\\rfloor$，这个时候直接返回就可以了。\n\n### 分治\n\n首先考虑最简单的情况，当n=1的时候，这个唯一的元素就是主要元素，这是一个最简单的子问题。那么是否所有自问都能正确返回主要元素呢？很明显当n=2的时候，如果A[0]!=A[1]，这个时候A是没有主要元素的。因为如果使用分治的话，子问题一定要有一个解得，所以当出现两个子问题的主要元素不一致的时候，如何来得到原问题的解呢？这时只能通过遍历，统计两个子问题对应的主要元素在更大的局部中出现的次数来解决。如果左边的主要元素在原问题的数组中出现的次数大于右边的主要元素那么答案就是左边的主要元素，否则的话就是右边的元素（需要注意的是返回右边的时候是包含右边的主要元素次数等于左边的情况，不过无所谓，因为后面的上一层还是要遍历统计的）。总结一下：\n\n**Divide** 将输入数组A划分为左边A[0, n/2] 与右边A[n/2+1, n-1]两个数组\n\n**Conquer** 左边的主要元素与右边的主要元素分别再各自递归的调用函数求解。\n\n**Merge** 如果左边与右边的主要元素相等，那么就直接返回这个主要元素。如果不等那就统计这两个主要元素在A中的出现次数，然后返回较大的那个，次数相等的话左右两个主要元素随便返回其中一个。\n\n#### 复杂度\n\n根据上面的思路可以写出递推式：首先是考虑最好的情况:就是每次都有左右两个子数组的主要元素相同，不需要判别，此时有递推公式：\n$$\n\\begin{equation}\\nonumber\n\\begin{split}\nT(n)&=2T[{\\lfloor\\frac{n}{2}\\rfloor]+Cn}\\\\\\\\\n&=2^2T[{\\lfloor\\frac{n}{2^2}\\rfloor]+C+2C}\\\\\\\\\n&=2^3T[{\\lfloor\\frac{n}{2^3}\\rfloor]+C+2C+2C}\\\\\\\\\n\\dots\\\\\\\\\n&=2^kT[{\\lfloor\\frac{n}{2^k}\\rfloor]+(2k-1)C}\\\\\\\\\n\\end{split} \n\\end{equation}\n$$\n每次分解后规模变为左右两个子树，因此下降到$\\lfloor\\frac{n}{2}\\rfloor$,而每次比较左右两个子树最大深度与更新最大路径长度所需的时间为常数C。设当第k次的时候下降到规模为1的叶子节点，因此有$\\frac{n}{2^k}=1$推出$k=\\log_2n$所以有$T(n)=n+(2\\log_2n-1)C=O(n)$,所以时间复杂度为O(n)。\n\n考虑最坏的情况：每次都需要重新遍历来确定主要元素，也就是递归树中的每一层都需要遍历数组也就是O(n)的成本。所以有递推公式\n$$\nT(n)=2T[{\\lfloor\\frac{n}{2}\\rfloor]+Cn}\n$$\n根据主定理可以得出算法的最坏时间复杂度为$O(nlogn)$\n\n空间复杂度因为可以使用左右的索引来进行划分，不需要额外的空间所以是O(1)。\n\n#### 代码\n\n```c++\n#include<iostream>\n#include<vector>\n#include<map>\n#include <stdio.h>\n\nusing namespace std;\nclass Solution {\nprivate:\n    int dc_majority(std::vector<int>&vec, int lo, int hi){\n        if(lo>=hi) return vec[lo];\n        int mid = lo + (hi-lo)/2;\n        int l_ans = dc_majority(vec, lo, mid);\n        int r_ans = dc_majority(vec, mid+1, hi);\n        if(l_ans==r_ans) return l_ans;\n        int l_ans_nums=0, r_ans_nums = 0;\n        for(int i=lo; i<=hi; i++){\n            if(vec[i]==l_ans) l_ans_nums++;\n            if(vec[i]==r_ans) r_ans_nums++;\n        }\n        return l_ans_nums>r_ans_nums ? l_ans : r_ans;\n    }\npublic:\n    int majorityElement(vector<int>& nums) {\n        int major=dc_majority(nums, 0, nums.size()-1);\n        return major;\n    }\n};\n\nint main(int argc, char const *argv[])\n{\n    // Solution sol;\n    // std::vector<int> vec={3,2,3};\n    // int ans = sol.majorityElement(vec);\n    // cout<<ans<<endl;\n    // cin>>ans;\n    ios::sync_with_stdio(false);\n    int len;\n    Solution Sol;\n    int ans;\n    while(cin>>len){\n        vector<int> vec(len);\n        for(int i = 0; i < len; i++) {\n            cin>>vec[i];\n        }\n        ans = Sol.majorityElement(vec);\n        cout<<ans<<endl;\n    }\n    return 0;\n}\t\n```\n\n### 摩尔投票\n\n每次从数组中删除一对不同的元素，按照题意到最后一定会剩下至少一个元素（假设每次不同的元素都是由一个主要元素和非主要元素组成的，这样的话最终仍然剩下主要元素，假设每次不同的元素都是非主要元素构成，最后肯定也会剩下多余的主要元素。也可以理解成捉对厮杀，因为主要元素的占比超过一半，其他非主要元素小于一半，所以最后一相减一定有主要元素剩下。）\n\n#### 代码\n\n直接用的花花大神的：\n\n```c++\nclass Solution {\npublic:\n    int majorityElement(vector<int>& nums) {\n        int majority = nums.front();\n        int count = 0;\n        \n        for (const int num : nums) {\n            if (num == majority) ++count;\n            else if (--count == 0) {\n                count = 1;\n                majority = num;\n            }\n        }\n        \n        return majority;\n    }\n};\n```\n\n#### 复杂度\n\n根据代码分析很容易得出时间复杂度为O(n), 空间复杂度为O(1)。\n\n\n\n## OJ的输入\n\n这道题最开始是在UOJ上面的课程作业，我最开始做的时候不管怎么调，用什么方法，包括摩尔投票都会爆内存超过限制，后面分析出来的原因是：\n\n```c++\nint main(){\n\tSolution Sol;\n\tvector<int> vec;\n\tint n ;\n\twhile(cin>>n){\n\t\t//int tmp = n;\n\t\tint element;\n\t\twhile(n--){\n\t\t\tcin>>element;\n\t\t\tvec.push_back(element);\n\t\t}\n\t\tcout<<Sol.majorityElement(vec)<<endl;\n\t}\n\t\n}\n```\n\n我的输入是用push_back()来输入进vector中的，而vector的内存是动态申请的，不足的话会申请原来的两倍，所以造成了内存超过限制的原因，比如只需要11m的，假设上一次的vector申请到的是10m，所以下次就申请了20m造成了内存超过限制。\n\n## 参考\n\n<http://zxi.mytechroad.com/blog/divide-and-conquer/leetcode-169-majority-element/> ","slug":"2019-10-14-数组中的主要元素","published":1,"updated":"2019-11-13T16:46:17.188Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2yelxho001em8tz0360d14m","content":"<h1 id=\"数组中的主要元素\"><a href=\"#数组中的主要元素\" class=\"headerlink\" title=\"数组中的主要元素\"></a>数组中的主要元素</h1><p>leetcode#169题，找出一个数组中出现次数超过$\\lfloor \\dfrac{n}{2}\\rfloor$ 次数的元素，也就是过半的主要元素。题目来源：</p>\n<p><a href=\"https://leetcode.com/problems/majority-element/\" target=\"_blank\" rel=\"noopener\">https://leetcode.com/problems/majority-element/</a> </p>\n<a id=\"more\"></a>\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><h3 id=\"哈希表\"><a href=\"#哈希表\" class=\"headerlink\" title=\"哈希表\"></a>哈希表</h3><p>遍历一次数组然后将每个元素出现的次数放在哈希表中，key是元素，value是出现的次数。然后输出哈希表中值大于$\\lfloor \\dfrac{n}{2}\\rfloor$ 的元素。</p>\n<h4 id=\"复杂度\"><a href=\"#复杂度\" class=\"headerlink\" title=\"复杂度\"></a>复杂度</h4><p>遍历数组的时间复杂度为O(n)，新建一个哈希表造成的空间复杂度为O(n)。</p>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><p>第一个是自己写的,输入是为了自己调试和算法课程作业的UOJ，这个OJ有个卡内存的坑后面讲。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;map&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">majorityElement</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">map</span>&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; m;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;nums.size(); i++)&#123;</span><br><span class=\"line\">            m[nums[i]]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> major = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> max = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"built_in\">map</span>&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt;::iterator it= m.begin(); it!=m.end(); it++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(it-&gt;second&gt;=max)&#123;</span><br><span class=\"line\">                max = it-&gt;second;</span><br><span class=\"line\">                major = it-&gt;first;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> major;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Solution sol;</span></span><br><span class=\"line\">    <span class=\"comment\">// std::vector&lt;int&gt; vec=&#123;3,2,3&#125;;</span></span><br><span class=\"line\">    <span class=\"comment\">// int ans = sol.majorityElement(vec);</span></span><br><span class=\"line\">    <span class=\"comment\">// cout&lt;&lt;ans&lt;&lt;endl;</span></span><br><span class=\"line\">    <span class=\"comment\">// cin&gt;&gt;ans;</span></span><br><span class=\"line\">    ios::sync_with_stdio(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len;</span><br><span class=\"line\">    Solution Sol;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ans;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span>&gt;&gt;len)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; vec(len);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">cin</span>&gt;&gt;vec[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ans = Sol.majorityElement(vec);</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;ans&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后再来看看花花大神写的：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Author: Huahua</span></span><br><span class=\"line\"><span class=\"comment\">// Runtime : 23 ms</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">majorityElement</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">unordered_map</span>&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; count;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> n = nums.size();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> num : nums)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (++count[num] &gt; n / <span class=\"number\">2</span>) <span class=\"keyword\">return</span> num;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>我自己写的代码多了一步冗余操作，就是完整的把count哈希表给建立完毕之后又多次一举的进行遍历寻找最大值。实际上在对原来的数组进行遍历的同时一定会出现主要元素的计数大于$\\lfloor \\dfrac{n}{2}\\rfloor$，这个时候直接返回就可以了。</p>\n<h3 id=\"分治\"><a href=\"#分治\" class=\"headerlink\" title=\"分治\"></a>分治</h3><p>首先考虑最简单的情况，当n=1的时候，这个唯一的元素就是主要元素，这是一个最简单的子问题。那么是否所有自问都能正确返回主要元素呢？很明显当n=2的时候，如果A[0]!=A[1]，这个时候A是没有主要元素的。因为如果使用分治的话，子问题一定要有一个解得，所以当出现两个子问题的主要元素不一致的时候，如何来得到原问题的解呢？这时只能通过遍历，统计两个子问题对应的主要元素在更大的局部中出现的次数来解决。如果左边的主要元素在原问题的数组中出现的次数大于右边的主要元素那么答案就是左边的主要元素，否则的话就是右边的元素（需要注意的是返回右边的时候是包含右边的主要元素次数等于左边的情况，不过无所谓，因为后面的上一层还是要遍历统计的）。总结一下：</p>\n<p><strong>Divide</strong> 将输入数组A划分为左边A[0, n/2] 与右边A[n/2+1, n-1]两个数组</p>\n<p><strong>Conquer</strong> 左边的主要元素与右边的主要元素分别再各自递归的调用函数求解。</p>\n<p><strong>Merge</strong> 如果左边与右边的主要元素相等，那么就直接返回这个主要元素。如果不等那就统计这两个主要元素在A中的出现次数，然后返回较大的那个，次数相等的话左右两个主要元素随便返回其中一个。</p>\n<h4 id=\"复杂度-1\"><a href=\"#复杂度-1\" class=\"headerlink\" title=\"复杂度\"></a>复杂度</h4><p>根据上面的思路可以写出递推式：首先是考虑最好的情况:就是每次都有左右两个子数组的主要元素相同，不需要判别，此时有递推公式：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\\nonumber\n\\begin{split}\nT(n)&=2T[{\\lfloor\\frac{n}{2}\\rfloor]+Cn}\\\\\\\\\n&=2^2T[{\\lfloor\\frac{n}{2^2}\\rfloor]+C+2C}\\\\\\\\\n&=2^3T[{\\lfloor\\frac{n}{2^3}\\rfloor]+C+2C+2C}\\\\\\\\\n\\dots\\\\\\\\\n&=2^kT[{\\lfloor\\frac{n}{2^k}\\rfloor]+(2k-1)C}\\\\\\\\\n\\end{split} \n\\end{equation}</script><p>每次分解后规模变为左右两个子树，因此下降到$\\lfloor\\frac{n}{2}\\rfloor$,而每次比较左右两个子树最大深度与更新最大路径长度所需的时间为常数C。设当第k次的时候下降到规模为1的叶子节点，因此有$\\frac{n}{2^k}=1$推出$k=\\log_2n$所以有$T(n)=n+(2\\log_2n-1)C=O(n)$,所以时间复杂度为O(n)。</p>\n<p>考虑最坏的情况：每次都需要重新遍历来确定主要元素，也就是递归树中的每一层都需要遍历数组也就是O(n)的成本。所以有递推公式</p>\n<script type=\"math/tex; mode=display\">\nT(n)=2T[{\\lfloor\\frac{n}{2}\\rfloor]+Cn}</script><p>根据主定理可以得出算法的最坏时间复杂度为$O(nlogn)$</p>\n<p>空间复杂度因为可以使用左右的索引来进行划分，不需要额外的空间所以是O(1)。</p>\n<h4 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;map&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dc_majority</span><span class=\"params\">(<span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp;vec, <span class=\"keyword\">int</span> lo, <span class=\"keyword\">int</span> hi)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(lo&gt;=hi) <span class=\"keyword\">return</span> vec[lo];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = lo + (hi-lo)/<span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> l_ans = dc_majority(vec, lo, mid);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> r_ans = dc_majority(vec, mid+<span class=\"number\">1</span>, hi);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(l_ans==r_ans) <span class=\"keyword\">return</span> l_ans;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> l_ans_nums=<span class=\"number\">0</span>, r_ans_nums = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=lo; i&lt;=hi; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(vec[i]==l_ans) l_ans_nums++;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(vec[i]==r_ans) r_ans_nums++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> l_ans_nums&gt;r_ans_nums ? l_ans : r_ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">majorityElement</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> major=dc_majority(nums, <span class=\"number\">0</span>, nums.size()<span class=\"number\">-1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> major;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Solution sol;</span></span><br><span class=\"line\">    <span class=\"comment\">// std::vector&lt;int&gt; vec=&#123;3,2,3&#125;;</span></span><br><span class=\"line\">    <span class=\"comment\">// int ans = sol.majorityElement(vec);</span></span><br><span class=\"line\">    <span class=\"comment\">// cout&lt;&lt;ans&lt;&lt;endl;</span></span><br><span class=\"line\">    <span class=\"comment\">// cin&gt;&gt;ans;</span></span><br><span class=\"line\">    ios::sync_with_stdio(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len;</span><br><span class=\"line\">    Solution Sol;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ans;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span>&gt;&gt;len)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; vec(len);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">cin</span>&gt;&gt;vec[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ans = Sol.majorityElement(vec);</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;ans&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"摩尔投票\"><a href=\"#摩尔投票\" class=\"headerlink\" title=\"摩尔投票\"></a>摩尔投票</h3><p>每次从数组中删除一对不同的元素，按照题意到最后一定会剩下至少一个元素（假设每次不同的元素都是由一个主要元素和非主要元素组成的，这样的话最终仍然剩下主要元素，假设每次不同的元素都是非主要元素构成，最后肯定也会剩下多余的主要元素。也可以理解成捉对厮杀，因为主要元素的占比超过一半，其他非主要元素小于一半，所以最后一相减一定有主要元素剩下。）</p>\n<h4 id=\"代码-2\"><a href=\"#代码-2\" class=\"headerlink\" title=\"代码\"></a>代码</h4><p>直接用的花花大神的：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">majorityElement</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> majority = nums.front();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> num : nums) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (num == majority) ++count;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (--count == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                count = <span class=\"number\">1</span>;</span><br><span class=\"line\">                majority = num;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> majority;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"复杂度-2\"><a href=\"#复杂度-2\" class=\"headerlink\" title=\"复杂度\"></a>复杂度</h4><p>根据代码分析很容易得出时间复杂度为O(n), 空间复杂度为O(1)。</p>\n<h2 id=\"OJ的输入\"><a href=\"#OJ的输入\" class=\"headerlink\" title=\"OJ的输入\"></a>OJ的输入</h2><p>这道题最开始是在UOJ上面的课程作业，我最开始做的时候不管怎么调，用什么方法，包括摩尔投票都会爆内存超过限制，后面分析出来的原因是：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tSolution Sol;</span><br><span class=\"line\">\t<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; vec;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> n ;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span>&gt;&gt;n)&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//int tmp = n;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> element;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(n--)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">cin</span>&gt;&gt;element;</span><br><span class=\"line\">\t\t\tvec.push_back(element);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span>&lt;&lt;Sol.majorityElement(vec)&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我的输入是用push_back()来输入进vector中的，而vector的内存是动态申请的，不足的话会申请原来的两倍，所以造成了内存超过限制的原因，比如只需要11m的，假设上一次的vector申请到的是10m，所以下次就申请了20m造成了内存超过限制。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://zxi.mytechroad.com/blog/divide-and-conquer/leetcode-169-majority-element/\" target=\"_blank\" rel=\"noopener\">http://zxi.mytechroad.com/blog/divide-and-conquer/leetcode-169-majority-element/</a> </p>\n","site":{"data":{}},"length":4999,"excerpt":"<h1 id=\"数组中的主要元素\"><a href=\"#数组中的主要元素\" class=\"headerlink\" title=\"数组中的主要元素\"></a>数组中的主要元素</h1><p>leetcode#169题，找出一个数组中出现次数超过$\\lfloor \\dfrac{n}{2}\\rfloor$ 次数的元素，也就是过半的主要元素。题目来源：</p>\n<p><a href=\"https://leetcode.com/problems/majority-element/\" target=\"_blank\" rel=\"noopener\">https://leetcode.com/problems/majority-element/</a> </p>","more":"<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><h3 id=\"哈希表\"><a href=\"#哈希表\" class=\"headerlink\" title=\"哈希表\"></a>哈希表</h3><p>遍历一次数组然后将每个元素出现的次数放在哈希表中，key是元素，value是出现的次数。然后输出哈希表中值大于$\\lfloor \\dfrac{n}{2}\\rfloor$ 的元素。</p>\n<h4 id=\"复杂度\"><a href=\"#复杂度\" class=\"headerlink\" title=\"复杂度\"></a>复杂度</h4><p>遍历数组的时间复杂度为O(n)，新建一个哈希表造成的空间复杂度为O(n)。</p>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><p>第一个是自己写的,输入是为了自己调试和算法课程作业的UOJ，这个OJ有个卡内存的坑后面讲。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;map&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">majorityElement</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">map</span>&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; m;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;nums.size(); i++)&#123;</span><br><span class=\"line\">            m[nums[i]]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> major = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> max = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"built_in\">map</span>&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt;::iterator it= m.begin(); it!=m.end(); it++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(it-&gt;second&gt;=max)&#123;</span><br><span class=\"line\">                max = it-&gt;second;</span><br><span class=\"line\">                major = it-&gt;first;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> major;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Solution sol;</span></span><br><span class=\"line\">    <span class=\"comment\">// std::vector&lt;int&gt; vec=&#123;3,2,3&#125;;</span></span><br><span class=\"line\">    <span class=\"comment\">// int ans = sol.majorityElement(vec);</span></span><br><span class=\"line\">    <span class=\"comment\">// cout&lt;&lt;ans&lt;&lt;endl;</span></span><br><span class=\"line\">    <span class=\"comment\">// cin&gt;&gt;ans;</span></span><br><span class=\"line\">    ios::sync_with_stdio(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len;</span><br><span class=\"line\">    Solution Sol;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ans;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span>&gt;&gt;len)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; vec(len);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">cin</span>&gt;&gt;vec[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ans = Sol.majorityElement(vec);</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;ans&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后再来看看花花大神写的：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Author: Huahua</span></span><br><span class=\"line\"><span class=\"comment\">// Runtime : 23 ms</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">majorityElement</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">unordered_map</span>&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; count;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> n = nums.size();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> num : nums)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (++count[num] &gt; n / <span class=\"number\">2</span>) <span class=\"keyword\">return</span> num;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>我自己写的代码多了一步冗余操作，就是完整的把count哈希表给建立完毕之后又多次一举的进行遍历寻找最大值。实际上在对原来的数组进行遍历的同时一定会出现主要元素的计数大于$\\lfloor \\dfrac{n}{2}\\rfloor$，这个时候直接返回就可以了。</p>\n<h3 id=\"分治\"><a href=\"#分治\" class=\"headerlink\" title=\"分治\"></a>分治</h3><p>首先考虑最简单的情况，当n=1的时候，这个唯一的元素就是主要元素，这是一个最简单的子问题。那么是否所有自问都能正确返回主要元素呢？很明显当n=2的时候，如果A[0]!=A[1]，这个时候A是没有主要元素的。因为如果使用分治的话，子问题一定要有一个解得，所以当出现两个子问题的主要元素不一致的时候，如何来得到原问题的解呢？这时只能通过遍历，统计两个子问题对应的主要元素在更大的局部中出现的次数来解决。如果左边的主要元素在原问题的数组中出现的次数大于右边的主要元素那么答案就是左边的主要元素，否则的话就是右边的元素（需要注意的是返回右边的时候是包含右边的主要元素次数等于左边的情况，不过无所谓，因为后面的上一层还是要遍历统计的）。总结一下：</p>\n<p><strong>Divide</strong> 将输入数组A划分为左边A[0, n/2] 与右边A[n/2+1, n-1]两个数组</p>\n<p><strong>Conquer</strong> 左边的主要元素与右边的主要元素分别再各自递归的调用函数求解。</p>\n<p><strong>Merge</strong> 如果左边与右边的主要元素相等，那么就直接返回这个主要元素。如果不等那就统计这两个主要元素在A中的出现次数，然后返回较大的那个，次数相等的话左右两个主要元素随便返回其中一个。</p>\n<h4 id=\"复杂度-1\"><a href=\"#复杂度-1\" class=\"headerlink\" title=\"复杂度\"></a>复杂度</h4><p>根据上面的思路可以写出递推式：首先是考虑最好的情况:就是每次都有左右两个子数组的主要元素相同，不需要判别，此时有递推公式：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\\nonumber\n\\begin{split}\nT(n)&=2T[{\\lfloor\\frac{n}{2}\\rfloor]+Cn}\\\\\\\\\n&=2^2T[{\\lfloor\\frac{n}{2^2}\\rfloor]+C+2C}\\\\\\\\\n&=2^3T[{\\lfloor\\frac{n}{2^3}\\rfloor]+C+2C+2C}\\\\\\\\\n\\dots\\\\\\\\\n&=2^kT[{\\lfloor\\frac{n}{2^k}\\rfloor]+(2k-1)C}\\\\\\\\\n\\end{split} \n\\end{equation}</script><p>每次分解后规模变为左右两个子树，因此下降到$\\lfloor\\frac{n}{2}\\rfloor$,而每次比较左右两个子树最大深度与更新最大路径长度所需的时间为常数C。设当第k次的时候下降到规模为1的叶子节点，因此有$\\frac{n}{2^k}=1$推出$k=\\log_2n$所以有$T(n)=n+(2\\log_2n-1)C=O(n)$,所以时间复杂度为O(n)。</p>\n<p>考虑最坏的情况：每次都需要重新遍历来确定主要元素，也就是递归树中的每一层都需要遍历数组也就是O(n)的成本。所以有递推公式</p>\n<script type=\"math/tex; mode=display\">\nT(n)=2T[{\\lfloor\\frac{n}{2}\\rfloor]+Cn}</script><p>根据主定理可以得出算法的最坏时间复杂度为$O(nlogn)$</p>\n<p>空间复杂度因为可以使用左右的索引来进行划分，不需要额外的空间所以是O(1)。</p>\n<h4 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;map&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dc_majority</span><span class=\"params\">(<span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp;vec, <span class=\"keyword\">int</span> lo, <span class=\"keyword\">int</span> hi)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(lo&gt;=hi) <span class=\"keyword\">return</span> vec[lo];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = lo + (hi-lo)/<span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> l_ans = dc_majority(vec, lo, mid);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> r_ans = dc_majority(vec, mid+<span class=\"number\">1</span>, hi);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(l_ans==r_ans) <span class=\"keyword\">return</span> l_ans;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> l_ans_nums=<span class=\"number\">0</span>, r_ans_nums = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=lo; i&lt;=hi; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(vec[i]==l_ans) l_ans_nums++;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(vec[i]==r_ans) r_ans_nums++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> l_ans_nums&gt;r_ans_nums ? l_ans : r_ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">majorityElement</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> major=dc_majority(nums, <span class=\"number\">0</span>, nums.size()<span class=\"number\">-1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> major;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Solution sol;</span></span><br><span class=\"line\">    <span class=\"comment\">// std::vector&lt;int&gt; vec=&#123;3,2,3&#125;;</span></span><br><span class=\"line\">    <span class=\"comment\">// int ans = sol.majorityElement(vec);</span></span><br><span class=\"line\">    <span class=\"comment\">// cout&lt;&lt;ans&lt;&lt;endl;</span></span><br><span class=\"line\">    <span class=\"comment\">// cin&gt;&gt;ans;</span></span><br><span class=\"line\">    ios::sync_with_stdio(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len;</span><br><span class=\"line\">    Solution Sol;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ans;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span>&gt;&gt;len)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; vec(len);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">cin</span>&gt;&gt;vec[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ans = Sol.majorityElement(vec);</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;ans&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"摩尔投票\"><a href=\"#摩尔投票\" class=\"headerlink\" title=\"摩尔投票\"></a>摩尔投票</h3><p>每次从数组中删除一对不同的元素，按照题意到最后一定会剩下至少一个元素（假设每次不同的元素都是由一个主要元素和非主要元素组成的，这样的话最终仍然剩下主要元素，假设每次不同的元素都是非主要元素构成，最后肯定也会剩下多余的主要元素。也可以理解成捉对厮杀，因为主要元素的占比超过一半，其他非主要元素小于一半，所以最后一相减一定有主要元素剩下。）</p>\n<h4 id=\"代码-2\"><a href=\"#代码-2\" class=\"headerlink\" title=\"代码\"></a>代码</h4><p>直接用的花花大神的：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">majorityElement</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> majority = nums.front();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> num : nums) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (num == majority) ++count;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (--count == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                count = <span class=\"number\">1</span>;</span><br><span class=\"line\">                majority = num;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> majority;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"复杂度-2\"><a href=\"#复杂度-2\" class=\"headerlink\" title=\"复杂度\"></a>复杂度</h4><p>根据代码分析很容易得出时间复杂度为O(n), 空间复杂度为O(1)。</p>\n<h2 id=\"OJ的输入\"><a href=\"#OJ的输入\" class=\"headerlink\" title=\"OJ的输入\"></a>OJ的输入</h2><p>这道题最开始是在UOJ上面的课程作业，我最开始做的时候不管怎么调，用什么方法，包括摩尔投票都会爆内存超过限制，后面分析出来的原因是：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tSolution Sol;</span><br><span class=\"line\">\t<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; vec;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> n ;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span>&gt;&gt;n)&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//int tmp = n;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> element;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(n--)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">cin</span>&gt;&gt;element;</span><br><span class=\"line\">\t\t\tvec.push_back(element);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span>&lt;&lt;Sol.majorityElement(vec)&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我的输入是用push_back()来输入进vector中的，而vector的内存是动态申请的，不足的话会申请原来的两倍，所以造成了内存超过限制的原因，比如只需要11m的，假设上一次的vector申请到的是10m，所以下次就申请了20m造成了内存超过限制。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://zxi.mytechroad.com/blog/divide-and-conquer/leetcode-169-majority-element/\" target=\"_blank\" rel=\"noopener\">http://zxi.mytechroad.com/blog/divide-and-conquer/leetcode-169-majority-element/</a> </p>"},{"title":"Linux命令学习之wc","date":"2018-07-09T13:12:11.000Z","copyright":true,"_content":"\n# Linux 命令学习wc命令\n\n## `wc`命令 \n\n<!--more-->\n\n1. 作用：Word Count 功能为统计指定文件中的字节数、字数、行数，并将统计结果显示输出。 \n2. 格式：\n   - `wc [option] filepath`\n3. 参数\n   - `-c` 统计字节数\n   - `-l` 统计行数\n   - `-m` 统计字符数 标志不能与 -c 标志一起使用。 \n   - `-w` 统计字（单词word）数。一个字被定义为由空白、跳格或换行字符分隔的字符串 \n   - `-L`  打印最长行的长度。 \n   - `-help` 显示帮助信息 \n   - `--version` 显示版本信息 \n4. 参考网址：http://www.cnblogs.com/peida/archive/2012/12/18/2822758.html\n\n","source":"_posts/Linux 命令 学习.md","raw":"---\ntitle: Linux命令学习之wc\ndate: 2018-07-9 21:12:11\ncategories: Linux\ntags: \n- Linux\n- command\ncopyright: true\n---\n\n# Linux 命令学习wc命令\n\n## `wc`命令 \n\n<!--more-->\n\n1. 作用：Word Count 功能为统计指定文件中的字节数、字数、行数，并将统计结果显示输出。 \n2. 格式：\n   - `wc [option] filepath`\n3. 参数\n   - `-c` 统计字节数\n   - `-l` 统计行数\n   - `-m` 统计字符数 标志不能与 -c 标志一起使用。 \n   - `-w` 统计字（单词word）数。一个字被定义为由空白、跳格或换行字符分隔的字符串 \n   - `-L`  打印最长行的长度。 \n   - `-help` 显示帮助信息 \n   - `--version` 显示版本信息 \n4. 参考网址：http://www.cnblogs.com/peida/archive/2012/12/18/2822758.html\n\n","slug":"Linux 命令 学习","published":1,"updated":"2019-11-08T13:16:33.020Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2yelxhq001hm8tzf8c5porz","content":"<h1 id=\"Linux-命令学习wc命令\"><a href=\"#Linux-命令学习wc命令\" class=\"headerlink\" title=\"Linux 命令学习wc命令\"></a>Linux 命令学习wc命令</h1><h2 id=\"wc命令\"><a href=\"#wc命令\" class=\"headerlink\" title=\"wc命令\"></a><code>wc</code>命令</h2><a id=\"more\"></a>\n<ol>\n<li>作用：Word Count 功能为统计指定文件中的字节数、字数、行数，并将统计结果显示输出。 </li>\n<li>格式：<ul>\n<li><code>wc [option] filepath</code></li>\n</ul>\n</li>\n<li>参数<ul>\n<li><code>-c</code> 统计字节数</li>\n<li><code>-l</code> 统计行数</li>\n<li><code>-m</code> 统计字符数 标志不能与 -c 标志一起使用。 </li>\n<li><code>-w</code> 统计字（单词word）数。一个字被定义为由空白、跳格或换行字符分隔的字符串 </li>\n<li><code>-L</code>  打印最长行的长度。 </li>\n<li><code>-help</code> 显示帮助信息 </li>\n<li><code>--version</code> 显示版本信息 </li>\n</ul>\n</li>\n<li>参考网址：<a href=\"http://www.cnblogs.com/peida/archive/2012/12/18/2822758.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/peida/archive/2012/12/18/2822758.html</a></li>\n</ol>\n","site":{"data":{}},"length":259,"excerpt":"<h1 id=\"Linux-命令学习wc命令\"><a href=\"#Linux-命令学习wc命令\" class=\"headerlink\" title=\"Linux 命令学习wc命令\"></a>Linux 命令学习wc命令</h1><h2 id=\"wc命令\"><a href=\"#wc命令\" class=\"headerlink\" title=\"wc命令\"></a><code>wc</code>命令</h2>","more":"<ol>\n<li>作用：Word Count 功能为统计指定文件中的字节数、字数、行数，并将统计结果显示输出。 </li>\n<li>格式：<ul>\n<li><code>wc [option] filepath</code></li>\n</ul>\n</li>\n<li>参数<ul>\n<li><code>-c</code> 统计字节数</li>\n<li><code>-l</code> 统计行数</li>\n<li><code>-m</code> 统计字符数 标志不能与 -c 标志一起使用。 </li>\n<li><code>-w</code> 统计字（单词word）数。一个字被定义为由空白、跳格或换行字符分隔的字符串 </li>\n<li><code>-L</code>  打印最长行的长度。 </li>\n<li><code>-help</code> 显示帮助信息 </li>\n<li><code>--version</code> 显示版本信息 </li>\n</ul>\n</li>\n<li>参考网址：<a href=\"http://www.cnblogs.com/peida/archive/2012/12/18/2822758.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/peida/archive/2012/12/18/2822758.html</a></li>\n</ol>"},{"title":"Clementine教程","date":"2019-11-07T02:42:24.000Z","copyright":true,"_content":"\n# Clementine教程\n\n数据挖掘课程要求使用这个软件Clementine来进行实验，之前完全没听说过这个软件。网上搜到的资料也比较少，特别是CSDN上面有个博客名字叫做Clementine完整教程，然后内容也是Clementine教程这几个字，把我给惊呆了，这也能写博客？现在实验都已经做完了因此记录下使用方法，希望对其他人能有帮助。\n\n<!--more-->\n\n## 简介\n\n### 页面\n\n在Clementine软件中只需要简单的像画图一样，把整个数据挖掘的操作流程对应的节点给连接起来就可以使用了。先对页面简单的介绍下，页面如下。\n\n![](https://res.cloudinary.com/bravey/image/upload/v1573095648/blog/clementine.jpg)\n\n在最下面的一栏是相对应的各个节点：Favorites中是常用的节点，Sources中是输入的数据节点，Field中是数据的属性设置节点，Modeling中是一些数据挖掘模型节点比如决策树神经网络等模型，Output中是输出节点用来查看数据。\n\n在右上角中的Streams显示整个工作台中的所有Stream，Outputs中是每次运行后得到输出结果，Models中是流程所用到的模型。\n\n数据挖掘的过程可以简单的分为两步：第一步对模型进行训练 第二步对训练好的模型进行使用。而一个完整的数据挖掘流程Stream中在Clementine中需要包含：数据输入节点->输入属性设置节点->模型节点->输出节点。在第一步模型训练中可以不使用输出节点。\n\n## 数据导入\n\n在下方节点栏中的Sources中选择Var.file节点，拖到中间的画布。然后双击设置输入数据的文件导入，如下所示：\n![](https://res.cloudinary.com/bravey/image/upload/v1573097265/blog/varfile1.jpg )\n\n在导入数据后选择分隔符我的数据是用tab分割的)，之后点击Apply完成设置。\n\n## 数据显示\n\n在导入了数据后可以使用输出节点来输出数据，选择Outputs中的Table节点来输出数据。如下所示：\n\n![](C:\\Users\\BraveY\\AppData\\Local\\Temp\\1573097747688.png)\n\n对输入节点训练集.txt邮件有个connect可以进行连接。或者使用快捷键F2来连接。连接好后右键execute就可以得到上图显示了。\n\n## 模型训练\n\n以使用决策树模型为例子，给定的输入数据集是一个在线测试系统中学生做的各项测试的数据，final是期末考试是否及格。也就是通过学生在测试系统的数据，来预测学生期末考试是否会及格。在选择模型前，需要在Fidel Ops中选择一个type节点来设置输入数据中各个属性。如下所示：\n\n![](https://res.cloudinary.com/bravey/image/upload/v1573098328/blog/type.jpg )\n\n第一个PersonId设置为Typeless不进行输入，决策树输出的是final，并设置为flag类型。其他数据都设置为range。\n\n接下来选择模型，在Modeling中选择C5.0这个决策树模型。并与前面的type节点连接。如下所示：\n\n![](https://res.cloudinary.com/bravey/image/upload/v1573098962/blog/train_tree.jpg)\n\n可以选择专家模式自定义剪枝率等参数。设置好后执行就可以得到训练好的模型了，将会显示在右上角的model中，这样就完成模型训练这个Stream了。\n\n在右上角的models中选择训练好的final模型，右键browse，然后选择viewer就可以查看训练好的决策树模型了。如下所示。\n\n![](https://res.cloudinary.com/bravey/image/upload/v1573099406/blog/model.jpg)\n![](https://res.cloudinary.com/bravey/image/upload/v1573099392/blog/viewer.jpg)\n\n## 模型使用\n\n同样导入数据节点验证集.txt，设置好type节点(测试集的flag属性也设置为输入了)，再把训练好的模型从右上角给拖进来，最后设置输出节点。整个流程与前述相同，得到的验证流程如下：\n![](https://res.cloudinary.com/bravey/image/upload/v1573099826/blog/test_stream.jpg)\n输出节点使用混淆矩阵来查看模型的准确性，具体设置为：\n![](https://res.cloudinary.com/bravey/image/upload/v1573099827/blog/confuse_matrix.jpg)\n最后执行就可以得到最终的显示了如下：\n![](https://res.cloudinary.com/bravey/image/upload/v1573099826/blog/matrix_out.jpg)\n\n## 总结\n\n其他模型比如神经网络等的使用流程大同小异，如果需要数据集与测试集以及英文教程可以联系我。","source":"_posts/2019-11-07-Clementine教程.md","raw":"---\ntitle: Clementine教程\ndate: 2019-11-07 10:42:24\ncategories: 数据挖掘\ntags:\n- Clementine\ncopyright: true\n---\n\n# Clementine教程\n\n数据挖掘课程要求使用这个软件Clementine来进行实验，之前完全没听说过这个软件。网上搜到的资料也比较少，特别是CSDN上面有个博客名字叫做Clementine完整教程，然后内容也是Clementine教程这几个字，把我给惊呆了，这也能写博客？现在实验都已经做完了因此记录下使用方法，希望对其他人能有帮助。\n\n<!--more-->\n\n## 简介\n\n### 页面\n\n在Clementine软件中只需要简单的像画图一样，把整个数据挖掘的操作流程对应的节点给连接起来就可以使用了。先对页面简单的介绍下，页面如下。\n\n![](https://res.cloudinary.com/bravey/image/upload/v1573095648/blog/clementine.jpg)\n\n在最下面的一栏是相对应的各个节点：Favorites中是常用的节点，Sources中是输入的数据节点，Field中是数据的属性设置节点，Modeling中是一些数据挖掘模型节点比如决策树神经网络等模型，Output中是输出节点用来查看数据。\n\n在右上角中的Streams显示整个工作台中的所有Stream，Outputs中是每次运行后得到输出结果，Models中是流程所用到的模型。\n\n数据挖掘的过程可以简单的分为两步：第一步对模型进行训练 第二步对训练好的模型进行使用。而一个完整的数据挖掘流程Stream中在Clementine中需要包含：数据输入节点->输入属性设置节点->模型节点->输出节点。在第一步模型训练中可以不使用输出节点。\n\n## 数据导入\n\n在下方节点栏中的Sources中选择Var.file节点，拖到中间的画布。然后双击设置输入数据的文件导入，如下所示：\n![](https://res.cloudinary.com/bravey/image/upload/v1573097265/blog/varfile1.jpg )\n\n在导入数据后选择分隔符我的数据是用tab分割的)，之后点击Apply完成设置。\n\n## 数据显示\n\n在导入了数据后可以使用输出节点来输出数据，选择Outputs中的Table节点来输出数据。如下所示：\n\n![](C:\\Users\\BraveY\\AppData\\Local\\Temp\\1573097747688.png)\n\n对输入节点训练集.txt邮件有个connect可以进行连接。或者使用快捷键F2来连接。连接好后右键execute就可以得到上图显示了。\n\n## 模型训练\n\n以使用决策树模型为例子，给定的输入数据集是一个在线测试系统中学生做的各项测试的数据，final是期末考试是否及格。也就是通过学生在测试系统的数据，来预测学生期末考试是否会及格。在选择模型前，需要在Fidel Ops中选择一个type节点来设置输入数据中各个属性。如下所示：\n\n![](https://res.cloudinary.com/bravey/image/upload/v1573098328/blog/type.jpg )\n\n第一个PersonId设置为Typeless不进行输入，决策树输出的是final，并设置为flag类型。其他数据都设置为range。\n\n接下来选择模型，在Modeling中选择C5.0这个决策树模型。并与前面的type节点连接。如下所示：\n\n![](https://res.cloudinary.com/bravey/image/upload/v1573098962/blog/train_tree.jpg)\n\n可以选择专家模式自定义剪枝率等参数。设置好后执行就可以得到训练好的模型了，将会显示在右上角的model中，这样就完成模型训练这个Stream了。\n\n在右上角的models中选择训练好的final模型，右键browse，然后选择viewer就可以查看训练好的决策树模型了。如下所示。\n\n![](https://res.cloudinary.com/bravey/image/upload/v1573099406/blog/model.jpg)\n![](https://res.cloudinary.com/bravey/image/upload/v1573099392/blog/viewer.jpg)\n\n## 模型使用\n\n同样导入数据节点验证集.txt，设置好type节点(测试集的flag属性也设置为输入了)，再把训练好的模型从右上角给拖进来，最后设置输出节点。整个流程与前述相同，得到的验证流程如下：\n![](https://res.cloudinary.com/bravey/image/upload/v1573099826/blog/test_stream.jpg)\n输出节点使用混淆矩阵来查看模型的准确性，具体设置为：\n![](https://res.cloudinary.com/bravey/image/upload/v1573099827/blog/confuse_matrix.jpg)\n最后执行就可以得到最终的显示了如下：\n![](https://res.cloudinary.com/bravey/image/upload/v1573099826/blog/matrix_out.jpg)\n\n## 总结\n\n其他模型比如神经网络等的使用流程大同小异，如果需要数据集与测试集以及英文教程可以联系我。","slug":"2019-11-07-Clementine教程","published":1,"updated":"2019-11-11T11:51:14.326Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2yelxhr001jm8tzmkpdkp2t","content":"<h1 id=\"Clementine教程\"><a href=\"#Clementine教程\" class=\"headerlink\" title=\"Clementine教程\"></a>Clementine教程</h1><p>数据挖掘课程要求使用这个软件Clementine来进行实验，之前完全没听说过这个软件。网上搜到的资料也比较少，特别是CSDN上面有个博客名字叫做Clementine完整教程，然后内容也是Clementine教程这几个字，把我给惊呆了，这也能写博客？现在实验都已经做完了因此记录下使用方法，希望对其他人能有帮助。</p>\n<a id=\"more\"></a>\n<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><h3 id=\"页面\"><a href=\"#页面\" class=\"headerlink\" title=\"页面\"></a>页面</h3><p>在Clementine软件中只需要简单的像画图一样，把整个数据挖掘的操作流程对应的节点给连接起来就可以使用了。先对页面简单的介绍下，页面如下。</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1573095648/blog/clementine.jpg\" alt=\"\"></p>\n<p>在最下面的一栏是相对应的各个节点：Favorites中是常用的节点，Sources中是输入的数据节点，Field中是数据的属性设置节点，Modeling中是一些数据挖掘模型节点比如决策树神经网络等模型，Output中是输出节点用来查看数据。</p>\n<p>在右上角中的Streams显示整个工作台中的所有Stream，Outputs中是每次运行后得到输出结果，Models中是流程所用到的模型。</p>\n<p>数据挖掘的过程可以简单的分为两步：第一步对模型进行训练 第二步对训练好的模型进行使用。而一个完整的数据挖掘流程Stream中在Clementine中需要包含：数据输入节点-&gt;输入属性设置节点-&gt;模型节点-&gt;输出节点。在第一步模型训练中可以不使用输出节点。</p>\n<h2 id=\"数据导入\"><a href=\"#数据导入\" class=\"headerlink\" title=\"数据导入\"></a>数据导入</h2><p>在下方节点栏中的Sources中选择Var.file节点，拖到中间的画布。然后双击设置输入数据的文件导入，如下所示：<br><img src=\"https://res.cloudinary.com/bravey/image/upload/v1573097265/blog/varfile1.jpg\" alt=\"\"></p>\n<p>在导入数据后选择分隔符我的数据是用tab分割的)，之后点击Apply完成设置。</p>\n<h2 id=\"数据显示\"><a href=\"#数据显示\" class=\"headerlink\" title=\"数据显示\"></a>数据显示</h2><p>在导入了数据后可以使用输出节点来输出数据，选择Outputs中的Table节点来输出数据。如下所示：</p>\n<p><img src=\"/2019-11-07-Clementine教程.htm/Users\\BraveY\\AppData\\Local\\Temp\\1573097747688.png\" alt=\"\"></p>\n<p>对输入节点训练集.txt邮件有个connect可以进行连接。或者使用快捷键F2来连接。连接好后右键execute就可以得到上图显示了。</p>\n<h2 id=\"模型训练\"><a href=\"#模型训练\" class=\"headerlink\" title=\"模型训练\"></a>模型训练</h2><p>以使用决策树模型为例子，给定的输入数据集是一个在线测试系统中学生做的各项测试的数据，final是期末考试是否及格。也就是通过学生在测试系统的数据，来预测学生期末考试是否会及格。在选择模型前，需要在Fidel Ops中选择一个type节点来设置输入数据中各个属性。如下所示：</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1573098328/blog/type.jpg\" alt=\"\"></p>\n<p>第一个PersonId设置为Typeless不进行输入，决策树输出的是final，并设置为flag类型。其他数据都设置为range。</p>\n<p>接下来选择模型，在Modeling中选择C5.0这个决策树模型。并与前面的type节点连接。如下所示：</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1573098962/blog/train_tree.jpg\" alt=\"\"></p>\n<p>可以选择专家模式自定义剪枝率等参数。设置好后执行就可以得到训练好的模型了，将会显示在右上角的model中，这样就完成模型训练这个Stream了。</p>\n<p>在右上角的models中选择训练好的final模型，右键browse，然后选择viewer就可以查看训练好的决策树模型了。如下所示。</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1573099406/blog/model.jpg\" alt=\"\"><br><img src=\"https://res.cloudinary.com/bravey/image/upload/v1573099392/blog/viewer.jpg\" alt=\"\"></p>\n<h2 id=\"模型使用\"><a href=\"#模型使用\" class=\"headerlink\" title=\"模型使用\"></a>模型使用</h2><p>同样导入数据节点验证集.txt，设置好type节点(测试集的flag属性也设置为输入了)，再把训练好的模型从右上角给拖进来，最后设置输出节点。整个流程与前述相同，得到的验证流程如下：<br><img src=\"https://res.cloudinary.com/bravey/image/upload/v1573099826/blog/test_stream.jpg\" alt=\"\"><br>输出节点使用混淆矩阵来查看模型的准确性，具体设置为：<br><img src=\"https://res.cloudinary.com/bravey/image/upload/v1573099827/blog/confuse_matrix.jpg\" alt=\"\"><br>最后执行就可以得到最终的显示了如下：<br><img src=\"https://res.cloudinary.com/bravey/image/upload/v1573099826/blog/matrix_out.jpg\" alt=\"\"></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>其他模型比如神经网络等的使用流程大同小异，如果需要数据集与测试集以及英文教程可以联系我。</p>\n","site":{"data":{}},"length":1367,"excerpt":"<h1 id=\"Clementine教程\"><a href=\"#Clementine教程\" class=\"headerlink\" title=\"Clementine教程\"></a>Clementine教程</h1><p>数据挖掘课程要求使用这个软件Clementine来进行实验，之前完全没听说过这个软件。网上搜到的资料也比较少，特别是CSDN上面有个博客名字叫做Clementine完整教程，然后内容也是Clementine教程这几个字，把我给惊呆了，这也能写博客？现在实验都已经做完了因此记录下使用方法，希望对其他人能有帮助。</p>","more":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><h3 id=\"页面\"><a href=\"#页面\" class=\"headerlink\" title=\"页面\"></a>页面</h3><p>在Clementine软件中只需要简单的像画图一样，把整个数据挖掘的操作流程对应的节点给连接起来就可以使用了。先对页面简单的介绍下，页面如下。</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1573095648/blog/clementine.jpg\" alt=\"\"></p>\n<p>在最下面的一栏是相对应的各个节点：Favorites中是常用的节点，Sources中是输入的数据节点，Field中是数据的属性设置节点，Modeling中是一些数据挖掘模型节点比如决策树神经网络等模型，Output中是输出节点用来查看数据。</p>\n<p>在右上角中的Streams显示整个工作台中的所有Stream，Outputs中是每次运行后得到输出结果，Models中是流程所用到的模型。</p>\n<p>数据挖掘的过程可以简单的分为两步：第一步对模型进行训练 第二步对训练好的模型进行使用。而一个完整的数据挖掘流程Stream中在Clementine中需要包含：数据输入节点-&gt;输入属性设置节点-&gt;模型节点-&gt;输出节点。在第一步模型训练中可以不使用输出节点。</p>\n<h2 id=\"数据导入\"><a href=\"#数据导入\" class=\"headerlink\" title=\"数据导入\"></a>数据导入</h2><p>在下方节点栏中的Sources中选择Var.file节点，拖到中间的画布。然后双击设置输入数据的文件导入，如下所示：<br><img src=\"https://res.cloudinary.com/bravey/image/upload/v1573097265/blog/varfile1.jpg\" alt=\"\"></p>\n<p>在导入数据后选择分隔符我的数据是用tab分割的)，之后点击Apply完成设置。</p>\n<h2 id=\"数据显示\"><a href=\"#数据显示\" class=\"headerlink\" title=\"数据显示\"></a>数据显示</h2><p>在导入了数据后可以使用输出节点来输出数据，选择Outputs中的Table节点来输出数据。如下所示：</p>\n<p><img src=\"/2019-11-07-Clementine教程.htm/Users\\BraveY\\AppData\\Local\\Temp\\1573097747688.png\" alt=\"\"></p>\n<p>对输入节点训练集.txt邮件有个connect可以进行连接。或者使用快捷键F2来连接。连接好后右键execute就可以得到上图显示了。</p>\n<h2 id=\"模型训练\"><a href=\"#模型训练\" class=\"headerlink\" title=\"模型训练\"></a>模型训练</h2><p>以使用决策树模型为例子，给定的输入数据集是一个在线测试系统中学生做的各项测试的数据，final是期末考试是否及格。也就是通过学生在测试系统的数据，来预测学生期末考试是否会及格。在选择模型前，需要在Fidel Ops中选择一个type节点来设置输入数据中各个属性。如下所示：</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1573098328/blog/type.jpg\" alt=\"\"></p>\n<p>第一个PersonId设置为Typeless不进行输入，决策树输出的是final，并设置为flag类型。其他数据都设置为range。</p>\n<p>接下来选择模型，在Modeling中选择C5.0这个决策树模型。并与前面的type节点连接。如下所示：</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1573098962/blog/train_tree.jpg\" alt=\"\"></p>\n<p>可以选择专家模式自定义剪枝率等参数。设置好后执行就可以得到训练好的模型了，将会显示在右上角的model中，这样就完成模型训练这个Stream了。</p>\n<p>在右上角的models中选择训练好的final模型，右键browse，然后选择viewer就可以查看训练好的决策树模型了。如下所示。</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1573099406/blog/model.jpg\" alt=\"\"><br><img src=\"https://res.cloudinary.com/bravey/image/upload/v1573099392/blog/viewer.jpg\" alt=\"\"></p>\n<h2 id=\"模型使用\"><a href=\"#模型使用\" class=\"headerlink\" title=\"模型使用\"></a>模型使用</h2><p>同样导入数据节点验证集.txt，设置好type节点(测试集的flag属性也设置为输入了)，再把训练好的模型从右上角给拖进来，最后设置输出节点。整个流程与前述相同，得到的验证流程如下：<br><img src=\"https://res.cloudinary.com/bravey/image/upload/v1573099826/blog/test_stream.jpg\" alt=\"\"><br>输出节点使用混淆矩阵来查看模型的准确性，具体设置为：<br><img src=\"https://res.cloudinary.com/bravey/image/upload/v1573099827/blog/confuse_matrix.jpg\" alt=\"\"><br>最后执行就可以得到最终的显示了如下：<br><img src=\"https://res.cloudinary.com/bravey/image/upload/v1573099826/blog/matrix_out.jpg\" alt=\"\"></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>其他模型比如神经网络等的使用流程大同小异，如果需要数据集与测试集以及英文教程可以联系我。</p>"},{"title":"BigdataBench deploy","date":"2018-06-23T08:55:45.000Z","copyright":true,"_content":"\n# Bigdatabench 4.0 MPI版本 安装\n\n<!--more-->\n\n官网上面的指南BigDataBench User Manual有一些错误。\n\n本机环境：\n\n​\tCentos 6.9\n\n​\tgcc (GCC) 4.8.2 20140120 (Red Hat 4.8.2-15)\n\n​\tg++ (GCC) 4.8.2 20140120 (Red Hat 4.8.2-15)\n\n## mpi的安装\n\n这部分网上资料很多，而Manual中有一点错误\n\n1. 需要保证c 编译器 如gcc c++ 编译器 如：g++\n\n2. 基础安装\n\n   1. 从官网下载安装包解压\n\n   - `wget http://www.mpich.org/static/downloads/3.2.1/mpich-3.2.1.tar.gz `  从官网下载安装包\n   - `tar -zxvf mpich-3.2.1.tar.gz `  解压\n   - `cd mpich-3.2.1`\n\n   1. 配置安装目录   本机安装在mpich-install目录下\n\n   - `./configure –prefix=/home/mpich-install 2>&1 | tee c.txt    ` 手册中&被错写为$了 `2>&1 | tee c.txt` 表示将输出的标准出错信息重定向到c.txt中。\n\n   1. build\n\n   - `make 2>&1 | tee m.txt `\n\n   1. 安装\n\n   - `make install 2>&1 | tee mi.txt `\n\n   1. 将安装目录添加到PATH 环境变量中\n\n   - `vim ~/.bashrc`\n   - `export PATH=$PATH:/home/mpich-install/bin` 在最后一行添加\n   - `source ~/.bashrc` 重启生效\n\n3. 检查\n\n   1. 检查路径\n      - `which mpicc` \n      - `which mpic++`\n\n4. 验证 \n\n   在mpich的安装包目录下有提供例子程序运行\n\n   1. `cd mpich-3.2.1/examples`\n   2. `mpicc cpi.c -o cpi` 编译cpi.c程序求pi值\n   3. `mpirun -n 4 ./cpi` 使用4个进程 注意`./`否则报错找不到文件\n\n   如果是集群环境在每个节点将mpich安装在相同的路径然后编辑一个machine_file （里面是各个节点的host）然后`mpirun -f machine_file -n 3 ./cpi` 在集群上并行运行\n\n## boost 安装\n\nboost当前最新版本是：1.67 但是BigdataBench用的是1.43版本推荐安装这个旧版本\n\n1. `wget https://sourceforge.net/projects/boost/files/boost/1.43.0/boost_1_43_0.tar.gz/download` \n\n2. 若下载下来的文件名为：downloads 则使用mv命令重命名在当前文件目录下:\n\n   `mv downloads boost_1_43_0.tar.gz  `  \n\n3. 解压`tar -zxvf boost_1_43_0.tar.gz`  之后`cd boost_1_43_0`\n\n4. `sh bootstrap.sh`  执行这个命令运行脚本后会多出很多配置文件\n\n5. 使用mpi,这一步骤很重要否则后续cmake时会提示找不到：boost_mpi\n\n   1. 对低版本的boost \n\n      1. `which mpic++` 找mpich的目录\n\n      2. `vim tools/build/v2/user-config.jam`\n\n      3. 在最后添加： using mpi:后面是mpich的目录\n\n         `#MPI config`\n\n         `using mpi : /usr/lib64/mpich/bin/mpic++ ;`\n\n   2. 对高版本的boost直接在boost_1_67_0目录下修改project-config.jam即可\n\n6. ` ./bjam` 进行编译\n\n7. `./bjam install` 这一步是必需的但在手册中没有表明。\n\n## BigdataBench的配置\n\n进入BigDataBench的安装根目录：\n\n1. ` vim conf.properties` 添加$JAVA_HOME， $MPI_HOME ，$BigdataBench_HOMEMPI的路径\n2. `sh prepar.sh` \n\n至此安装理论上已经成功。但仍然遇到了其他问题\n\n## Perminsion denied问题\n\n最开始的安装包是从windows下面考过去的结果生成cc的数据后无法运行执行脚本\n\n![](BigdataBench-deploy\\runcc.png)\n\n原因是此时的run_connectedComponents已经不是可执行文件了（不是绿色的）需要`chmod a+x run_connectedComponents`来将文件的权限修改为可执行文件权限（修改后变为绿色）\n\n后面wget下载后解压配置之后直接就是可执行文件！\n\n## ldd 程序 动态链接库缺失\n\n` [root@hw073 ConnectedComponent]# ldd run_connectedComponents`\n`linux-vdso.so.1 =>  (0x00007ffdfc8d4000)`\n`librt.so.1 => /lib64/librt.so.1 (0x0000003156e00000)`\n`libpthread.so.0 => /lib64/libpthread.so.0 (0x0000003156a00000)`\n\n`libboost_serialization-mt.so.1.43.0 => not found`\n`libboost_filesystem-mt.so.1.43.0 => not found`\n`libboost_system-mt.so.1.43.0 => not found`\n`libstdc++.so.6 => /usr/lib64/libstdc++.so.6 (0x0000003162200000)`\n`libm.so.6 => /lib64/libm.so.6 (0x0000003157200000)`\n`libgcc_s.so.1 => /lib64/libgcc_s.so.1 (0x0000003161a00000)`\n`libc.so.6 => /lib64/libc.so.6 (0x0000003156600000)`\n`/lib64/ld-linux-x86-64.so.2 (0x0000003155e00000)`\n\n最开始以为是没有指定LD_LIBRARY_PATH ，因为明明有这个文件的，后面使用find / -name 命令发现还是找不到，仔细一看ldd 的信息，发现上述文件都多了个-mt\n\n解决办法： 在boost安装时的库。本机：`/usr/local/lib` 有着及其相似的3个文件`libboost_filesystem.so.1.43.0` 、`libboost_filesystem.so.1.43.0` ，`libboost_system.so.1.43.0` 均少了个-mt，因此将上述三个文件均拷贝一份命名为上述缺少的动态库文件。\n\n`cd /usr/local/lib` #切换到对应的目录下\n\n`cp libboost_system.so.1.43.0 libboost_system-mt.so.1.43.0 ` #拷贝为对应的文件名","source":"_posts/BigdataBench-deploy.md","raw":"---\ntitle: BigdataBench deploy\ndate: 2018-06-23 16:55:45\ncategories: deploy\ntags: bigdatabench\ncopyright: true\n---\n\n# Bigdatabench 4.0 MPI版本 安装\n\n<!--more-->\n\n官网上面的指南BigDataBench User Manual有一些错误。\n\n本机环境：\n\n​\tCentos 6.9\n\n​\tgcc (GCC) 4.8.2 20140120 (Red Hat 4.8.2-15)\n\n​\tg++ (GCC) 4.8.2 20140120 (Red Hat 4.8.2-15)\n\n## mpi的安装\n\n这部分网上资料很多，而Manual中有一点错误\n\n1. 需要保证c 编译器 如gcc c++ 编译器 如：g++\n\n2. 基础安装\n\n   1. 从官网下载安装包解压\n\n   - `wget http://www.mpich.org/static/downloads/3.2.1/mpich-3.2.1.tar.gz `  从官网下载安装包\n   - `tar -zxvf mpich-3.2.1.tar.gz `  解压\n   - `cd mpich-3.2.1`\n\n   1. 配置安装目录   本机安装在mpich-install目录下\n\n   - `./configure –prefix=/home/mpich-install 2>&1 | tee c.txt    ` 手册中&被错写为$了 `2>&1 | tee c.txt` 表示将输出的标准出错信息重定向到c.txt中。\n\n   1. build\n\n   - `make 2>&1 | tee m.txt `\n\n   1. 安装\n\n   - `make install 2>&1 | tee mi.txt `\n\n   1. 将安装目录添加到PATH 环境变量中\n\n   - `vim ~/.bashrc`\n   - `export PATH=$PATH:/home/mpich-install/bin` 在最后一行添加\n   - `source ~/.bashrc` 重启生效\n\n3. 检查\n\n   1. 检查路径\n      - `which mpicc` \n      - `which mpic++`\n\n4. 验证 \n\n   在mpich的安装包目录下有提供例子程序运行\n\n   1. `cd mpich-3.2.1/examples`\n   2. `mpicc cpi.c -o cpi` 编译cpi.c程序求pi值\n   3. `mpirun -n 4 ./cpi` 使用4个进程 注意`./`否则报错找不到文件\n\n   如果是集群环境在每个节点将mpich安装在相同的路径然后编辑一个machine_file （里面是各个节点的host）然后`mpirun -f machine_file -n 3 ./cpi` 在集群上并行运行\n\n## boost 安装\n\nboost当前最新版本是：1.67 但是BigdataBench用的是1.43版本推荐安装这个旧版本\n\n1. `wget https://sourceforge.net/projects/boost/files/boost/1.43.0/boost_1_43_0.tar.gz/download` \n\n2. 若下载下来的文件名为：downloads 则使用mv命令重命名在当前文件目录下:\n\n   `mv downloads boost_1_43_0.tar.gz  `  \n\n3. 解压`tar -zxvf boost_1_43_0.tar.gz`  之后`cd boost_1_43_0`\n\n4. `sh bootstrap.sh`  执行这个命令运行脚本后会多出很多配置文件\n\n5. 使用mpi,这一步骤很重要否则后续cmake时会提示找不到：boost_mpi\n\n   1. 对低版本的boost \n\n      1. `which mpic++` 找mpich的目录\n\n      2. `vim tools/build/v2/user-config.jam`\n\n      3. 在最后添加： using mpi:后面是mpich的目录\n\n         `#MPI config`\n\n         `using mpi : /usr/lib64/mpich/bin/mpic++ ;`\n\n   2. 对高版本的boost直接在boost_1_67_0目录下修改project-config.jam即可\n\n6. ` ./bjam` 进行编译\n\n7. `./bjam install` 这一步是必需的但在手册中没有表明。\n\n## BigdataBench的配置\n\n进入BigDataBench的安装根目录：\n\n1. ` vim conf.properties` 添加$JAVA_HOME， $MPI_HOME ，$BigdataBench_HOMEMPI的路径\n2. `sh prepar.sh` \n\n至此安装理论上已经成功。但仍然遇到了其他问题\n\n## Perminsion denied问题\n\n最开始的安装包是从windows下面考过去的结果生成cc的数据后无法运行执行脚本\n\n![](BigdataBench-deploy\\runcc.png)\n\n原因是此时的run_connectedComponents已经不是可执行文件了（不是绿色的）需要`chmod a+x run_connectedComponents`来将文件的权限修改为可执行文件权限（修改后变为绿色）\n\n后面wget下载后解压配置之后直接就是可执行文件！\n\n## ldd 程序 动态链接库缺失\n\n` [root@hw073 ConnectedComponent]# ldd run_connectedComponents`\n`linux-vdso.so.1 =>  (0x00007ffdfc8d4000)`\n`librt.so.1 => /lib64/librt.so.1 (0x0000003156e00000)`\n`libpthread.so.0 => /lib64/libpthread.so.0 (0x0000003156a00000)`\n\n`libboost_serialization-mt.so.1.43.0 => not found`\n`libboost_filesystem-mt.so.1.43.0 => not found`\n`libboost_system-mt.so.1.43.0 => not found`\n`libstdc++.so.6 => /usr/lib64/libstdc++.so.6 (0x0000003162200000)`\n`libm.so.6 => /lib64/libm.so.6 (0x0000003157200000)`\n`libgcc_s.so.1 => /lib64/libgcc_s.so.1 (0x0000003161a00000)`\n`libc.so.6 => /lib64/libc.so.6 (0x0000003156600000)`\n`/lib64/ld-linux-x86-64.so.2 (0x0000003155e00000)`\n\n最开始以为是没有指定LD_LIBRARY_PATH ，因为明明有这个文件的，后面使用find / -name 命令发现还是找不到，仔细一看ldd 的信息，发现上述文件都多了个-mt\n\n解决办法： 在boost安装时的库。本机：`/usr/local/lib` 有着及其相似的3个文件`libboost_filesystem.so.1.43.0` 、`libboost_filesystem.so.1.43.0` ，`libboost_system.so.1.43.0` 均少了个-mt，因此将上述三个文件均拷贝一份命名为上述缺少的动态库文件。\n\n`cd /usr/local/lib` #切换到对应的目录下\n\n`cp libboost_system.so.1.43.0 libboost_system-mt.so.1.43.0 ` #拷贝为对应的文件名","slug":"BigdataBench-deploy","published":1,"updated":"2019-11-08T13:11:52.787Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2yelxht001nm8tzvg8aeqoi","content":"<h1 id=\"Bigdatabench-4-0-MPI版本-安装\"><a href=\"#Bigdatabench-4-0-MPI版本-安装\" class=\"headerlink\" title=\"Bigdatabench 4.0 MPI版本 安装\"></a>Bigdatabench 4.0 MPI版本 安装</h1><a id=\"more\"></a>\n<p>官网上面的指南BigDataBench User Manual有一些错误。</p>\n<p>本机环境：</p>\n<p>​    Centos 6.9</p>\n<p>​    gcc (GCC) 4.8.2 20140120 (Red Hat 4.8.2-15)</p>\n<p>​    g++ (GCC) 4.8.2 20140120 (Red Hat 4.8.2-15)</p>\n<h2 id=\"mpi的安装\"><a href=\"#mpi的安装\" class=\"headerlink\" title=\"mpi的安装\"></a>mpi的安装</h2><p>这部分网上资料很多，而Manual中有一点错误</p>\n<ol>\n<li><p>需要保证c 编译器 如gcc c++ 编译器 如：g++</p>\n</li>\n<li><p>基础安装</p>\n<ol>\n<li>从官网下载安装包解压</li>\n</ol>\n<ul>\n<li><code>wget http://www.mpich.org/static/downloads/3.2.1/mpich-3.2.1.tar.gz</code>  从官网下载安装包</li>\n<li><code>tar -zxvf mpich-3.2.1.tar.gz</code>  解压</li>\n<li><code>cd mpich-3.2.1</code></li>\n</ul>\n<ol>\n<li>配置安装目录   本机安装在mpich-install目录下</li>\n</ol>\n<ul>\n<li><code>./configure –prefix=/home/mpich-install 2&gt;&amp;1 | tee c.txt</code> 手册中&amp;被错写为$了 <code>2&gt;&amp;1 | tee c.txt</code> 表示将输出的标准出错信息重定向到c.txt中。</li>\n</ul>\n<ol>\n<li>build</li>\n</ol>\n<ul>\n<li><code>make 2&gt;&amp;1 | tee m.txt</code></li>\n</ul>\n<ol>\n<li>安装</li>\n</ol>\n<ul>\n<li><code>make install 2&gt;&amp;1 | tee mi.txt</code></li>\n</ul>\n<ol>\n<li>将安装目录添加到PATH 环境变量中</li>\n</ol>\n<ul>\n<li><code>vim ~/.bashrc</code></li>\n<li><code>export PATH=$PATH:/home/mpich-install/bin</code> 在最后一行添加</li>\n<li><code>source ~/.bashrc</code> 重启生效</li>\n</ul>\n</li>\n<li><p>检查</p>\n<ol>\n<li>检查路径<ul>\n<li><code>which mpicc</code> </li>\n<li><code>which mpic++</code></li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>验证 </p>\n<p>在mpich的安装包目录下有提供例子程序运行</p>\n<ol>\n<li><code>cd mpich-3.2.1/examples</code></li>\n<li><code>mpicc cpi.c -o cpi</code> 编译cpi.c程序求pi值</li>\n<li><code>mpirun -n 4 ./cpi</code> 使用4个进程 注意<code>./</code>否则报错找不到文件</li>\n</ol>\n<p>如果是集群环境在每个节点将mpich安装在相同的路径然后编辑一个machine_file （里面是各个节点的host）然后<code>mpirun -f machine_file -n 3 ./cpi</code> 在集群上并行运行</p>\n</li>\n</ol>\n<h2 id=\"boost-安装\"><a href=\"#boost-安装\" class=\"headerlink\" title=\"boost 安装\"></a>boost 安装</h2><p>boost当前最新版本是：1.67 但是BigdataBench用的是1.43版本推荐安装这个旧版本</p>\n<ol>\n<li><p><code>wget https://sourceforge.net/projects/boost/files/boost/1.43.0/boost_1_43_0.tar.gz/download</code> </p>\n</li>\n<li><p>若下载下来的文件名为：downloads 则使用mv命令重命名在当前文件目录下:</p>\n<p><code>mv downloads boost_1_43_0.tar.gz</code>  </p>\n</li>\n<li><p>解压<code>tar -zxvf boost_1_43_0.tar.gz</code>  之后<code>cd boost_1_43_0</code></p>\n</li>\n<li><p><code>sh bootstrap.sh</code>  执行这个命令运行脚本后会多出很多配置文件</p>\n</li>\n<li><p>使用mpi,这一步骤很重要否则后续cmake时会提示找不到：boost_mpi</p>\n<ol>\n<li><p>对低版本的boost </p>\n<ol>\n<li><p><code>which mpic++</code> 找mpich的目录</p>\n</li>\n<li><p><code>vim tools/build/v2/user-config.jam</code></p>\n</li>\n<li><p>在最后添加： using mpi:后面是mpich的目录</p>\n<p><code>#MPI config</code></p>\n<p><code>using mpi : /usr/lib64/mpich/bin/mpic++ ;</code></p>\n</li>\n</ol>\n</li>\n<li><p>对高版本的boost直接在boost_1_67_0目录下修改project-config.jam即可</p>\n</li>\n</ol>\n</li>\n<li><p><code>./bjam</code> 进行编译</p>\n</li>\n<li><p><code>./bjam install</code> 这一步是必需的但在手册中没有表明。</p>\n</li>\n</ol>\n<h2 id=\"BigdataBench的配置\"><a href=\"#BigdataBench的配置\" class=\"headerlink\" title=\"BigdataBench的配置\"></a>BigdataBench的配置</h2><p>进入BigDataBench的安装根目录：</p>\n<ol>\n<li><code>vim conf.properties</code> 添加$JAVA_HOME， $MPI_HOME ，$BigdataBench_HOMEMPI的路径</li>\n<li><code>sh prepar.sh</code> </li>\n</ol>\n<p>至此安装理论上已经成功。但仍然遇到了其他问题</p>\n<h2 id=\"Perminsion-denied问题\"><a href=\"#Perminsion-denied问题\" class=\"headerlink\" title=\"Perminsion denied问题\"></a>Perminsion denied问题</h2><p>最开始的安装包是从windows下面考过去的结果生成cc的数据后无法运行执行脚本</p>\n<p><img src=\"/BigdataBench-deploy.htm/runcc.png\" alt=\"\"></p>\n<p>原因是此时的run_connectedComponents已经不是可执行文件了（不是绿色的）需要<code>chmod a+x run_connectedComponents</code>来将文件的权限修改为可执行文件权限（修改后变为绿色）</p>\n<p>后面wget下载后解压配置之后直接就是可执行文件！</p>\n<h2 id=\"ldd-程序-动态链接库缺失\"><a href=\"#ldd-程序-动态链接库缺失\" class=\"headerlink\" title=\"ldd 程序 动态链接库缺失\"></a>ldd 程序 动态链接库缺失</h2><p><code>[root@hw073 ConnectedComponent]# ldd run_connectedComponents</code><br><code>linux-vdso.so.1 =&gt;  (0x00007ffdfc8d4000)</code><br><code>librt.so.1 =&gt; /lib64/librt.so.1 (0x0000003156e00000)</code><br><code>libpthread.so.0 =&gt; /lib64/libpthread.so.0 (0x0000003156a00000)</code></p>\n<p><code>libboost_serialization-mt.so.1.43.0 =&gt; not found</code><br><code>libboost_filesystem-mt.so.1.43.0 =&gt; not found</code><br><code>libboost_system-mt.so.1.43.0 =&gt; not found</code><br><code>libstdc++.so.6 =&gt; /usr/lib64/libstdc++.so.6 (0x0000003162200000)</code><br><code>libm.so.6 =&gt; /lib64/libm.so.6 (0x0000003157200000)</code><br><code>libgcc_s.so.1 =&gt; /lib64/libgcc_s.so.1 (0x0000003161a00000)</code><br><code>libc.so.6 =&gt; /lib64/libc.so.6 (0x0000003156600000)</code><br><code>/lib64/ld-linux-x86-64.so.2 (0x0000003155e00000)</code></p>\n<p>最开始以为是没有指定LD_LIBRARY_PATH ，因为明明有这个文件的，后面使用find / -name 命令发现还是找不到，仔细一看ldd 的信息，发现上述文件都多了个-mt</p>\n<p>解决办法： 在boost安装时的库。本机：<code>/usr/local/lib</code> 有着及其相似的3个文件<code>libboost_filesystem.so.1.43.0</code> 、<code>libboost_filesystem.so.1.43.0</code> ，<code>libboost_system.so.1.43.0</code> 均少了个-mt，因此将上述三个文件均拷贝一份命名为上述缺少的动态库文件。</p>\n<p><code>cd /usr/local/lib</code> #切换到对应的目录下</p>\n<p><code>cp libboost_system.so.1.43.0 libboost_system-mt.so.1.43.0</code> #拷贝为对应的文件名</p>\n","site":{"data":{}},"length":2708,"excerpt":"<h1 id=\"Bigdatabench-4-0-MPI版本-安装\"><a href=\"#Bigdatabench-4-0-MPI版本-安装\" class=\"headerlink\" title=\"Bigdatabench 4.0 MPI版本 安装\"></a>Bigdatabench 4.0 MPI版本 安装</h1>","more":"<p>官网上面的指南BigDataBench User Manual有一些错误。</p>\n<p>本机环境：</p>\n<p>​    Centos 6.9</p>\n<p>​    gcc (GCC) 4.8.2 20140120 (Red Hat 4.8.2-15)</p>\n<p>​    g++ (GCC) 4.8.2 20140120 (Red Hat 4.8.2-15)</p>\n<h2 id=\"mpi的安装\"><a href=\"#mpi的安装\" class=\"headerlink\" title=\"mpi的安装\"></a>mpi的安装</h2><p>这部分网上资料很多，而Manual中有一点错误</p>\n<ol>\n<li><p>需要保证c 编译器 如gcc c++ 编译器 如：g++</p>\n</li>\n<li><p>基础安装</p>\n<ol>\n<li>从官网下载安装包解压</li>\n</ol>\n<ul>\n<li><code>wget http://www.mpich.org/static/downloads/3.2.1/mpich-3.2.1.tar.gz</code>  从官网下载安装包</li>\n<li><code>tar -zxvf mpich-3.2.1.tar.gz</code>  解压</li>\n<li><code>cd mpich-3.2.1</code></li>\n</ul>\n<ol>\n<li>配置安装目录   本机安装在mpich-install目录下</li>\n</ol>\n<ul>\n<li><code>./configure –prefix=/home/mpich-install 2&gt;&amp;1 | tee c.txt</code> 手册中&amp;被错写为$了 <code>2&gt;&amp;1 | tee c.txt</code> 表示将输出的标准出错信息重定向到c.txt中。</li>\n</ul>\n<ol>\n<li>build</li>\n</ol>\n<ul>\n<li><code>make 2&gt;&amp;1 | tee m.txt</code></li>\n</ul>\n<ol>\n<li>安装</li>\n</ol>\n<ul>\n<li><code>make install 2&gt;&amp;1 | tee mi.txt</code></li>\n</ul>\n<ol>\n<li>将安装目录添加到PATH 环境变量中</li>\n</ol>\n<ul>\n<li><code>vim ~/.bashrc</code></li>\n<li><code>export PATH=$PATH:/home/mpich-install/bin</code> 在最后一行添加</li>\n<li><code>source ~/.bashrc</code> 重启生效</li>\n</ul>\n</li>\n<li><p>检查</p>\n<ol>\n<li>检查路径<ul>\n<li><code>which mpicc</code> </li>\n<li><code>which mpic++</code></li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>验证 </p>\n<p>在mpich的安装包目录下有提供例子程序运行</p>\n<ol>\n<li><code>cd mpich-3.2.1/examples</code></li>\n<li><code>mpicc cpi.c -o cpi</code> 编译cpi.c程序求pi值</li>\n<li><code>mpirun -n 4 ./cpi</code> 使用4个进程 注意<code>./</code>否则报错找不到文件</li>\n</ol>\n<p>如果是集群环境在每个节点将mpich安装在相同的路径然后编辑一个machine_file （里面是各个节点的host）然后<code>mpirun -f machine_file -n 3 ./cpi</code> 在集群上并行运行</p>\n</li>\n</ol>\n<h2 id=\"boost-安装\"><a href=\"#boost-安装\" class=\"headerlink\" title=\"boost 安装\"></a>boost 安装</h2><p>boost当前最新版本是：1.67 但是BigdataBench用的是1.43版本推荐安装这个旧版本</p>\n<ol>\n<li><p><code>wget https://sourceforge.net/projects/boost/files/boost/1.43.0/boost_1_43_0.tar.gz/download</code> </p>\n</li>\n<li><p>若下载下来的文件名为：downloads 则使用mv命令重命名在当前文件目录下:</p>\n<p><code>mv downloads boost_1_43_0.tar.gz</code>  </p>\n</li>\n<li><p>解压<code>tar -zxvf boost_1_43_0.tar.gz</code>  之后<code>cd boost_1_43_0</code></p>\n</li>\n<li><p><code>sh bootstrap.sh</code>  执行这个命令运行脚本后会多出很多配置文件</p>\n</li>\n<li><p>使用mpi,这一步骤很重要否则后续cmake时会提示找不到：boost_mpi</p>\n<ol>\n<li><p>对低版本的boost </p>\n<ol>\n<li><p><code>which mpic++</code> 找mpich的目录</p>\n</li>\n<li><p><code>vim tools/build/v2/user-config.jam</code></p>\n</li>\n<li><p>在最后添加： using mpi:后面是mpich的目录</p>\n<p><code>#MPI config</code></p>\n<p><code>using mpi : /usr/lib64/mpich/bin/mpic++ ;</code></p>\n</li>\n</ol>\n</li>\n<li><p>对高版本的boost直接在boost_1_67_0目录下修改project-config.jam即可</p>\n</li>\n</ol>\n</li>\n<li><p><code>./bjam</code> 进行编译</p>\n</li>\n<li><p><code>./bjam install</code> 这一步是必需的但在手册中没有表明。</p>\n</li>\n</ol>\n<h2 id=\"BigdataBench的配置\"><a href=\"#BigdataBench的配置\" class=\"headerlink\" title=\"BigdataBench的配置\"></a>BigdataBench的配置</h2><p>进入BigDataBench的安装根目录：</p>\n<ol>\n<li><code>vim conf.properties</code> 添加$JAVA_HOME， $MPI_HOME ，$BigdataBench_HOMEMPI的路径</li>\n<li><code>sh prepar.sh</code> </li>\n</ol>\n<p>至此安装理论上已经成功。但仍然遇到了其他问题</p>\n<h2 id=\"Perminsion-denied问题\"><a href=\"#Perminsion-denied问题\" class=\"headerlink\" title=\"Perminsion denied问题\"></a>Perminsion denied问题</h2><p>最开始的安装包是从windows下面考过去的结果生成cc的数据后无法运行执行脚本</p>\n<p><img src=\"/BigdataBench-deploy.htm/runcc.png\" alt=\"\"></p>\n<p>原因是此时的run_connectedComponents已经不是可执行文件了（不是绿色的）需要<code>chmod a+x run_connectedComponents</code>来将文件的权限修改为可执行文件权限（修改后变为绿色）</p>\n<p>后面wget下载后解压配置之后直接就是可执行文件！</p>\n<h2 id=\"ldd-程序-动态链接库缺失\"><a href=\"#ldd-程序-动态链接库缺失\" class=\"headerlink\" title=\"ldd 程序 动态链接库缺失\"></a>ldd 程序 动态链接库缺失</h2><p><code>[root@hw073 ConnectedComponent]# ldd run_connectedComponents</code><br><code>linux-vdso.so.1 =&gt;  (0x00007ffdfc8d4000)</code><br><code>librt.so.1 =&gt; /lib64/librt.so.1 (0x0000003156e00000)</code><br><code>libpthread.so.0 =&gt; /lib64/libpthread.so.0 (0x0000003156a00000)</code></p>\n<p><code>libboost_serialization-mt.so.1.43.0 =&gt; not found</code><br><code>libboost_filesystem-mt.so.1.43.0 =&gt; not found</code><br><code>libboost_system-mt.so.1.43.0 =&gt; not found</code><br><code>libstdc++.so.6 =&gt; /usr/lib64/libstdc++.so.6 (0x0000003162200000)</code><br><code>libm.so.6 =&gt; /lib64/libm.so.6 (0x0000003157200000)</code><br><code>libgcc_s.so.1 =&gt; /lib64/libgcc_s.so.1 (0x0000003161a00000)</code><br><code>libc.so.6 =&gt; /lib64/libc.so.6 (0x0000003156600000)</code><br><code>/lib64/ld-linux-x86-64.so.2 (0x0000003155e00000)</code></p>\n<p>最开始以为是没有指定LD_LIBRARY_PATH ，因为明明有这个文件的，后面使用find / -name 命令发现还是找不到，仔细一看ldd 的信息，发现上述文件都多了个-mt</p>\n<p>解决办法： 在boost安装时的库。本机：<code>/usr/local/lib</code> 有着及其相似的3个文件<code>libboost_filesystem.so.1.43.0</code> 、<code>libboost_filesystem.so.1.43.0</code> ，<code>libboost_system.so.1.43.0</code> 均少了个-mt，因此将上述三个文件均拷贝一份命名为上述缺少的动态库文件。</p>\n<p><code>cd /usr/local/lib</code> #切换到对应的目录下</p>\n<p><code>cp libboost_system.so.1.43.0 libboost_system-mt.so.1.43.0</code> #拷贝为对应的文件名</p>"},{"title":"apt-get install失败","date":"2019-03-10T08:23:20.000Z","copyright":true,"_content":"\n## apt-get install失败\n\n<!--more-->\n\n### 第一阶段\n\n1. 使用perf 报错 内核无法找到perf\n\n   ```\n   root@hw103:/home/yky/redis-5.0.3# perf \n   WARNING: perf not found for kernel 4.15.0-45\n   \n     You may need to install the following packages for this specific kernel:\n       linux-tools-4.15.0-45-generic\n       linux-cloud-tools-4.15.0-45-generic\n   \n     You may also want to install one of the following packages to keep up to date:\n       linux-tools-generic\n       linux-cloud-tools-generic\n   ```\n\n   \n\n2. 安装此内核的通用工具时错误\n\n   ```\n   root@hw103:/home/yky/redis-5.0.3# apt-get install  linux-tools-4.15.0-45-generic\n   Reading package lists... Done\n   Building dependency tree       \n   Reading state information... Done\n   You might want to run 'apt-get -f install' to correct these:\n   The following packages have unmet dependencies:\n    console-setup : Depends: keyboard-configuration (= 1.178ubuntu2.7) but 1.108ubuntu15.3 is to be installed\n    console-setup-linux : Depends: keyboard-configuration (= 1.178ubuntu2.7) but 1.108ubuntu15.3 is to be installed\n                          Breaks: keyboard-configuration (< 1.138) but 1.108ubuntu15.3 is to be installed\n    linux-tools-4.15.0-45-generic : Depends: linux-tools-4.15.0-45 but it is not going to be installed\n   E: Unmet dependencies. Try 'apt-get -f install' with no packages (or specify a solution).\n   ```\n\n3. 使用apt-get -f install 时报错\n\n   ```\n   update-rc.d: error: insserv rejected the script header\n   dpkg: error processing archive /var/cache/apt/archives/keyboard-configuration_1.178ubuntu2.7_all.deb (--unpack):\n    subprocess new pre-installation script returned error exit status 1\n   dpkg-query: warning: files list file for package 'keyboard-configuration' missing; assuming package has no files currently installed\n   dpkg-query: warning: files list file for package 'keyboard-configuration' missing; assuming package has no files currently installed\n   dpkg-query: warning: files list file for package 'keyboard-configuration' missing; assuming package has no files currently installed\n   Errors were encountered while processing:\n    /var/cache/apt/archives/keyboard-configuration_1.178ubuntu2.7_all.deb\n   E: Sub-process /usr/bin/dpkg returned an error code (1)\n   ```\n\n   问题综述：\n\n   1. `apt-get install lib`时报错 Unmet dependencies\n   2. `apt-get install -f ` 时报错Sub-process /usr/bin/dpkg returned an error code (1)\n\n\n4. 第一阶段解决办法\n\n   在/var/lib/dpkg/目录下有个info文件 ，然后文件中没有keyboard-configuration的相关文件但是有info的备份info_backup  ，这里面有相关的文件，于是将keyboard-configuration的所有相关文件都拷贝到了/var/lib/dpkg/info 中。\n\n   在info_backup目录下执行如下命令拷贝\n\n   `cp keyboard-configuration.* ../info`\n\n   随后再次执行安装内核通用工具 报错为第二阶段\n\n### 第二阶段\n\n1. 安装此内核的通用工具时时报错：\n\n   ``` \n   insserv: Starting redis depends on plymouth and therefore on system facility `$all' which can not be true!\n   insserv: exiting now without changing boot order!\n   update-rc.d: error: insserv rejected the script header\n   dpkg: error processing package avahi-daemon (--configure):\n    subprocess installed post-installation script returned error exit status 1\n   No apport report written because MaxReports is reached already\n                                                                 No apport report written because MaxReports is reached already\n                                                                                                                               dpkg: dependency problems prevent configuration o\n   f avahi-utils: avahi-utils depends on avahi-daemon; however:\n     Package avahi-daemon is not configured yet.\n   \n   dpkg: error processing package avahi-utils (--configure):\n    dependency problems - leaving unconfigured\n   Setting up unattended-upgrades (1.1ubuntu1.18.04.9) ...\n   dpkg: error processing package unattended-upgrades (--configure):\n    subprocess installed post-installation script returned error exit status 10\n   No apport report written because MaxReports is reached already\n                                                                 Setting up linux-tools-4.15.0-45 (4.15.0-45.48) ...\n   Setting up linux-tools-4.15.0-45-generic (4.15.0-45.48) ...\n   Processing triggers for initramfs-tools (0.122ubuntu8.14) ...\n   Errors were encountered while processing:\n    udev\n    snapd\n    ubuntu-core-launcher\n    kmod\n    ubuntu-drivers-common\n    whoopsie\n    openssh-server\n    ssh\n    avahi-daemon\n    avahi-utils\n    unattended-upgrades\n   E: Sub-process /usr/bin/dpkg returned an error code (1)\n   ```\n\n2. 解决办法：/var/lib/dpkg/info 目录下将上述出现问题的模块的postinst文件重命名。\n\n   在/var/lib/dpkg/info 下写了个脚本\n\n   solution.sh\n\n   ```\n   #!/bin/bash\n   for pack in $(cat module.txt)\n   do \n       mv \"$pack\".postinst \"$pack\".postinst.bak\n   done\n   ```\n\n   其中module.txt的内容为\n\n   ```\n    udev\n    snapd\n    ubuntu-core-launcher\n    kmod\n    ubuntu-drivers-common\n    whoopsie\n    openssh-server\n    ssh\n    avahi-daemon\n    avahi-utils\n    unattended-upgrades\n   ```\n\n3. 执行脚本后 使用`sudo apt-get upgrade` 进行更新\n\n4. 参考：\n\n   1. https://www.codelast.com/%E5%8E%9F%E5%88%9B-%E8%A7%A3%E5%86%B3ubuntu-%E6%97%A0%E6%B3%95%E7%94%A8-apt-get-install-%E5%AE%89%E8%A3%85%E4%BB%BB%E4%BD%95%E8%BD%AF%E4%BB%B6dpkg-error-processing-package-xxx%E7%9A%84%E9%97%AE/\n   2. https://askubuntu.com/questions/949760/dpkg-warning-files-list-file-for-package-missing","source":"_posts/apt-get install 失败.md","raw":"---\ntitle: apt-get install失败\ndate: 2019-03-10 16:23:20\ncategories: Linux\ntags: \n- Linux \n- 运维\ncopyright: true\n---\n\n## apt-get install失败\n\n<!--more-->\n\n### 第一阶段\n\n1. 使用perf 报错 内核无法找到perf\n\n   ```\n   root@hw103:/home/yky/redis-5.0.3# perf \n   WARNING: perf not found for kernel 4.15.0-45\n   \n     You may need to install the following packages for this specific kernel:\n       linux-tools-4.15.0-45-generic\n       linux-cloud-tools-4.15.0-45-generic\n   \n     You may also want to install one of the following packages to keep up to date:\n       linux-tools-generic\n       linux-cloud-tools-generic\n   ```\n\n   \n\n2. 安装此内核的通用工具时错误\n\n   ```\n   root@hw103:/home/yky/redis-5.0.3# apt-get install  linux-tools-4.15.0-45-generic\n   Reading package lists... Done\n   Building dependency tree       \n   Reading state information... Done\n   You might want to run 'apt-get -f install' to correct these:\n   The following packages have unmet dependencies:\n    console-setup : Depends: keyboard-configuration (= 1.178ubuntu2.7) but 1.108ubuntu15.3 is to be installed\n    console-setup-linux : Depends: keyboard-configuration (= 1.178ubuntu2.7) but 1.108ubuntu15.3 is to be installed\n                          Breaks: keyboard-configuration (< 1.138) but 1.108ubuntu15.3 is to be installed\n    linux-tools-4.15.0-45-generic : Depends: linux-tools-4.15.0-45 but it is not going to be installed\n   E: Unmet dependencies. Try 'apt-get -f install' with no packages (or specify a solution).\n   ```\n\n3. 使用apt-get -f install 时报错\n\n   ```\n   update-rc.d: error: insserv rejected the script header\n   dpkg: error processing archive /var/cache/apt/archives/keyboard-configuration_1.178ubuntu2.7_all.deb (--unpack):\n    subprocess new pre-installation script returned error exit status 1\n   dpkg-query: warning: files list file for package 'keyboard-configuration' missing; assuming package has no files currently installed\n   dpkg-query: warning: files list file for package 'keyboard-configuration' missing; assuming package has no files currently installed\n   dpkg-query: warning: files list file for package 'keyboard-configuration' missing; assuming package has no files currently installed\n   Errors were encountered while processing:\n    /var/cache/apt/archives/keyboard-configuration_1.178ubuntu2.7_all.deb\n   E: Sub-process /usr/bin/dpkg returned an error code (1)\n   ```\n\n   问题综述：\n\n   1. `apt-get install lib`时报错 Unmet dependencies\n   2. `apt-get install -f ` 时报错Sub-process /usr/bin/dpkg returned an error code (1)\n\n\n4. 第一阶段解决办法\n\n   在/var/lib/dpkg/目录下有个info文件 ，然后文件中没有keyboard-configuration的相关文件但是有info的备份info_backup  ，这里面有相关的文件，于是将keyboard-configuration的所有相关文件都拷贝到了/var/lib/dpkg/info 中。\n\n   在info_backup目录下执行如下命令拷贝\n\n   `cp keyboard-configuration.* ../info`\n\n   随后再次执行安装内核通用工具 报错为第二阶段\n\n### 第二阶段\n\n1. 安装此内核的通用工具时时报错：\n\n   ``` \n   insserv: Starting redis depends on plymouth and therefore on system facility `$all' which can not be true!\n   insserv: exiting now without changing boot order!\n   update-rc.d: error: insserv rejected the script header\n   dpkg: error processing package avahi-daemon (--configure):\n    subprocess installed post-installation script returned error exit status 1\n   No apport report written because MaxReports is reached already\n                                                                 No apport report written because MaxReports is reached already\n                                                                                                                               dpkg: dependency problems prevent configuration o\n   f avahi-utils: avahi-utils depends on avahi-daemon; however:\n     Package avahi-daemon is not configured yet.\n   \n   dpkg: error processing package avahi-utils (--configure):\n    dependency problems - leaving unconfigured\n   Setting up unattended-upgrades (1.1ubuntu1.18.04.9) ...\n   dpkg: error processing package unattended-upgrades (--configure):\n    subprocess installed post-installation script returned error exit status 10\n   No apport report written because MaxReports is reached already\n                                                                 Setting up linux-tools-4.15.0-45 (4.15.0-45.48) ...\n   Setting up linux-tools-4.15.0-45-generic (4.15.0-45.48) ...\n   Processing triggers for initramfs-tools (0.122ubuntu8.14) ...\n   Errors were encountered while processing:\n    udev\n    snapd\n    ubuntu-core-launcher\n    kmod\n    ubuntu-drivers-common\n    whoopsie\n    openssh-server\n    ssh\n    avahi-daemon\n    avahi-utils\n    unattended-upgrades\n   E: Sub-process /usr/bin/dpkg returned an error code (1)\n   ```\n\n2. 解决办法：/var/lib/dpkg/info 目录下将上述出现问题的模块的postinst文件重命名。\n\n   在/var/lib/dpkg/info 下写了个脚本\n\n   solution.sh\n\n   ```\n   #!/bin/bash\n   for pack in $(cat module.txt)\n   do \n       mv \"$pack\".postinst \"$pack\".postinst.bak\n   done\n   ```\n\n   其中module.txt的内容为\n\n   ```\n    udev\n    snapd\n    ubuntu-core-launcher\n    kmod\n    ubuntu-drivers-common\n    whoopsie\n    openssh-server\n    ssh\n    avahi-daemon\n    avahi-utils\n    unattended-upgrades\n   ```\n\n3. 执行脚本后 使用`sudo apt-get upgrade` 进行更新\n\n4. 参考：\n\n   1. https://www.codelast.com/%E5%8E%9F%E5%88%9B-%E8%A7%A3%E5%86%B3ubuntu-%E6%97%A0%E6%B3%95%E7%94%A8-apt-get-install-%E5%AE%89%E8%A3%85%E4%BB%BB%E4%BD%95%E8%BD%AF%E4%BB%B6dpkg-error-processing-package-xxx%E7%9A%84%E9%97%AE/\n   2. https://askubuntu.com/questions/949760/dpkg-warning-files-list-file-for-package-missing","slug":"apt-get install 失败","published":1,"updated":"2019-11-08T13:16:54.015Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2yelxhv001qm8tzv52lln7y","content":"<h2 id=\"apt-get-install失败\"><a href=\"#apt-get-install失败\" class=\"headerlink\" title=\"apt-get install失败\"></a>apt-get install失败</h2><a id=\"more\"></a>\n<h3 id=\"第一阶段\"><a href=\"#第一阶段\" class=\"headerlink\" title=\"第一阶段\"></a>第一阶段</h3><ol>\n<li><p>使用perf 报错 内核无法找到perf</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@hw103:/home/yky/redis-5.0.3# perf </span><br><span class=\"line\">WARNING: perf not found for kernel 4.15.0-45</span><br><span class=\"line\"></span><br><span class=\"line\">  You may need to install the following packages for this specific kernel:</span><br><span class=\"line\">    linux-tools-4.15.0-45-generic</span><br><span class=\"line\">    linux-cloud-tools-4.15.0-45-generic</span><br><span class=\"line\"></span><br><span class=\"line\">  You may also want to install one of the following packages to keep up to date:</span><br><span class=\"line\">    linux-tools-generic</span><br><span class=\"line\">    linux-cloud-tools-generic</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol>\n<li><p>安装此内核的通用工具时错误</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@hw103:/home/yky/redis-5.0.3# apt-get install  linux-tools-4.15.0-45-generic</span><br><span class=\"line\">Reading package lists... Done</span><br><span class=\"line\">Building dependency tree       </span><br><span class=\"line\">Reading state information... Done</span><br><span class=\"line\">You might want to run &apos;apt-get -f install&apos; to correct these:</span><br><span class=\"line\">The following packages have unmet dependencies:</span><br><span class=\"line\"> console-setup : Depends: keyboard-configuration (= 1.178ubuntu2.7) but 1.108ubuntu15.3 is to be installed</span><br><span class=\"line\"> console-setup-linux : Depends: keyboard-configuration (= 1.178ubuntu2.7) but 1.108ubuntu15.3 is to be installed</span><br><span class=\"line\">                       Breaks: keyboard-configuration (&lt; 1.138) but 1.108ubuntu15.3 is to be installed</span><br><span class=\"line\"> linux-tools-4.15.0-45-generic : Depends: linux-tools-4.15.0-45 but it is not going to be installed</span><br><span class=\"line\">E: Unmet dependencies. Try &apos;apt-get -f install&apos; with no packages (or specify a solution).</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用apt-get -f install 时报错</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">update-rc.d: error: insserv rejected the script header</span><br><span class=\"line\">dpkg: error processing archive /var/cache/apt/archives/keyboard-configuration_1.178ubuntu2.7_all.deb (--unpack):</span><br><span class=\"line\"> subprocess new pre-installation script returned error exit status 1</span><br><span class=\"line\">dpkg-query: warning: files list file for package &apos;keyboard-configuration&apos; missing; assuming package has no files currently installed</span><br><span class=\"line\">dpkg-query: warning: files list file for package &apos;keyboard-configuration&apos; missing; assuming package has no files currently installed</span><br><span class=\"line\">dpkg-query: warning: files list file for package &apos;keyboard-configuration&apos; missing; assuming package has no files currently installed</span><br><span class=\"line\">Errors were encountered while processing:</span><br><span class=\"line\"> /var/cache/apt/archives/keyboard-configuration_1.178ubuntu2.7_all.deb</span><br><span class=\"line\">E: Sub-process /usr/bin/dpkg returned an error code (1)</span><br></pre></td></tr></table></figure>\n<p>问题综述：</p>\n<ol>\n<li><code>apt-get install lib</code>时报错 Unmet dependencies</li>\n<li><code>apt-get install -f</code> 时报错Sub-process /usr/bin/dpkg returned an error code (1)</li>\n</ol>\n</li>\n</ol>\n<ol>\n<li><p>第一阶段解决办法</p>\n<p>在/var/lib/dpkg/目录下有个info文件 ，然后文件中没有keyboard-configuration的相关文件但是有info的备份info_backup  ，这里面有相关的文件，于是将keyboard-configuration的所有相关文件都拷贝到了/var/lib/dpkg/info 中。</p>\n<p>在info_backup目录下执行如下命令拷贝</p>\n<p><code>cp keyboard-configuration.* ../info</code></p>\n<p>随后再次执行安装内核通用工具 报错为第二阶段</p>\n</li>\n</ol>\n<h3 id=\"第二阶段\"><a href=\"#第二阶段\" class=\"headerlink\" title=\"第二阶段\"></a>第二阶段</h3><ol>\n<li><p>安装此内核的通用工具时时报错：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">insserv: Starting redis depends on plymouth and therefore on system facility `$all&apos; which can not be true!</span><br><span class=\"line\">insserv: exiting now without changing boot order!</span><br><span class=\"line\">update-rc.d: error: insserv rejected the script header</span><br><span class=\"line\">dpkg: error processing package avahi-daemon (--configure):</span><br><span class=\"line\"> subprocess installed post-installation script returned error exit status 1</span><br><span class=\"line\">No apport report written because MaxReports is reached already</span><br><span class=\"line\">                                                              No apport report written because MaxReports is reached already</span><br><span class=\"line\">                                                                                                                            dpkg: dependency problems prevent configuration o</span><br><span class=\"line\">f avahi-utils: avahi-utils depends on avahi-daemon; however:</span><br><span class=\"line\">  Package avahi-daemon is not configured yet.</span><br><span class=\"line\"></span><br><span class=\"line\">dpkg: error processing package avahi-utils (--configure):</span><br><span class=\"line\"> dependency problems - leaving unconfigured</span><br><span class=\"line\">Setting up unattended-upgrades (1.1ubuntu1.18.04.9) ...</span><br><span class=\"line\">dpkg: error processing package unattended-upgrades (--configure):</span><br><span class=\"line\"> subprocess installed post-installation script returned error exit status 10</span><br><span class=\"line\">No apport report written because MaxReports is reached already</span><br><span class=\"line\">                                                              Setting up linux-tools-4.15.0-45 (4.15.0-45.48) ...</span><br><span class=\"line\">Setting up linux-tools-4.15.0-45-generic (4.15.0-45.48) ...</span><br><span class=\"line\">Processing triggers for initramfs-tools (0.122ubuntu8.14) ...</span><br><span class=\"line\">Errors were encountered while processing:</span><br><span class=\"line\"> udev</span><br><span class=\"line\"> snapd</span><br><span class=\"line\"> ubuntu-core-launcher</span><br><span class=\"line\"> kmod</span><br><span class=\"line\"> ubuntu-drivers-common</span><br><span class=\"line\"> whoopsie</span><br><span class=\"line\"> openssh-server</span><br><span class=\"line\"> ssh</span><br><span class=\"line\"> avahi-daemon</span><br><span class=\"line\"> avahi-utils</span><br><span class=\"line\"> unattended-upgrades</span><br><span class=\"line\">E: Sub-process /usr/bin/dpkg returned an error code (1)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>解决办法：/var/lib/dpkg/info 目录下将上述出现问题的模块的postinst文件重命名。</p>\n<p>在/var/lib/dpkg/info 下写了个脚本</p>\n<p>solution.sh</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/bash</span><br><span class=\"line\">for pack in $(cat module.txt)</span><br><span class=\"line\">do </span><br><span class=\"line\">    mv &quot;$pack&quot;.postinst &quot;$pack&quot;.postinst.bak</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure>\n<p>其中module.txt的内容为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">udev</span><br><span class=\"line\">snapd</span><br><span class=\"line\">ubuntu-core-launcher</span><br><span class=\"line\">kmod</span><br><span class=\"line\">ubuntu-drivers-common</span><br><span class=\"line\">whoopsie</span><br><span class=\"line\">openssh-server</span><br><span class=\"line\">ssh</span><br><span class=\"line\">avahi-daemon</span><br><span class=\"line\">avahi-utils</span><br><span class=\"line\">unattended-upgrades</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>执行脚本后 使用<code>sudo apt-get upgrade</code> 进行更新</p>\n</li>\n<li><p>参考：</p>\n<ol>\n<li><a href=\"https://www.codelast.com/%E5%8E%9F%E5%88%9B-%E8%A7%A3%E5%86%B3ubuntu-%E6%97%A0%E6%B3%95%E7%94%A8-apt-get-install-%E5%AE%89%E8%A3%85%E4%BB%BB%E4%BD%95%E8%BD%AF%E4%BB%B6dpkg-error-processing-package-xxx%E7%9A%84%E9%97%AE/\" target=\"_blank\" rel=\"noopener\">https://www.codelast.com/%E5%8E%9F%E5%88%9B-%E8%A7%A3%E5%86%B3ubuntu-%E6%97%A0%E6%B3%95%E7%94%A8-apt-get-install-%E5%AE%89%E8%A3%85%E4%BB%BB%E4%BD%95%E8%BD%AF%E4%BB%B6dpkg-error-processing-package-xxx%E7%9A%84%E9%97%AE/</a></li>\n<li><a href=\"https://askubuntu.com/questions/949760/dpkg-warning-files-list-file-for-package-missing\" target=\"_blank\" rel=\"noopener\">https://askubuntu.com/questions/949760/dpkg-warning-files-list-file-for-package-missing</a></li>\n</ol>\n</li>\n</ol>\n","site":{"data":{}},"length":4190,"excerpt":"<h2 id=\"apt-get-install失败\"><a href=\"#apt-get-install失败\" class=\"headerlink\" title=\"apt-get install失败\"></a>apt-get install失败</h2>","more":"<h3 id=\"第一阶段\"><a href=\"#第一阶段\" class=\"headerlink\" title=\"第一阶段\"></a>第一阶段</h3><ol>\n<li><p>使用perf 报错 内核无法找到perf</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@hw103:/home/yky/redis-5.0.3# perf </span><br><span class=\"line\">WARNING: perf not found for kernel 4.15.0-45</span><br><span class=\"line\"></span><br><span class=\"line\">  You may need to install the following packages for this specific kernel:</span><br><span class=\"line\">    linux-tools-4.15.0-45-generic</span><br><span class=\"line\">    linux-cloud-tools-4.15.0-45-generic</span><br><span class=\"line\"></span><br><span class=\"line\">  You may also want to install one of the following packages to keep up to date:</span><br><span class=\"line\">    linux-tools-generic</span><br><span class=\"line\">    linux-cloud-tools-generic</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol>\n<li><p>安装此内核的通用工具时错误</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@hw103:/home/yky/redis-5.0.3# apt-get install  linux-tools-4.15.0-45-generic</span><br><span class=\"line\">Reading package lists... Done</span><br><span class=\"line\">Building dependency tree       </span><br><span class=\"line\">Reading state information... Done</span><br><span class=\"line\">You might want to run &apos;apt-get -f install&apos; to correct these:</span><br><span class=\"line\">The following packages have unmet dependencies:</span><br><span class=\"line\"> console-setup : Depends: keyboard-configuration (= 1.178ubuntu2.7) but 1.108ubuntu15.3 is to be installed</span><br><span class=\"line\"> console-setup-linux : Depends: keyboard-configuration (= 1.178ubuntu2.7) but 1.108ubuntu15.3 is to be installed</span><br><span class=\"line\">                       Breaks: keyboard-configuration (&lt; 1.138) but 1.108ubuntu15.3 is to be installed</span><br><span class=\"line\"> linux-tools-4.15.0-45-generic : Depends: linux-tools-4.15.0-45 but it is not going to be installed</span><br><span class=\"line\">E: Unmet dependencies. Try &apos;apt-get -f install&apos; with no packages (or specify a solution).</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用apt-get -f install 时报错</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">update-rc.d: error: insserv rejected the script header</span><br><span class=\"line\">dpkg: error processing archive /var/cache/apt/archives/keyboard-configuration_1.178ubuntu2.7_all.deb (--unpack):</span><br><span class=\"line\"> subprocess new pre-installation script returned error exit status 1</span><br><span class=\"line\">dpkg-query: warning: files list file for package &apos;keyboard-configuration&apos; missing; assuming package has no files currently installed</span><br><span class=\"line\">dpkg-query: warning: files list file for package &apos;keyboard-configuration&apos; missing; assuming package has no files currently installed</span><br><span class=\"line\">dpkg-query: warning: files list file for package &apos;keyboard-configuration&apos; missing; assuming package has no files currently installed</span><br><span class=\"line\">Errors were encountered while processing:</span><br><span class=\"line\"> /var/cache/apt/archives/keyboard-configuration_1.178ubuntu2.7_all.deb</span><br><span class=\"line\">E: Sub-process /usr/bin/dpkg returned an error code (1)</span><br></pre></td></tr></table></figure>\n<p>问题综述：</p>\n<ol>\n<li><code>apt-get install lib</code>时报错 Unmet dependencies</li>\n<li><code>apt-get install -f</code> 时报错Sub-process /usr/bin/dpkg returned an error code (1)</li>\n</ol>\n</li>\n</ol>\n<ol>\n<li><p>第一阶段解决办法</p>\n<p>在/var/lib/dpkg/目录下有个info文件 ，然后文件中没有keyboard-configuration的相关文件但是有info的备份info_backup  ，这里面有相关的文件，于是将keyboard-configuration的所有相关文件都拷贝到了/var/lib/dpkg/info 中。</p>\n<p>在info_backup目录下执行如下命令拷贝</p>\n<p><code>cp keyboard-configuration.* ../info</code></p>\n<p>随后再次执行安装内核通用工具 报错为第二阶段</p>\n</li>\n</ol>\n<h3 id=\"第二阶段\"><a href=\"#第二阶段\" class=\"headerlink\" title=\"第二阶段\"></a>第二阶段</h3><ol>\n<li><p>安装此内核的通用工具时时报错：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">insserv: Starting redis depends on plymouth and therefore on system facility `$all&apos; which can not be true!</span><br><span class=\"line\">insserv: exiting now without changing boot order!</span><br><span class=\"line\">update-rc.d: error: insserv rejected the script header</span><br><span class=\"line\">dpkg: error processing package avahi-daemon (--configure):</span><br><span class=\"line\"> subprocess installed post-installation script returned error exit status 1</span><br><span class=\"line\">No apport report written because MaxReports is reached already</span><br><span class=\"line\">                                                              No apport report written because MaxReports is reached already</span><br><span class=\"line\">                                                                                                                            dpkg: dependency problems prevent configuration o</span><br><span class=\"line\">f avahi-utils: avahi-utils depends on avahi-daemon; however:</span><br><span class=\"line\">  Package avahi-daemon is not configured yet.</span><br><span class=\"line\"></span><br><span class=\"line\">dpkg: error processing package avahi-utils (--configure):</span><br><span class=\"line\"> dependency problems - leaving unconfigured</span><br><span class=\"line\">Setting up unattended-upgrades (1.1ubuntu1.18.04.9) ...</span><br><span class=\"line\">dpkg: error processing package unattended-upgrades (--configure):</span><br><span class=\"line\"> subprocess installed post-installation script returned error exit status 10</span><br><span class=\"line\">No apport report written because MaxReports is reached already</span><br><span class=\"line\">                                                              Setting up linux-tools-4.15.0-45 (4.15.0-45.48) ...</span><br><span class=\"line\">Setting up linux-tools-4.15.0-45-generic (4.15.0-45.48) ...</span><br><span class=\"line\">Processing triggers for initramfs-tools (0.122ubuntu8.14) ...</span><br><span class=\"line\">Errors were encountered while processing:</span><br><span class=\"line\"> udev</span><br><span class=\"line\"> snapd</span><br><span class=\"line\"> ubuntu-core-launcher</span><br><span class=\"line\"> kmod</span><br><span class=\"line\"> ubuntu-drivers-common</span><br><span class=\"line\"> whoopsie</span><br><span class=\"line\"> openssh-server</span><br><span class=\"line\"> ssh</span><br><span class=\"line\"> avahi-daemon</span><br><span class=\"line\"> avahi-utils</span><br><span class=\"line\"> unattended-upgrades</span><br><span class=\"line\">E: Sub-process /usr/bin/dpkg returned an error code (1)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>解决办法：/var/lib/dpkg/info 目录下将上述出现问题的模块的postinst文件重命名。</p>\n<p>在/var/lib/dpkg/info 下写了个脚本</p>\n<p>solution.sh</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/bash</span><br><span class=\"line\">for pack in $(cat module.txt)</span><br><span class=\"line\">do </span><br><span class=\"line\">    mv &quot;$pack&quot;.postinst &quot;$pack&quot;.postinst.bak</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure>\n<p>其中module.txt的内容为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">udev</span><br><span class=\"line\">snapd</span><br><span class=\"line\">ubuntu-core-launcher</span><br><span class=\"line\">kmod</span><br><span class=\"line\">ubuntu-drivers-common</span><br><span class=\"line\">whoopsie</span><br><span class=\"line\">openssh-server</span><br><span class=\"line\">ssh</span><br><span class=\"line\">avahi-daemon</span><br><span class=\"line\">avahi-utils</span><br><span class=\"line\">unattended-upgrades</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>执行脚本后 使用<code>sudo apt-get upgrade</code> 进行更新</p>\n</li>\n<li><p>参考：</p>\n<ol>\n<li><a href=\"https://www.codelast.com/%E5%8E%9F%E5%88%9B-%E8%A7%A3%E5%86%B3ubuntu-%E6%97%A0%E6%B3%95%E7%94%A8-apt-get-install-%E5%AE%89%E8%A3%85%E4%BB%BB%E4%BD%95%E8%BD%AF%E4%BB%B6dpkg-error-processing-package-xxx%E7%9A%84%E9%97%AE/\" target=\"_blank\" rel=\"noopener\">https://www.codelast.com/%E5%8E%9F%E5%88%9B-%E8%A7%A3%E5%86%B3ubuntu-%E6%97%A0%E6%B3%95%E7%94%A8-apt-get-install-%E5%AE%89%E8%A3%85%E4%BB%BB%E4%BD%95%E8%BD%AF%E4%BB%B6dpkg-error-processing-package-xxx%E7%9A%84%E9%97%AE/</a></li>\n<li><a href=\"https://askubuntu.com/questions/949760/dpkg-warning-files-list-file-for-package-missing\" target=\"_blank\" rel=\"noopener\">https://askubuntu.com/questions/949760/dpkg-warning-files-list-file-for-package-missing</a></li>\n</ol>\n</li>\n</ol>"},{"title":"Make学习","date":"2018-10-09T14:51:57.000Z","copyright":true,"_content":"\n# make学习\n\n开始阅读redis源码，都说redis很简单，源码不多。但是源码包下载下来后却发现不知道从何处入手，有那么多文件和源码。后面查找资料才发现阅读源码的第一步就是阅读Makefile，项目如何构建和源码间的关联都写在了Makefile文件中。之前没有接触过Makefile，记录下Make的学习。\n\n<!--more-->\n\n## makefile的格式\n\n1. 概述\n\n   makefile 文件由一系列rules组成 rules的格式为：\n\n```\n<target> : <prerequisites> \n[tab]  <commands>\n```\n\n​\t\"目标\"是必需的，不可省略；\"前置条件\"和\"命令\"都是可选的，但是两者之中必须至少存在一个。 \n\n​\t每条规则就明确两件事：构建目标的前置条件是什么，以及如何构建。 \n\n2. target\n\n   一个目标（target）就构成一条规则。目标通常是文件名，指明Make命令所要构建的对象，比如上文的 a.txt 目标可以是一个文件名，也可以是多个文件名，之间用空格分隔。（make的时候指定文件名从而对该文件进行构建build）\n\n   除了文件名，目标还可以是某个操作的名字，这称为\"伪目标\"（phony target）。伪目标不生成文件，只执行命令。\n\n   比如：\n\n   ```\n   clean:\n         rm *.o\n   ```\n\n   此时执行`make clean` 命令则会进行`rm *.o` 的操作。\n\n   但是当存在clean这个文件时，那么这个命令不会执行。因为Make发现clean文件已经存在，就认为没有必要重新构建了，就不会执行指定的rm命令。\n\n   为了避免这种情况，可以明确声明clean是\"伪目标\"，写法如下。\n\n   ```\n   .PHONY: clean\n   clean:\n           rm *.o temp\n   ```\n\n   如果Make命令运行时没有指定目标，默认会执行Makefile文件的第一个目标。 \n\n3. prerequisites\n\n   前置条件通常是一组文件名，之间用空格分隔。它指定了\"目标\"是否重新构建的判断标准：只要有一个前置文件不存在，或者有过更新（前置文件的last-modification时间戳比目标的时间戳新），\"目标\"就需要重新构建。 \n\n   没有前置条件，就意味着它跟其他文件都无关，只要这个target文件还不存在 就需要执行命令构建\n\n   如果需要生成多个文件，往往采用下面的写法。 \n\n   `source: file1 file2 file3`  \n\n   无需加上命令，当三个文件不存在时，执行`make source`就会生成这三个文件。\n\n4. commands\n\n   命令（commands）表示如何更新目标文件，由一行或多行的Shell命令组成。它是构建\"目标\"的具体指令，它的运行结果通常就是生成目标文件。 \n\n   每行命令之前必须有一个tab键 \n\n   需要注意的是，每行命令在一个单独的shell中执行。这些Shell之间没有继承关系。\n\n   ```\n   var-lost:\n       export foo=bar\n       echo \"foo=[$$foo]\"\n   ```\n\n   上面代码执行后（`make var-lost`），取不到foo的值。因为两行命令在两个不同的进程执行。 \n\n   解决办法：\n\n    1. 命令写在同1行\n\n    2. 换行符前加反斜杠转义\n\n       ```\n       var-kept:\n           export foo=bar; \\\n           echo \"foo=[$$foo]\"\n       ```\n\n   \t3. 加上`.ONESHELL:`命令 \n\n       ```\n       .ONESHELL:\n       var-kept:\n           export foo=bar; \n           echo \"foo=[$$foo]\"\n       ```\n\n## makefile的语法\n\n1. 注释\n\n   井号（#）在Makefile中表示注释。 \n\n2. 回声（echoing）\n\n   正常情况下，make会打印每条命令，然后再执行，这就叫做回声（echoing）。\n\n   在命令的前面加上@，就可以关闭回声。 \n\n   由于在构建过程中，需要了解当前在执行哪条命令，所以通常只在注释和纯显示的echo命令前面加上@。 \n\n3. 通配符\n\n   由于在构建过程中，需要了解当前在执行哪条命令，所以通常只在注释和纯显示的echo命令前面加上@。 \n\n4. 模式匹配\n\n   Make命令允许对文件名，进行类似正则运算的匹配，主要用到的匹配符是%。比如，假定当前目录下有 f1.c 和 f2.c 两个源码文件，需要将它们编译为对应的对象文件。 \n\n   ```\n   %.o: %.c\n   ```\n\n   等同于\n\n   ```\n   f1.o: f1.c\n   f2.o: f2.c\n   ```\n\n   使用匹配符%，可以将大量同类型的文件，只用一条规则就完成构建。 \n\n5. 变量和赋值符\n\n   Makefile 允许使用等号自定义变量。 \n\n   ```\n   txt = Hello World\n   test:\n       @echo $(txt)\n   ```\n\n   上面代码中，变量 txt 等于 Hello World。调用时，变量需要放在 $( ) 之中 \n\n   调用Shell变量，需要在美元符号前，再加一个美元符号，这是因为Make命令会对美元符号转义。 \n\n6. 内置变量\n\n   Make命令提供一系列内置变量，比如，$(CC) 指向当前使用的编译器，$(MAKE) 指向当前使用的Make工具。这主要是为了跨平台的兼容性 gmake、cmake、dmake等等。\n\n   $(AR) ：函数库打包程序,将对应的gcc编译出来的obj文件打包成静态链接库程序。\n\n   ar可以集合许多文件，成为单一的备存文件。在备存文件中，所有成员文件皆保有原来的属性与权限。\n\n7. 自动变量\n\n   1. $@指代当前目标，就是Make命令当前构建的那个目标  target\n\n   2. $<指代第一个前置条件。比如，规则为 t: p1 p2，那么$< 就指代p1 \n\n   3. $？指代比目标更新的所有前置条件，之间以空格分隔。比如，规则为 t: p1 p2，其中 p2 的时间戳比 t 新，$?就指代p2。 \n\n   4. $^指代所有前置条件，之间以空格分隔。比如，规则为 t: p1 p2，那么 $^ 就指代 p1 p2 。 \n\n   5. $*指代匹配符 % 匹配的部分， 比如% 匹配 f1.txt 中的f1 ，$* 就表示 f1。 \n\n   6. $(@D) 和 $(@F)$(@D) 和 $(@F) 分别指向 $@ 的目录名和文件名。比如，$@是 src/input.c，那么$(@D) 的值为 src ，$(@F) 的值为 input.c。 \n\n   7. $(<D) 和 $(<F)\n\n      $(<D) 和 $(<F) 分别指向 $< 的目录名和文件名。\n\n8. 其他\n\n   1. `.DEFAULT：`表示找不到匹配规则时，就执行该recipe。  \n\n      ```\n      default:all\n      .DEFAULT:\n      \tcommands\n      ```\n\n      这里当执行`make default` 时会转到`make all` 因为default：all 这个target没有隐式规则。所以最后会执行commands。\n\n   2. 忽略命令的出错，可以在Makefile的命令行前加一个减号\"-\"(在Tab键之后)，标记为不管命令出不出错都认为是成功的。如：     \n\n      ```\n      clean:        \n      \t-(rm -f *.o )\n      ```\n\n   3. `include filename` 将filename中的内容导入，如果找不到会停止make， `-include filename` 则不会停止make。 \n\n## 几种等号\n\n= 是最基本的赋值\n:= 是覆盖之前的值\n?= 是如果没有被赋值过就赋予等号后面的值\n+= 是添加等号后面的值\n\n=与:= 的区别\n\n =：make会将整个makefile展开后，再决定变量的值。也就是说，变量的值将会是整个makefile中最后被指定的值。例子为：\n\n```makefile\n     x = foo\n     y = $(x) bar\n     x = xyz\n```\n\ny的值将会是 xyz bar ，而不是 foo bar 。因为展开后最终变成的是xyz\n\n:=表示变量的值决定于它在makefile中的位置，而不是整个makefile展开后的最终值。\n\n```makefile\n x := foo\n y := $(x) bar\n x := xyz\n```\n\ny的值将会是 foo bar ，而不是 xyz bar 了。\n\n## 参考资料：\n\n1. http://www.ruanyifeng.com/blog/2015/02/make.html\n2. https://gist.github.com/isaacs/62a2d1825d04437c6f08 makefile文件教程\n3. https://www.gnu.org/software/make/manual/make.html GNUmake手册\n4. <https://blog.csdn.net/shouso888/article/details/7226030> 等号解释\n\n","source":"_posts/make学习.md","raw":"---\ntitle: Make学习\ndate: 2018-10-09 22:51:57\ncategories: 编程语言\ntags:\n- make\ncopyright: true\n---\n\n# make学习\n\n开始阅读redis源码，都说redis很简单，源码不多。但是源码包下载下来后却发现不知道从何处入手，有那么多文件和源码。后面查找资料才发现阅读源码的第一步就是阅读Makefile，项目如何构建和源码间的关联都写在了Makefile文件中。之前没有接触过Makefile，记录下Make的学习。\n\n<!--more-->\n\n## makefile的格式\n\n1. 概述\n\n   makefile 文件由一系列rules组成 rules的格式为：\n\n```\n<target> : <prerequisites> \n[tab]  <commands>\n```\n\n​\t\"目标\"是必需的，不可省略；\"前置条件\"和\"命令\"都是可选的，但是两者之中必须至少存在一个。 \n\n​\t每条规则就明确两件事：构建目标的前置条件是什么，以及如何构建。 \n\n2. target\n\n   一个目标（target）就构成一条规则。目标通常是文件名，指明Make命令所要构建的对象，比如上文的 a.txt 目标可以是一个文件名，也可以是多个文件名，之间用空格分隔。（make的时候指定文件名从而对该文件进行构建build）\n\n   除了文件名，目标还可以是某个操作的名字，这称为\"伪目标\"（phony target）。伪目标不生成文件，只执行命令。\n\n   比如：\n\n   ```\n   clean:\n         rm *.o\n   ```\n\n   此时执行`make clean` 命令则会进行`rm *.o` 的操作。\n\n   但是当存在clean这个文件时，那么这个命令不会执行。因为Make发现clean文件已经存在，就认为没有必要重新构建了，就不会执行指定的rm命令。\n\n   为了避免这种情况，可以明确声明clean是\"伪目标\"，写法如下。\n\n   ```\n   .PHONY: clean\n   clean:\n           rm *.o temp\n   ```\n\n   如果Make命令运行时没有指定目标，默认会执行Makefile文件的第一个目标。 \n\n3. prerequisites\n\n   前置条件通常是一组文件名，之间用空格分隔。它指定了\"目标\"是否重新构建的判断标准：只要有一个前置文件不存在，或者有过更新（前置文件的last-modification时间戳比目标的时间戳新），\"目标\"就需要重新构建。 \n\n   没有前置条件，就意味着它跟其他文件都无关，只要这个target文件还不存在 就需要执行命令构建\n\n   如果需要生成多个文件，往往采用下面的写法。 \n\n   `source: file1 file2 file3`  \n\n   无需加上命令，当三个文件不存在时，执行`make source`就会生成这三个文件。\n\n4. commands\n\n   命令（commands）表示如何更新目标文件，由一行或多行的Shell命令组成。它是构建\"目标\"的具体指令，它的运行结果通常就是生成目标文件。 \n\n   每行命令之前必须有一个tab键 \n\n   需要注意的是，每行命令在一个单独的shell中执行。这些Shell之间没有继承关系。\n\n   ```\n   var-lost:\n       export foo=bar\n       echo \"foo=[$$foo]\"\n   ```\n\n   上面代码执行后（`make var-lost`），取不到foo的值。因为两行命令在两个不同的进程执行。 \n\n   解决办法：\n\n    1. 命令写在同1行\n\n    2. 换行符前加反斜杠转义\n\n       ```\n       var-kept:\n           export foo=bar; \\\n           echo \"foo=[$$foo]\"\n       ```\n\n   \t3. 加上`.ONESHELL:`命令 \n\n       ```\n       .ONESHELL:\n       var-kept:\n           export foo=bar; \n           echo \"foo=[$$foo]\"\n       ```\n\n## makefile的语法\n\n1. 注释\n\n   井号（#）在Makefile中表示注释。 \n\n2. 回声（echoing）\n\n   正常情况下，make会打印每条命令，然后再执行，这就叫做回声（echoing）。\n\n   在命令的前面加上@，就可以关闭回声。 \n\n   由于在构建过程中，需要了解当前在执行哪条命令，所以通常只在注释和纯显示的echo命令前面加上@。 \n\n3. 通配符\n\n   由于在构建过程中，需要了解当前在执行哪条命令，所以通常只在注释和纯显示的echo命令前面加上@。 \n\n4. 模式匹配\n\n   Make命令允许对文件名，进行类似正则运算的匹配，主要用到的匹配符是%。比如，假定当前目录下有 f1.c 和 f2.c 两个源码文件，需要将它们编译为对应的对象文件。 \n\n   ```\n   %.o: %.c\n   ```\n\n   等同于\n\n   ```\n   f1.o: f1.c\n   f2.o: f2.c\n   ```\n\n   使用匹配符%，可以将大量同类型的文件，只用一条规则就完成构建。 \n\n5. 变量和赋值符\n\n   Makefile 允许使用等号自定义变量。 \n\n   ```\n   txt = Hello World\n   test:\n       @echo $(txt)\n   ```\n\n   上面代码中，变量 txt 等于 Hello World。调用时，变量需要放在 $( ) 之中 \n\n   调用Shell变量，需要在美元符号前，再加一个美元符号，这是因为Make命令会对美元符号转义。 \n\n6. 内置变量\n\n   Make命令提供一系列内置变量，比如，$(CC) 指向当前使用的编译器，$(MAKE) 指向当前使用的Make工具。这主要是为了跨平台的兼容性 gmake、cmake、dmake等等。\n\n   $(AR) ：函数库打包程序,将对应的gcc编译出来的obj文件打包成静态链接库程序。\n\n   ar可以集合许多文件，成为单一的备存文件。在备存文件中，所有成员文件皆保有原来的属性与权限。\n\n7. 自动变量\n\n   1. $@指代当前目标，就是Make命令当前构建的那个目标  target\n\n   2. $<指代第一个前置条件。比如，规则为 t: p1 p2，那么$< 就指代p1 \n\n   3. $？指代比目标更新的所有前置条件，之间以空格分隔。比如，规则为 t: p1 p2，其中 p2 的时间戳比 t 新，$?就指代p2。 \n\n   4. $^指代所有前置条件，之间以空格分隔。比如，规则为 t: p1 p2，那么 $^ 就指代 p1 p2 。 \n\n   5. $*指代匹配符 % 匹配的部分， 比如% 匹配 f1.txt 中的f1 ，$* 就表示 f1。 \n\n   6. $(@D) 和 $(@F)$(@D) 和 $(@F) 分别指向 $@ 的目录名和文件名。比如，$@是 src/input.c，那么$(@D) 的值为 src ，$(@F) 的值为 input.c。 \n\n   7. $(<D) 和 $(<F)\n\n      $(<D) 和 $(<F) 分别指向 $< 的目录名和文件名。\n\n8. 其他\n\n   1. `.DEFAULT：`表示找不到匹配规则时，就执行该recipe。  \n\n      ```\n      default:all\n      .DEFAULT:\n      \tcommands\n      ```\n\n      这里当执行`make default` 时会转到`make all` 因为default：all 这个target没有隐式规则。所以最后会执行commands。\n\n   2. 忽略命令的出错，可以在Makefile的命令行前加一个减号\"-\"(在Tab键之后)，标记为不管命令出不出错都认为是成功的。如：     \n\n      ```\n      clean:        \n      \t-(rm -f *.o )\n      ```\n\n   3. `include filename` 将filename中的内容导入，如果找不到会停止make， `-include filename` 则不会停止make。 \n\n## 几种等号\n\n= 是最基本的赋值\n:= 是覆盖之前的值\n?= 是如果没有被赋值过就赋予等号后面的值\n+= 是添加等号后面的值\n\n=与:= 的区别\n\n =：make会将整个makefile展开后，再决定变量的值。也就是说，变量的值将会是整个makefile中最后被指定的值。例子为：\n\n```makefile\n     x = foo\n     y = $(x) bar\n     x = xyz\n```\n\ny的值将会是 xyz bar ，而不是 foo bar 。因为展开后最终变成的是xyz\n\n:=表示变量的值决定于它在makefile中的位置，而不是整个makefile展开后的最终值。\n\n```makefile\n x := foo\n y := $(x) bar\n x := xyz\n```\n\ny的值将会是 foo bar ，而不是 xyz bar 了。\n\n## 参考资料：\n\n1. http://www.ruanyifeng.com/blog/2015/02/make.html\n2. https://gist.github.com/isaacs/62a2d1825d04437c6f08 makefile文件教程\n3. https://www.gnu.org/software/make/manual/make.html GNUmake手册\n4. <https://blog.csdn.net/shouso888/article/details/7226030> 等号解释\n\n","slug":"make学习","published":1,"updated":"2019-11-08T13:13:13.283Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2yelxhw001tm8tz5ap31aou","content":"<h1 id=\"make学习\"><a href=\"#make学习\" class=\"headerlink\" title=\"make学习\"></a>make学习</h1><p>开始阅读redis源码，都说redis很简单，源码不多。但是源码包下载下来后却发现不知道从何处入手，有那么多文件和源码。后面查找资料才发现阅读源码的第一步就是阅读Makefile，项目如何构建和源码间的关联都写在了Makefile文件中。之前没有接触过Makefile，记录下Make的学习。</p>\n<a id=\"more\"></a>\n<h2 id=\"makefile的格式\"><a href=\"#makefile的格式\" class=\"headerlink\" title=\"makefile的格式\"></a>makefile的格式</h2><ol>\n<li><p>概述</p>\n<p>makefile 文件由一系列rules组成 rules的格式为：</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;target&gt; : &lt;prerequisites&gt; </span><br><span class=\"line\">[tab]  &lt;commands&gt;</span><br></pre></td></tr></table></figure>\n<p>​    “目标”是必需的，不可省略；”前置条件”和”命令”都是可选的，但是两者之中必须至少存在一个。 </p>\n<p>​    每条规则就明确两件事：构建目标的前置条件是什么，以及如何构建。 </p>\n<ol>\n<li><p>target</p>\n<p>一个目标（target）就构成一条规则。目标通常是文件名，指明Make命令所要构建的对象，比如上文的 a.txt 目标可以是一个文件名，也可以是多个文件名，之间用空格分隔。（make的时候指定文件名从而对该文件进行构建build）</p>\n<p>除了文件名，目标还可以是某个操作的名字，这称为”伪目标”（phony target）。伪目标不生成文件，只执行命令。</p>\n<p>比如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">clean:</span><br><span class=\"line\">      rm *.o</span><br></pre></td></tr></table></figure>\n<p>此时执行<code>make clean</code> 命令则会进行<code>rm *.o</code> 的操作。</p>\n<p>但是当存在clean这个文件时，那么这个命令不会执行。因为Make发现clean文件已经存在，就认为没有必要重新构建了，就不会执行指定的rm命令。</p>\n<p>为了避免这种情况，可以明确声明clean是”伪目标”，写法如下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.PHONY: clean</span><br><span class=\"line\">clean:</span><br><span class=\"line\">        rm *.o temp</span><br></pre></td></tr></table></figure>\n<p>如果Make命令运行时没有指定目标，默认会执行Makefile文件的第一个目标。 </p>\n</li>\n<li><p>prerequisites</p>\n<p>前置条件通常是一组文件名，之间用空格分隔。它指定了”目标”是否重新构建的判断标准：只要有一个前置文件不存在，或者有过更新（前置文件的last-modification时间戳比目标的时间戳新），”目标”就需要重新构建。 </p>\n<p>没有前置条件，就意味着它跟其他文件都无关，只要这个target文件还不存在 就需要执行命令构建</p>\n<p>如果需要生成多个文件，往往采用下面的写法。 </p>\n<p><code>source: file1 file2 file3</code>  </p>\n<p>无需加上命令，当三个文件不存在时，执行<code>make source</code>就会生成这三个文件。</p>\n</li>\n<li><p>commands</p>\n<p>命令（commands）表示如何更新目标文件，由一行或多行的Shell命令组成。它是构建”目标”的具体指令，它的运行结果通常就是生成目标文件。 </p>\n<p>每行命令之前必须有一个tab键 </p>\n<p>需要注意的是，每行命令在一个单独的shell中执行。这些Shell之间没有继承关系。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var-lost:</span><br><span class=\"line\">    export foo=bar</span><br><span class=\"line\">    echo &quot;foo=[$$foo]&quot;</span><br></pre></td></tr></table></figure>\n<p>上面代码执行后（<code>make var-lost</code>），取不到foo的值。因为两行命令在两个不同的进程执行。 </p>\n<p>解决办法：</p>\n<ol>\n<li><p>命令写在同1行</p>\n</li>\n<li><p>换行符前加反斜杠转义</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var-kept:</span><br><span class=\"line\">    export foo=bar; \\</span><br><span class=\"line\">    echo &quot;foo=[$$foo]&quot;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>加上<code>.ONESHELL:</code>命令 </li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.ONESHELL:</span><br><span class=\"line\">var-kept:</span><br><span class=\"line\">    export foo=bar; </span><br><span class=\"line\">    echo &quot;foo=[$$foo]&quot;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"makefile的语法\"><a href=\"#makefile的语法\" class=\"headerlink\" title=\"makefile的语法\"></a>makefile的语法</h2><ol>\n<li><p>注释</p>\n<p>井号（#）在Makefile中表示注释。 </p>\n</li>\n<li><p>回声（echoing）</p>\n<p>正常情况下，make会打印每条命令，然后再执行，这就叫做回声（echoing）。</p>\n<p>在命令的前面加上@，就可以关闭回声。 </p>\n<p>由于在构建过程中，需要了解当前在执行哪条命令，所以通常只在注释和纯显示的echo命令前面加上@。 </p>\n</li>\n<li><p>通配符</p>\n<p>由于在构建过程中，需要了解当前在执行哪条命令，所以通常只在注释和纯显示的echo命令前面加上@。 </p>\n</li>\n<li><p>模式匹配</p>\n<p>Make命令允许对文件名，进行类似正则运算的匹配，主要用到的匹配符是%。比如，假定当前目录下有 f1.c 和 f2.c 两个源码文件，需要将它们编译为对应的对象文件。 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">%.o: %.c</span><br></pre></td></tr></table></figure>\n<p>等同于</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f1.o: f1.c</span><br><span class=\"line\">f2.o: f2.c</span><br></pre></td></tr></table></figure>\n<p>使用匹配符%，可以将大量同类型的文件，只用一条规则就完成构建。 </p>\n</li>\n<li><p>变量和赋值符</p>\n<p>Makefile 允许使用等号自定义变量。 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">txt = Hello World</span><br><span class=\"line\">test:</span><br><span class=\"line\">    @echo $(txt)</span><br></pre></td></tr></table></figure>\n<p>上面代码中，变量 txt 等于 Hello World。调用时，变量需要放在 $( ) 之中 </p>\n<p>调用Shell变量，需要在美元符号前，再加一个美元符号，这是因为Make命令会对美元符号转义。 </p>\n</li>\n<li><p>内置变量</p>\n<p>Make命令提供一系列内置变量，比如，$(CC) 指向当前使用的编译器，$(MAKE) 指向当前使用的Make工具。这主要是为了跨平台的兼容性 gmake、cmake、dmake等等。</p>\n<p>$(AR) ：函数库打包程序,将对应的gcc编译出来的obj文件打包成静态链接库程序。</p>\n<p>ar可以集合许多文件，成为单一的备存文件。在备存文件中，所有成员文件皆保有原来的属性与权限。</p>\n</li>\n<li><p>自动变量</p>\n<ol>\n<li><p>$@指代当前目标，就是Make命令当前构建的那个目标  target</p>\n</li>\n<li><p>$&lt;指代第一个前置条件。比如，规则为 t: p1 p2，那么$&lt; 就指代p1 </p>\n</li>\n<li><p>$？指代比目标更新的所有前置条件，之间以空格分隔。比如，规则为 t: p1 p2，其中 p2 的时间戳比 t 新，$?就指代p2。 </p>\n</li>\n<li><p>$^指代所有前置条件，之间以空格分隔。比如，规则为 t: p1 p2，那么 $^ 就指代 p1 p2 。 </p>\n</li>\n<li><p>$<em>指代匹配符 % 匹配的部分， 比如% 匹配 f1.txt 中的f1 ，$</em> 就表示 f1。 </p>\n</li>\n<li><p>$(@D) 和 $(@F)$(@D) 和 $(@F) 分别指向 $@ 的目录名和文件名。比如，$@是 src/input.c，那么$(@D) 的值为 src ，$(@F) 的值为 input.c。 </p>\n</li>\n<li><p>$(&lt;D) 和 $(&lt;F)</p>\n<p>$(&lt;D) 和 $(&lt;F) 分别指向 $&lt; 的目录名和文件名。</p>\n</li>\n</ol>\n</li>\n<li><p>其他</p>\n<ol>\n<li><p><code>.DEFAULT：</code>表示找不到匹配规则时，就执行该recipe。  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">default:all</span><br><span class=\"line\">.DEFAULT:</span><br><span class=\"line\">\tcommands</span><br></pre></td></tr></table></figure>\n<p>这里当执行<code>make default</code> 时会转到<code>make all</code> 因为default：all 这个target没有隐式规则。所以最后会执行commands。</p>\n</li>\n<li><p>忽略命令的出错，可以在Makefile的命令行前加一个减号”-“(在Tab键之后)，标记为不管命令出不出错都认为是成功的。如：     </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">clean:        </span><br><span class=\"line\">\t-(rm -f *.o )</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>include filename</code> 将filename中的内容导入，如果找不到会停止make， <code>-include filename</code> 则不会停止make。 </p>\n</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"几种等号\"><a href=\"#几种等号\" class=\"headerlink\" title=\"几种等号\"></a>几种等号</h2><p>= 是最基本的赋值<br>:= 是覆盖之前的值<br>?= 是如果没有被赋值过就赋予等号后面的值<br>+= 是添加等号后面的值</p>\n<p>=与:= 的区别</p>\n<p> =：make会将整个makefile展开后，再决定变量的值。也就是说，变量的值将会是整个makefile中最后被指定的值。例子为：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = foo</span><br><span class=\"line\">y = <span class=\"variable\">$(x)</span> bar</span><br><span class=\"line\">x = xyz</span><br></pre></td></tr></table></figure>\n<p>y的值将会是 xyz bar ，而不是 foo bar 。因为展开后最终变成的是xyz</p>\n<p>:=表示变量的值决定于它在makefile中的位置，而不是整个makefile展开后的最终值。</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x := foo</span><br><span class=\"line\">y := <span class=\"variable\">$(x)</span> bar</span><br><span class=\"line\">x := xyz</span><br></pre></td></tr></table></figure>\n<p>y的值将会是 foo bar ，而不是 xyz bar 了。</p>\n<h2 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h2><ol>\n<li><a href=\"http://www.ruanyifeng.com/blog/2015/02/make.html\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2015/02/make.html</a></li>\n<li><a href=\"https://gist.github.com/isaacs/62a2d1825d04437c6f08\" target=\"_blank\" rel=\"noopener\">https://gist.github.com/isaacs/62a2d1825d04437c6f08</a> makefile文件教程</li>\n<li><a href=\"https://www.gnu.org/software/make/manual/make.html\" target=\"_blank\" rel=\"noopener\">https://www.gnu.org/software/make/manual/make.html</a> GNUmake手册</li>\n<li><a href=\"https://blog.csdn.net/shouso888/article/details/7226030\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/shouso888/article/details/7226030</a> 等号解释</li>\n</ol>\n","site":{"data":{}},"length":3190,"excerpt":"<h1 id=\"make学习\"><a href=\"#make学习\" class=\"headerlink\" title=\"make学习\"></a>make学习</h1><p>开始阅读redis源码，都说redis很简单，源码不多。但是源码包下载下来后却发现不知道从何处入手，有那么多文件和源码。后面查找资料才发现阅读源码的第一步就是阅读Makefile，项目如何构建和源码间的关联都写在了Makefile文件中。之前没有接触过Makefile，记录下Make的学习。</p>","more":"<h2 id=\"makefile的格式\"><a href=\"#makefile的格式\" class=\"headerlink\" title=\"makefile的格式\"></a>makefile的格式</h2><ol>\n<li><p>概述</p>\n<p>makefile 文件由一系列rules组成 rules的格式为：</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;target&gt; : &lt;prerequisites&gt; </span><br><span class=\"line\">[tab]  &lt;commands&gt;</span><br></pre></td></tr></table></figure>\n<p>​    “目标”是必需的，不可省略；”前置条件”和”命令”都是可选的，但是两者之中必须至少存在一个。 </p>\n<p>​    每条规则就明确两件事：构建目标的前置条件是什么，以及如何构建。 </p>\n<ol>\n<li><p>target</p>\n<p>一个目标（target）就构成一条规则。目标通常是文件名，指明Make命令所要构建的对象，比如上文的 a.txt 目标可以是一个文件名，也可以是多个文件名，之间用空格分隔。（make的时候指定文件名从而对该文件进行构建build）</p>\n<p>除了文件名，目标还可以是某个操作的名字，这称为”伪目标”（phony target）。伪目标不生成文件，只执行命令。</p>\n<p>比如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">clean:</span><br><span class=\"line\">      rm *.o</span><br></pre></td></tr></table></figure>\n<p>此时执行<code>make clean</code> 命令则会进行<code>rm *.o</code> 的操作。</p>\n<p>但是当存在clean这个文件时，那么这个命令不会执行。因为Make发现clean文件已经存在，就认为没有必要重新构建了，就不会执行指定的rm命令。</p>\n<p>为了避免这种情况，可以明确声明clean是”伪目标”，写法如下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.PHONY: clean</span><br><span class=\"line\">clean:</span><br><span class=\"line\">        rm *.o temp</span><br></pre></td></tr></table></figure>\n<p>如果Make命令运行时没有指定目标，默认会执行Makefile文件的第一个目标。 </p>\n</li>\n<li><p>prerequisites</p>\n<p>前置条件通常是一组文件名，之间用空格分隔。它指定了”目标”是否重新构建的判断标准：只要有一个前置文件不存在，或者有过更新（前置文件的last-modification时间戳比目标的时间戳新），”目标”就需要重新构建。 </p>\n<p>没有前置条件，就意味着它跟其他文件都无关，只要这个target文件还不存在 就需要执行命令构建</p>\n<p>如果需要生成多个文件，往往采用下面的写法。 </p>\n<p><code>source: file1 file2 file3</code>  </p>\n<p>无需加上命令，当三个文件不存在时，执行<code>make source</code>就会生成这三个文件。</p>\n</li>\n<li><p>commands</p>\n<p>命令（commands）表示如何更新目标文件，由一行或多行的Shell命令组成。它是构建”目标”的具体指令，它的运行结果通常就是生成目标文件。 </p>\n<p>每行命令之前必须有一个tab键 </p>\n<p>需要注意的是，每行命令在一个单独的shell中执行。这些Shell之间没有继承关系。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var-lost:</span><br><span class=\"line\">    export foo=bar</span><br><span class=\"line\">    echo &quot;foo=[$$foo]&quot;</span><br></pre></td></tr></table></figure>\n<p>上面代码执行后（<code>make var-lost</code>），取不到foo的值。因为两行命令在两个不同的进程执行。 </p>\n<p>解决办法：</p>\n<ol>\n<li><p>命令写在同1行</p>\n</li>\n<li><p>换行符前加反斜杠转义</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var-kept:</span><br><span class=\"line\">    export foo=bar; \\</span><br><span class=\"line\">    echo &quot;foo=[$$foo]&quot;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>加上<code>.ONESHELL:</code>命令 </li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.ONESHELL:</span><br><span class=\"line\">var-kept:</span><br><span class=\"line\">    export foo=bar; </span><br><span class=\"line\">    echo &quot;foo=[$$foo]&quot;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"makefile的语法\"><a href=\"#makefile的语法\" class=\"headerlink\" title=\"makefile的语法\"></a>makefile的语法</h2><ol>\n<li><p>注释</p>\n<p>井号（#）在Makefile中表示注释。 </p>\n</li>\n<li><p>回声（echoing）</p>\n<p>正常情况下，make会打印每条命令，然后再执行，这就叫做回声（echoing）。</p>\n<p>在命令的前面加上@，就可以关闭回声。 </p>\n<p>由于在构建过程中，需要了解当前在执行哪条命令，所以通常只在注释和纯显示的echo命令前面加上@。 </p>\n</li>\n<li><p>通配符</p>\n<p>由于在构建过程中，需要了解当前在执行哪条命令，所以通常只在注释和纯显示的echo命令前面加上@。 </p>\n</li>\n<li><p>模式匹配</p>\n<p>Make命令允许对文件名，进行类似正则运算的匹配，主要用到的匹配符是%。比如，假定当前目录下有 f1.c 和 f2.c 两个源码文件，需要将它们编译为对应的对象文件。 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">%.o: %.c</span><br></pre></td></tr></table></figure>\n<p>等同于</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f1.o: f1.c</span><br><span class=\"line\">f2.o: f2.c</span><br></pre></td></tr></table></figure>\n<p>使用匹配符%，可以将大量同类型的文件，只用一条规则就完成构建。 </p>\n</li>\n<li><p>变量和赋值符</p>\n<p>Makefile 允许使用等号自定义变量。 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">txt = Hello World</span><br><span class=\"line\">test:</span><br><span class=\"line\">    @echo $(txt)</span><br></pre></td></tr></table></figure>\n<p>上面代码中，变量 txt 等于 Hello World。调用时，变量需要放在 $( ) 之中 </p>\n<p>调用Shell变量，需要在美元符号前，再加一个美元符号，这是因为Make命令会对美元符号转义。 </p>\n</li>\n<li><p>内置变量</p>\n<p>Make命令提供一系列内置变量，比如，$(CC) 指向当前使用的编译器，$(MAKE) 指向当前使用的Make工具。这主要是为了跨平台的兼容性 gmake、cmake、dmake等等。</p>\n<p>$(AR) ：函数库打包程序,将对应的gcc编译出来的obj文件打包成静态链接库程序。</p>\n<p>ar可以集合许多文件，成为单一的备存文件。在备存文件中，所有成员文件皆保有原来的属性与权限。</p>\n</li>\n<li><p>自动变量</p>\n<ol>\n<li><p>$@指代当前目标，就是Make命令当前构建的那个目标  target</p>\n</li>\n<li><p>$&lt;指代第一个前置条件。比如，规则为 t: p1 p2，那么$&lt; 就指代p1 </p>\n</li>\n<li><p>$？指代比目标更新的所有前置条件，之间以空格分隔。比如，规则为 t: p1 p2，其中 p2 的时间戳比 t 新，$?就指代p2。 </p>\n</li>\n<li><p>$^指代所有前置条件，之间以空格分隔。比如，规则为 t: p1 p2，那么 $^ 就指代 p1 p2 。 </p>\n</li>\n<li><p>$<em>指代匹配符 % 匹配的部分， 比如% 匹配 f1.txt 中的f1 ，$</em> 就表示 f1。 </p>\n</li>\n<li><p>$(@D) 和 $(@F)$(@D) 和 $(@F) 分别指向 $@ 的目录名和文件名。比如，$@是 src/input.c，那么$(@D) 的值为 src ，$(@F) 的值为 input.c。 </p>\n</li>\n<li><p>$(&lt;D) 和 $(&lt;F)</p>\n<p>$(&lt;D) 和 $(&lt;F) 分别指向 $&lt; 的目录名和文件名。</p>\n</li>\n</ol>\n</li>\n<li><p>其他</p>\n<ol>\n<li><p><code>.DEFAULT：</code>表示找不到匹配规则时，就执行该recipe。  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">default:all</span><br><span class=\"line\">.DEFAULT:</span><br><span class=\"line\">\tcommands</span><br></pre></td></tr></table></figure>\n<p>这里当执行<code>make default</code> 时会转到<code>make all</code> 因为default：all 这个target没有隐式规则。所以最后会执行commands。</p>\n</li>\n<li><p>忽略命令的出错，可以在Makefile的命令行前加一个减号”-“(在Tab键之后)，标记为不管命令出不出错都认为是成功的。如：     </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">clean:        </span><br><span class=\"line\">\t-(rm -f *.o )</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>include filename</code> 将filename中的内容导入，如果找不到会停止make， <code>-include filename</code> 则不会停止make。 </p>\n</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"几种等号\"><a href=\"#几种等号\" class=\"headerlink\" title=\"几种等号\"></a>几种等号</h2><p>= 是最基本的赋值<br>:= 是覆盖之前的值<br>?= 是如果没有被赋值过就赋予等号后面的值<br>+= 是添加等号后面的值</p>\n<p>=与:= 的区别</p>\n<p> =：make会将整个makefile展开后，再决定变量的值。也就是说，变量的值将会是整个makefile中最后被指定的值。例子为：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = foo</span><br><span class=\"line\">y = <span class=\"variable\">$(x)</span> bar</span><br><span class=\"line\">x = xyz</span><br></pre></td></tr></table></figure>\n<p>y的值将会是 xyz bar ，而不是 foo bar 。因为展开后最终变成的是xyz</p>\n<p>:=表示变量的值决定于它在makefile中的位置，而不是整个makefile展开后的最终值。</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x := foo</span><br><span class=\"line\">y := <span class=\"variable\">$(x)</span> bar</span><br><span class=\"line\">x := xyz</span><br></pre></td></tr></table></figure>\n<p>y的值将会是 foo bar ，而不是 xyz bar 了。</p>\n<h2 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h2><ol>\n<li><a href=\"http://www.ruanyifeng.com/blog/2015/02/make.html\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2015/02/make.html</a></li>\n<li><a href=\"https://gist.github.com/isaacs/62a2d1825d04437c6f08\" target=\"_blank\" rel=\"noopener\">https://gist.github.com/isaacs/62a2d1825d04437c6f08</a> makefile文件教程</li>\n<li><a href=\"https://www.gnu.org/software/make/manual/make.html\" target=\"_blank\" rel=\"noopener\">https://www.gnu.org/software/make/manual/make.html</a> GNUmake手册</li>\n<li><a href=\"https://blog.csdn.net/shouso888/article/details/7226030\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/shouso888/article/details/7226030</a> 等号解释</li>\n</ol>"},{"title":"ceph 部署文档","date":"2018-04-17T09:36:03.000Z","copyright":true,"_content":"\n# ceph 部署文档\n\n<!--more-->\n\n------\n\n# 1.配置所有节点\n\n## 创建ceph用户\n\n## 安装配置NTP\n\n1. `systemctl enable ntp`  ubuntu 14.04不可用，感觉已经安装过了，因此跳过。\n\n## 配置hosts文件\n\n`172.16.1.93 object1`\n`172.16.1.94 object2`\n`172.16.1.95 object3`\n`172.16.1.66 object4`\n`172.16.1.92 controller`\n\n------\n\n# 2. 配置ssh服务器\n\n修改ssh的配置文件\n\nHost controller\n        Hostname gd92\n        User cephuser\nHost object1\n        Hostname gd93\n        User cephuser\nHost object2\n        Hostname hw101\n        User cephuser\nHost object3\n        Hostname gd95\n        User cephuser\nHost object4\n        Hostname gd66\n        User cephuser\n\n生成密钥并拷贝到4个osd节点上，无需拷贝到controller节点\n\n------\n\n# 3.安装ceph\n\n主要参考链接：这些链接的操作大都一致，部分的顺序会有变化。\n\nhttps://linux.cn/article-8182-1.html#4_10238\n\nhttps://blog.csdn.net/styshoo/article/details/55471132\n\nhttps://blog.csdn.net/styshoo/article/details/58572816\n\n## 部署监控节点出现的问题\n\n`ceph-deploy mon create-initial`\n\n1. ` ceph-mon --cluster ceph --mkfs -i gd92 --keyring /var/lib/ceph/tmp/ceph-gd92.mon.keyring`\n\n   问题：ceph.conf的配置文件中的`public network=172.16.1.92/24` 掩码前面多打了空格\n\n   修改后重新执行命令，并加上`--overwrite-conf` \n\n2. [info]Running command: ceph --cluster=ceph --admin-daemon /var/run/ceph/ceph-mon.controller.asok mon_status\n\n   `admin_socket: exception getting command descriptions: [Errno 2] No such file or directory`\n\n   似乎是ceph -deploy 的问题，或者是ubuntu14.04的问题。教程是ubuntu16.04的\n\n   此问题非hostname 不对应\n\n   非conf 不同步导致。--overwrtie-conf  无作用。\n\n   解决办法：按照14.04方法重新安装ceph-deploy\n\n## 部署osd节点出现的问题\n\n1. 使用`ceph-deploy disk list ceph-osd1 ceph-osd2 ceph-osd3`检查磁盘可用性时报错，使用`ceph-deploy osd prepare ceph-osd1:/dev/sdb ceph-osd2:/dev/sdb ceph-osd3:/dev/sdb` 在数据盘上面准备时也报错\n   Running command: fdisk -l  File \"/usr/lib/python2.7/distpackages/ceph_deploy/util/decorators.py\", line 69, in newfunc \n   问题：未知\n   解决办法：将osd节点的数据目录放在指定目录，不用整个数据盘\n2. 最后部署后集群状况是health -ok，但是4osds，有3个osd up，一个osd down\n   问题：down掉的节点磁盘有问题。\n   解决办法：先卸载磁盘，重新格式化，挂载，重新激活osd节点\n\n## 部署rgw节点出现的问题\n\n1. 显示rgw进程在工作，但是使用：http://controller:7480 显示拒绝连接。并且新建S3账号，测试时未返回正确结果。\n\n   问题：未知\n\n   尝试方法：重新部署\n\n   解决办法：重新部署后最开始将端口设置为80，发现可以创建s3账号，但是无法正确测试，显示创建bucket出错，查看rgw的log，发现端口被占用，无法打开，后面重新设置端口为7480问题解决，测试均正确。","source":"_posts/ceph部署文档.md","raw":"---\ntitle: ceph 部署文档\ndate: 2018-04-17 17:36:03\ncategories: deploy\ntags: ceph\ncopyright: true\n---\n\n# ceph 部署文档\n\n<!--more-->\n\n------\n\n# 1.配置所有节点\n\n## 创建ceph用户\n\n## 安装配置NTP\n\n1. `systemctl enable ntp`  ubuntu 14.04不可用，感觉已经安装过了，因此跳过。\n\n## 配置hosts文件\n\n`172.16.1.93 object1`\n`172.16.1.94 object2`\n`172.16.1.95 object3`\n`172.16.1.66 object4`\n`172.16.1.92 controller`\n\n------\n\n# 2. 配置ssh服务器\n\n修改ssh的配置文件\n\nHost controller\n        Hostname gd92\n        User cephuser\nHost object1\n        Hostname gd93\n        User cephuser\nHost object2\n        Hostname hw101\n        User cephuser\nHost object3\n        Hostname gd95\n        User cephuser\nHost object4\n        Hostname gd66\n        User cephuser\n\n生成密钥并拷贝到4个osd节点上，无需拷贝到controller节点\n\n------\n\n# 3.安装ceph\n\n主要参考链接：这些链接的操作大都一致，部分的顺序会有变化。\n\nhttps://linux.cn/article-8182-1.html#4_10238\n\nhttps://blog.csdn.net/styshoo/article/details/55471132\n\nhttps://blog.csdn.net/styshoo/article/details/58572816\n\n## 部署监控节点出现的问题\n\n`ceph-deploy mon create-initial`\n\n1. ` ceph-mon --cluster ceph --mkfs -i gd92 --keyring /var/lib/ceph/tmp/ceph-gd92.mon.keyring`\n\n   问题：ceph.conf的配置文件中的`public network=172.16.1.92/24` 掩码前面多打了空格\n\n   修改后重新执行命令，并加上`--overwrite-conf` \n\n2. [info]Running command: ceph --cluster=ceph --admin-daemon /var/run/ceph/ceph-mon.controller.asok mon_status\n\n   `admin_socket: exception getting command descriptions: [Errno 2] No such file or directory`\n\n   似乎是ceph -deploy 的问题，或者是ubuntu14.04的问题。教程是ubuntu16.04的\n\n   此问题非hostname 不对应\n\n   非conf 不同步导致。--overwrtie-conf  无作用。\n\n   解决办法：按照14.04方法重新安装ceph-deploy\n\n## 部署osd节点出现的问题\n\n1. 使用`ceph-deploy disk list ceph-osd1 ceph-osd2 ceph-osd3`检查磁盘可用性时报错，使用`ceph-deploy osd prepare ceph-osd1:/dev/sdb ceph-osd2:/dev/sdb ceph-osd3:/dev/sdb` 在数据盘上面准备时也报错\n   Running command: fdisk -l  File \"/usr/lib/python2.7/distpackages/ceph_deploy/util/decorators.py\", line 69, in newfunc \n   问题：未知\n   解决办法：将osd节点的数据目录放在指定目录，不用整个数据盘\n2. 最后部署后集群状况是health -ok，但是4osds，有3个osd up，一个osd down\n   问题：down掉的节点磁盘有问题。\n   解决办法：先卸载磁盘，重新格式化，挂载，重新激活osd节点\n\n## 部署rgw节点出现的问题\n\n1. 显示rgw进程在工作，但是使用：http://controller:7480 显示拒绝连接。并且新建S3账号，测试时未返回正确结果。\n\n   问题：未知\n\n   尝试方法：重新部署\n\n   解决办法：重新部署后最开始将端口设置为80，发现可以创建s3账号，但是无法正确测试，显示创建bucket出错，查看rgw的log，发现端口被占用，无法打开，后面重新设置端口为7480问题解决，测试均正确。","slug":"ceph部署文档","published":1,"updated":"2019-11-08T13:11:43.727Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2yelxhx001vm8tz1noojzfk","content":"<h1 id=\"ceph-部署文档\"><a href=\"#ceph-部署文档\" class=\"headerlink\" title=\"ceph 部署文档\"></a>ceph 部署文档</h1><a id=\"more\"></a>\n<hr>\n<h1 id=\"1-配置所有节点\"><a href=\"#1-配置所有节点\" class=\"headerlink\" title=\"1.配置所有节点\"></a>1.配置所有节点</h1><h2 id=\"创建ceph用户\"><a href=\"#创建ceph用户\" class=\"headerlink\" title=\"创建ceph用户\"></a>创建ceph用户</h2><h2 id=\"安装配置NTP\"><a href=\"#安装配置NTP\" class=\"headerlink\" title=\"安装配置NTP\"></a>安装配置NTP</h2><ol>\n<li><code>systemctl enable ntp</code>  ubuntu 14.04不可用，感觉已经安装过了，因此跳过。</li>\n</ol>\n<h2 id=\"配置hosts文件\"><a href=\"#配置hosts文件\" class=\"headerlink\" title=\"配置hosts文件\"></a>配置hosts文件</h2><p><code>172.16.1.93 object1</code><br><code>172.16.1.94 object2</code><br><code>172.16.1.95 object3</code><br><code>172.16.1.66 object4</code><br><code>172.16.1.92 controller</code></p>\n<hr>\n<h1 id=\"2-配置ssh服务器\"><a href=\"#2-配置ssh服务器\" class=\"headerlink\" title=\"2. 配置ssh服务器\"></a>2. 配置ssh服务器</h1><p>修改ssh的配置文件</p>\n<p>Host controller<br>        Hostname gd92<br>        User cephuser<br>Host object1<br>        Hostname gd93<br>        User cephuser<br>Host object2<br>        Hostname hw101<br>        User cephuser<br>Host object3<br>        Hostname gd95<br>        User cephuser<br>Host object4<br>        Hostname gd66<br>        User cephuser</p>\n<p>生成密钥并拷贝到4个osd节点上，无需拷贝到controller节点</p>\n<hr>\n<h1 id=\"3-安装ceph\"><a href=\"#3-安装ceph\" class=\"headerlink\" title=\"3.安装ceph\"></a>3.安装ceph</h1><p>主要参考链接：这些链接的操作大都一致，部分的顺序会有变化。</p>\n<p><a href=\"https://linux.cn/article-8182-1.html#4_10238\" target=\"_blank\" rel=\"noopener\">https://linux.cn/article-8182-1.html#4_10238</a></p>\n<p><a href=\"https://blog.csdn.net/styshoo/article/details/55471132\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/styshoo/article/details/55471132</a></p>\n<p><a href=\"https://blog.csdn.net/styshoo/article/details/58572816\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/styshoo/article/details/58572816</a></p>\n<h2 id=\"部署监控节点出现的问题\"><a href=\"#部署监控节点出现的问题\" class=\"headerlink\" title=\"部署监控节点出现的问题\"></a>部署监控节点出现的问题</h2><p><code>ceph-deploy mon create-initial</code></p>\n<ol>\n<li><p><code>ceph-mon --cluster ceph --mkfs -i gd92 --keyring /var/lib/ceph/tmp/ceph-gd92.mon.keyring</code></p>\n<p>问题：ceph.conf的配置文件中的<code>public network=172.16.1.92/24</code> 掩码前面多打了空格</p>\n<p>修改后重新执行命令，并加上<code>--overwrite-conf</code> </p>\n</li>\n<li><p>[info]Running command: ceph —cluster=ceph —admin-daemon /var/run/ceph/ceph-mon.controller.asok mon_status</p>\n<p><code>admin_socket: exception getting command descriptions: [Errno 2] No such file or directory</code></p>\n<p>似乎是ceph -deploy 的问题，或者是ubuntu14.04的问题。教程是ubuntu16.04的</p>\n<p>此问题非hostname 不对应</p>\n<p>非conf 不同步导致。—overwrtie-conf  无作用。</p>\n<p>解决办法：按照14.04方法重新安装ceph-deploy</p>\n</li>\n</ol>\n<h2 id=\"部署osd节点出现的问题\"><a href=\"#部署osd节点出现的问题\" class=\"headerlink\" title=\"部署osd节点出现的问题\"></a>部署osd节点出现的问题</h2><ol>\n<li>使用<code>ceph-deploy disk list ceph-osd1 ceph-osd2 ceph-osd3</code>检查磁盘可用性时报错，使用<code>ceph-deploy osd prepare ceph-osd1:/dev/sdb ceph-osd2:/dev/sdb ceph-osd3:/dev/sdb</code> 在数据盘上面准备时也报错<br>Running command: fdisk -l  File “/usr/lib/python2.7/distpackages/ceph_deploy/util/decorators.py”, line 69, in newfunc<br>问题：未知<br>解决办法：将osd节点的数据目录放在指定目录，不用整个数据盘</li>\n<li>最后部署后集群状况是health -ok，但是4osds，有3个osd up，一个osd down<br>问题：down掉的节点磁盘有问题。<br>解决办法：先卸载磁盘，重新格式化，挂载，重新激活osd节点</li>\n</ol>\n<h2 id=\"部署rgw节点出现的问题\"><a href=\"#部署rgw节点出现的问题\" class=\"headerlink\" title=\"部署rgw节点出现的问题\"></a>部署rgw节点出现的问题</h2><ol>\n<li><p>显示rgw进程在工作，但是使用：<a href=\"http://controller:7480\" target=\"_blank\" rel=\"noopener\">http://controller:7480</a> 显示拒绝连接。并且新建S3账号，测试时未返回正确结果。</p>\n<p>问题：未知</p>\n<p>尝试方法：重新部署</p>\n<p>解决办法：重新部署后最开始将端口设置为80，发现可以创建s3账号，但是无法正确测试，显示创建bucket出错，查看rgw的log，发现端口被占用，无法打开，后面重新设置端口为7480问题解决，测试均正确。</p>\n</li>\n</ol>\n","site":{"data":{}},"length":1696,"excerpt":"<h1 id=\"ceph-部署文档\"><a href=\"#ceph-部署文档\" class=\"headerlink\" title=\"ceph 部署文档\"></a>ceph 部署文档</h1>","more":"<hr>\n<h1 id=\"1-配置所有节点\"><a href=\"#1-配置所有节点\" class=\"headerlink\" title=\"1.配置所有节点\"></a>1.配置所有节点</h1><h2 id=\"创建ceph用户\"><a href=\"#创建ceph用户\" class=\"headerlink\" title=\"创建ceph用户\"></a>创建ceph用户</h2><h2 id=\"安装配置NTP\"><a href=\"#安装配置NTP\" class=\"headerlink\" title=\"安装配置NTP\"></a>安装配置NTP</h2><ol>\n<li><code>systemctl enable ntp</code>  ubuntu 14.04不可用，感觉已经安装过了，因此跳过。</li>\n</ol>\n<h2 id=\"配置hosts文件\"><a href=\"#配置hosts文件\" class=\"headerlink\" title=\"配置hosts文件\"></a>配置hosts文件</h2><p><code>172.16.1.93 object1</code><br><code>172.16.1.94 object2</code><br><code>172.16.1.95 object3</code><br><code>172.16.1.66 object4</code><br><code>172.16.1.92 controller</code></p>\n<hr>\n<h1 id=\"2-配置ssh服务器\"><a href=\"#2-配置ssh服务器\" class=\"headerlink\" title=\"2. 配置ssh服务器\"></a>2. 配置ssh服务器</h1><p>修改ssh的配置文件</p>\n<p>Host controller<br>        Hostname gd92<br>        User cephuser<br>Host object1<br>        Hostname gd93<br>        User cephuser<br>Host object2<br>        Hostname hw101<br>        User cephuser<br>Host object3<br>        Hostname gd95<br>        User cephuser<br>Host object4<br>        Hostname gd66<br>        User cephuser</p>\n<p>生成密钥并拷贝到4个osd节点上，无需拷贝到controller节点</p>\n<hr>\n<h1 id=\"3-安装ceph\"><a href=\"#3-安装ceph\" class=\"headerlink\" title=\"3.安装ceph\"></a>3.安装ceph</h1><p>主要参考链接：这些链接的操作大都一致，部分的顺序会有变化。</p>\n<p><a href=\"https://linux.cn/article-8182-1.html#4_10238\" target=\"_blank\" rel=\"noopener\">https://linux.cn/article-8182-1.html#4_10238</a></p>\n<p><a href=\"https://blog.csdn.net/styshoo/article/details/55471132\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/styshoo/article/details/55471132</a></p>\n<p><a href=\"https://blog.csdn.net/styshoo/article/details/58572816\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/styshoo/article/details/58572816</a></p>\n<h2 id=\"部署监控节点出现的问题\"><a href=\"#部署监控节点出现的问题\" class=\"headerlink\" title=\"部署监控节点出现的问题\"></a>部署监控节点出现的问题</h2><p><code>ceph-deploy mon create-initial</code></p>\n<ol>\n<li><p><code>ceph-mon --cluster ceph --mkfs -i gd92 --keyring /var/lib/ceph/tmp/ceph-gd92.mon.keyring</code></p>\n<p>问题：ceph.conf的配置文件中的<code>public network=172.16.1.92/24</code> 掩码前面多打了空格</p>\n<p>修改后重新执行命令，并加上<code>--overwrite-conf</code> </p>\n</li>\n<li><p>[info]Running command: ceph —cluster=ceph —admin-daemon /var/run/ceph/ceph-mon.controller.asok mon_status</p>\n<p><code>admin_socket: exception getting command descriptions: [Errno 2] No such file or directory</code></p>\n<p>似乎是ceph -deploy 的问题，或者是ubuntu14.04的问题。教程是ubuntu16.04的</p>\n<p>此问题非hostname 不对应</p>\n<p>非conf 不同步导致。—overwrtie-conf  无作用。</p>\n<p>解决办法：按照14.04方法重新安装ceph-deploy</p>\n</li>\n</ol>\n<h2 id=\"部署osd节点出现的问题\"><a href=\"#部署osd节点出现的问题\" class=\"headerlink\" title=\"部署osd节点出现的问题\"></a>部署osd节点出现的问题</h2><ol>\n<li>使用<code>ceph-deploy disk list ceph-osd1 ceph-osd2 ceph-osd3</code>检查磁盘可用性时报错，使用<code>ceph-deploy osd prepare ceph-osd1:/dev/sdb ceph-osd2:/dev/sdb ceph-osd3:/dev/sdb</code> 在数据盘上面准备时也报错<br>Running command: fdisk -l  File “/usr/lib/python2.7/distpackages/ceph_deploy/util/decorators.py”, line 69, in newfunc<br>问题：未知<br>解决办法：将osd节点的数据目录放在指定目录，不用整个数据盘</li>\n<li>最后部署后集群状况是health -ok，但是4osds，有3个osd up，一个osd down<br>问题：down掉的节点磁盘有问题。<br>解决办法：先卸载磁盘，重新格式化，挂载，重新激活osd节点</li>\n</ol>\n<h2 id=\"部署rgw节点出现的问题\"><a href=\"#部署rgw节点出现的问题\" class=\"headerlink\" title=\"部署rgw节点出现的问题\"></a>部署rgw节点出现的问题</h2><ol>\n<li><p>显示rgw进程在工作，但是使用：<a href=\"http://controller:7480\" target=\"_blank\" rel=\"noopener\">http://controller:7480</a> 显示拒绝连接。并且新建S3账号，测试时未返回正确结果。</p>\n<p>问题：未知</p>\n<p>尝试方法：重新部署</p>\n<p>解决办法：重新部署后最开始将端口设置为80，发现可以创建s3账号，但是无法正确测试，显示创建bucket出错，查看rgw的log，发现端口被占用，无法打开，后面重新设置端口为7480问题解决，测试均正确。</p>\n</li>\n</ol>"},{"title":"ping 无法连接外网","date":"2019-03-15T05:51:47.000Z","copyright":true,"_content":"\n\n\n## ping 无法连接外网\n\n<!--more-->\n\n### 问题\n\nping外网ping不通\n\n```\nyky@hw076:~/tmux> ping www.baidu.com\nping: unknown host www.baidu.com\nyky@hw076:~/tmux> ping 8.8.8.8\nconnect: Network is unreachable\n```\n\nping内网可以ping通\n\n```\nhw076:~ # ping 172.18.11.114\nPING 172.18.11.114 (172.18.11.114) 56(84) bytes of data.\n64 bytes from 172.18.11.114: icmp_seq=1 ttl=64 time=0.193 ms\n64 bytes from 172.18.11.114: icmp_seq=2 ttl=64 time=0.216 ms\n64 bytes from 172.18.11.114: icmp_seq=3 ttl=64 time=0.207 ms\n64 bytes from 172.18.11.114: icmp_seq=4 ttl=64 time=0.200 ms\n^C\n--- 172.18.11.114 ping statistics ---\n4 packets transmitted, 4 received, 0% packet loss, time 2999ms\nrtt min/avg/max/mdev = 0.193/0.204/0.216/0.008 ms\n\n```\n\nifconfig信息为：\n\n```\nhw076:~ # ifconfig \neth0      Link encap:Ethernet  HWaddr 90:E2:BA:15:C9:C4  \n          inet addr:172.18.11.76  Bcast:192.168.1.255  Mask:255.255.0.0\n          inet6 addr: fe80::92e2:baff:fe15:c9c4/64 Scope:Link\n          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1\n          RX packets:9725797 errors:0 dropped:506 overruns:0 frame:0\n          TX packets:21023 errors:0 dropped:0 overruns:0 carrier:0\n          collisions:0 txqueuelen:1000 \n          RX bytes:598731249 (570.9 Mb)  TX bytes:2767270 (2.6 Mb)\n          Memory:fb480000-fb500000 \n\nlo        Link encap:Local Loopback  \n          inet addr:127.0.0.1  Mask:255.0.0.0\n          inet6 addr: ::1/128 Scope:Host\n          UP LOOPBACK RUNNING  MTU:65536  Metric:1\n          RX packets:276 errors:0 dropped:0 overruns:0 frame:0\n          TX packets:276 errors:0 dropped:0 overruns:0 carrier:0\n          collisions:0 txqueuelen:0 \n          RX bytes:25088 (24.5 Kb)  TX bytes:25088 (24.5 Kb)\n```\n\nroute显示路由信息如下：\n\n```\nhw076:/etc/netconfig.d # route\nKernel IP routing table\nDestination     Gateway         Genmask         Flags Metric Ref    Use Iface\ndefault         *               0.0.0.0         UG    0      0        0 eth0\nloopback        *               255.0.0.0       U     0      0        0 lo\nlink-local      *               255.255.0.0     U     0      0        0 eth0\n172.18.0.0      *               255.255.0.0     U     0      0        0 eth0\n```\n\n原因是route没有配置网关，gateway是空着的。\n\n### 解决方法\n\n通过查看其他可以正常访问的节点的路由信息，得知网关节点为：172.18.0.254。因此增加默认网关节点配置。\n\n执行命令：\n\n```\nroute add default  gw 172.18.0.254\n```\n\n再次查看路由信息：\n\n```\nhw076:~ # route\nKernel IP routing table\nDestination     Gateway         Genmask         Flags Metric Ref    Use Iface\ndefault         172.18.0.254    0.0.0.0         UG    0      0        0 eth0\nloopback        *               255.0.0.0       U     0      0        0 lo\nlink-local      *               255.255.0.0     U     0      0        0 eth0\n172.18.0.0      *               255.255.0.0     U     0      0        0 eth0\n```\n\n再次ping8.8.8.8显示正常，问题解决。","source":"_posts/ping 问题.md","raw":"---\ntitle: ping 无法连接外网\ndate: 2019-03-15 13:51:47\ncategories: Linux\ntags:\n- Linux\n- 运维\n- 网络问题\ncopyright: true\n---\n\n\n\n## ping 无法连接外网\n\n<!--more-->\n\n### 问题\n\nping外网ping不通\n\n```\nyky@hw076:~/tmux> ping www.baidu.com\nping: unknown host www.baidu.com\nyky@hw076:~/tmux> ping 8.8.8.8\nconnect: Network is unreachable\n```\n\nping内网可以ping通\n\n```\nhw076:~ # ping 172.18.11.114\nPING 172.18.11.114 (172.18.11.114) 56(84) bytes of data.\n64 bytes from 172.18.11.114: icmp_seq=1 ttl=64 time=0.193 ms\n64 bytes from 172.18.11.114: icmp_seq=2 ttl=64 time=0.216 ms\n64 bytes from 172.18.11.114: icmp_seq=3 ttl=64 time=0.207 ms\n64 bytes from 172.18.11.114: icmp_seq=4 ttl=64 time=0.200 ms\n^C\n--- 172.18.11.114 ping statistics ---\n4 packets transmitted, 4 received, 0% packet loss, time 2999ms\nrtt min/avg/max/mdev = 0.193/0.204/0.216/0.008 ms\n\n```\n\nifconfig信息为：\n\n```\nhw076:~ # ifconfig \neth0      Link encap:Ethernet  HWaddr 90:E2:BA:15:C9:C4  \n          inet addr:172.18.11.76  Bcast:192.168.1.255  Mask:255.255.0.0\n          inet6 addr: fe80::92e2:baff:fe15:c9c4/64 Scope:Link\n          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1\n          RX packets:9725797 errors:0 dropped:506 overruns:0 frame:0\n          TX packets:21023 errors:0 dropped:0 overruns:0 carrier:0\n          collisions:0 txqueuelen:1000 \n          RX bytes:598731249 (570.9 Mb)  TX bytes:2767270 (2.6 Mb)\n          Memory:fb480000-fb500000 \n\nlo        Link encap:Local Loopback  \n          inet addr:127.0.0.1  Mask:255.0.0.0\n          inet6 addr: ::1/128 Scope:Host\n          UP LOOPBACK RUNNING  MTU:65536  Metric:1\n          RX packets:276 errors:0 dropped:0 overruns:0 frame:0\n          TX packets:276 errors:0 dropped:0 overruns:0 carrier:0\n          collisions:0 txqueuelen:0 \n          RX bytes:25088 (24.5 Kb)  TX bytes:25088 (24.5 Kb)\n```\n\nroute显示路由信息如下：\n\n```\nhw076:/etc/netconfig.d # route\nKernel IP routing table\nDestination     Gateway         Genmask         Flags Metric Ref    Use Iface\ndefault         *               0.0.0.0         UG    0      0        0 eth0\nloopback        *               255.0.0.0       U     0      0        0 lo\nlink-local      *               255.255.0.0     U     0      0        0 eth0\n172.18.0.0      *               255.255.0.0     U     0      0        0 eth0\n```\n\n原因是route没有配置网关，gateway是空着的。\n\n### 解决方法\n\n通过查看其他可以正常访问的节点的路由信息，得知网关节点为：172.18.0.254。因此增加默认网关节点配置。\n\n执行命令：\n\n```\nroute add default  gw 172.18.0.254\n```\n\n再次查看路由信息：\n\n```\nhw076:~ # route\nKernel IP routing table\nDestination     Gateway         Genmask         Flags Metric Ref    Use Iface\ndefault         172.18.0.254    0.0.0.0         UG    0      0        0 eth0\nloopback        *               255.0.0.0       U     0      0        0 lo\nlink-local      *               255.255.0.0     U     0      0        0 eth0\n172.18.0.0      *               255.255.0.0     U     0      0        0 eth0\n```\n\n再次ping8.8.8.8显示正常，问题解决。","slug":"ping 问题","published":1,"updated":"2019-11-08T13:16:22.252Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2yelxhz001zm8tz8jjpyfv1","content":"<h2 id=\"ping-无法连接外网\"><a href=\"#ping-无法连接外网\" class=\"headerlink\" title=\"ping 无法连接外网\"></a>ping 无法连接外网</h2><a id=\"more\"></a>\n<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><p>ping外网ping不通</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yky@hw076:~/tmux&gt; ping www.baidu.com</span><br><span class=\"line\">ping: unknown host www.baidu.com</span><br><span class=\"line\">yky@hw076:~/tmux&gt; ping 8.8.8.8</span><br><span class=\"line\">connect: Network is unreachable</span><br></pre></td></tr></table></figure>\n<p>ping内网可以ping通</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hw076:~ # ping 172.18.11.114</span><br><span class=\"line\">PING 172.18.11.114 (172.18.11.114) 56(84) bytes of data.</span><br><span class=\"line\">64 bytes from 172.18.11.114: icmp_seq=1 ttl=64 time=0.193 ms</span><br><span class=\"line\">64 bytes from 172.18.11.114: icmp_seq=2 ttl=64 time=0.216 ms</span><br><span class=\"line\">64 bytes from 172.18.11.114: icmp_seq=3 ttl=64 time=0.207 ms</span><br><span class=\"line\">64 bytes from 172.18.11.114: icmp_seq=4 ttl=64 time=0.200 ms</span><br><span class=\"line\">^C</span><br><span class=\"line\">--- 172.18.11.114 ping statistics ---</span><br><span class=\"line\">4 packets transmitted, 4 received, 0% packet loss, time 2999ms</span><br><span class=\"line\">rtt min/avg/max/mdev = 0.193/0.204/0.216/0.008 ms</span><br></pre></td></tr></table></figure>\n<p>ifconfig信息为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hw076:~ # ifconfig </span><br><span class=\"line\">eth0      Link encap:Ethernet  HWaddr 90:E2:BA:15:C9:C4  </span><br><span class=\"line\">          inet addr:172.18.11.76  Bcast:192.168.1.255  Mask:255.255.0.0</span><br><span class=\"line\">          inet6 addr: fe80::92e2:baff:fe15:c9c4/64 Scope:Link</span><br><span class=\"line\">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class=\"line\">          RX packets:9725797 errors:0 dropped:506 overruns:0 frame:0</span><br><span class=\"line\">          TX packets:21023 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class=\"line\">          collisions:0 txqueuelen:1000 </span><br><span class=\"line\">          RX bytes:598731249 (570.9 Mb)  TX bytes:2767270 (2.6 Mb)</span><br><span class=\"line\">          Memory:fb480000-fb500000 </span><br><span class=\"line\"></span><br><span class=\"line\">lo        Link encap:Local Loopback  </span><br><span class=\"line\">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class=\"line\">          inet6 addr: ::1/128 Scope:Host</span><br><span class=\"line\">          UP LOOPBACK RUNNING  MTU:65536  Metric:1</span><br><span class=\"line\">          RX packets:276 errors:0 dropped:0 overruns:0 frame:0</span><br><span class=\"line\">          TX packets:276 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class=\"line\">          collisions:0 txqueuelen:0 </span><br><span class=\"line\">          RX bytes:25088 (24.5 Kb)  TX bytes:25088 (24.5 Kb)</span><br></pre></td></tr></table></figure>\n<p>route显示路由信息如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hw076:/etc/netconfig.d # route</span><br><span class=\"line\">Kernel IP routing table</span><br><span class=\"line\">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class=\"line\">default         *               0.0.0.0         UG    0      0        0 eth0</span><br><span class=\"line\">loopback        *               255.0.0.0       U     0      0        0 lo</span><br><span class=\"line\">link-local      *               255.255.0.0     U     0      0        0 eth0</span><br><span class=\"line\">172.18.0.0      *               255.255.0.0     U     0      0        0 eth0</span><br></pre></td></tr></table></figure>\n<p>原因是route没有配置网关，gateway是空着的。</p>\n<h3 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h3><p>通过查看其他可以正常访问的节点的路由信息，得知网关节点为：172.18.0.254。因此增加默认网关节点配置。</p>\n<p>执行命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">route add default  gw 172.18.0.254</span><br></pre></td></tr></table></figure>\n<p>再次查看路由信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hw076:~ # route</span><br><span class=\"line\">Kernel IP routing table</span><br><span class=\"line\">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class=\"line\">default         172.18.0.254    0.0.0.0         UG    0      0        0 eth0</span><br><span class=\"line\">loopback        *               255.0.0.0       U     0      0        0 lo</span><br><span class=\"line\">link-local      *               255.255.0.0     U     0      0        0 eth0</span><br><span class=\"line\">172.18.0.0      *               255.255.0.0     U     0      0        0 eth0</span><br></pre></td></tr></table></figure>\n<p>再次ping8.8.8.8显示正常，问题解决。</p>\n","site":{"data":{}},"length":1912,"excerpt":"<h2 id=\"ping-无法连接外网\"><a href=\"#ping-无法连接外网\" class=\"headerlink\" title=\"ping 无法连接外网\"></a>ping 无法连接外网</h2>","more":"<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><p>ping外网ping不通</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yky@hw076:~/tmux&gt; ping www.baidu.com</span><br><span class=\"line\">ping: unknown host www.baidu.com</span><br><span class=\"line\">yky@hw076:~/tmux&gt; ping 8.8.8.8</span><br><span class=\"line\">connect: Network is unreachable</span><br></pre></td></tr></table></figure>\n<p>ping内网可以ping通</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hw076:~ # ping 172.18.11.114</span><br><span class=\"line\">PING 172.18.11.114 (172.18.11.114) 56(84) bytes of data.</span><br><span class=\"line\">64 bytes from 172.18.11.114: icmp_seq=1 ttl=64 time=0.193 ms</span><br><span class=\"line\">64 bytes from 172.18.11.114: icmp_seq=2 ttl=64 time=0.216 ms</span><br><span class=\"line\">64 bytes from 172.18.11.114: icmp_seq=3 ttl=64 time=0.207 ms</span><br><span class=\"line\">64 bytes from 172.18.11.114: icmp_seq=4 ttl=64 time=0.200 ms</span><br><span class=\"line\">^C</span><br><span class=\"line\">--- 172.18.11.114 ping statistics ---</span><br><span class=\"line\">4 packets transmitted, 4 received, 0% packet loss, time 2999ms</span><br><span class=\"line\">rtt min/avg/max/mdev = 0.193/0.204/0.216/0.008 ms</span><br></pre></td></tr></table></figure>\n<p>ifconfig信息为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hw076:~ # ifconfig </span><br><span class=\"line\">eth0      Link encap:Ethernet  HWaddr 90:E2:BA:15:C9:C4  </span><br><span class=\"line\">          inet addr:172.18.11.76  Bcast:192.168.1.255  Mask:255.255.0.0</span><br><span class=\"line\">          inet6 addr: fe80::92e2:baff:fe15:c9c4/64 Scope:Link</span><br><span class=\"line\">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class=\"line\">          RX packets:9725797 errors:0 dropped:506 overruns:0 frame:0</span><br><span class=\"line\">          TX packets:21023 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class=\"line\">          collisions:0 txqueuelen:1000 </span><br><span class=\"line\">          RX bytes:598731249 (570.9 Mb)  TX bytes:2767270 (2.6 Mb)</span><br><span class=\"line\">          Memory:fb480000-fb500000 </span><br><span class=\"line\"></span><br><span class=\"line\">lo        Link encap:Local Loopback  </span><br><span class=\"line\">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class=\"line\">          inet6 addr: ::1/128 Scope:Host</span><br><span class=\"line\">          UP LOOPBACK RUNNING  MTU:65536  Metric:1</span><br><span class=\"line\">          RX packets:276 errors:0 dropped:0 overruns:0 frame:0</span><br><span class=\"line\">          TX packets:276 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class=\"line\">          collisions:0 txqueuelen:0 </span><br><span class=\"line\">          RX bytes:25088 (24.5 Kb)  TX bytes:25088 (24.5 Kb)</span><br></pre></td></tr></table></figure>\n<p>route显示路由信息如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hw076:/etc/netconfig.d # route</span><br><span class=\"line\">Kernel IP routing table</span><br><span class=\"line\">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class=\"line\">default         *               0.0.0.0         UG    0      0        0 eth0</span><br><span class=\"line\">loopback        *               255.0.0.0       U     0      0        0 lo</span><br><span class=\"line\">link-local      *               255.255.0.0     U     0      0        0 eth0</span><br><span class=\"line\">172.18.0.0      *               255.255.0.0     U     0      0        0 eth0</span><br></pre></td></tr></table></figure>\n<p>原因是route没有配置网关，gateway是空着的。</p>\n<h3 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h3><p>通过查看其他可以正常访问的节点的路由信息，得知网关节点为：172.18.0.254。因此增加默认网关节点配置。</p>\n<p>执行命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">route add default  gw 172.18.0.254</span><br></pre></td></tr></table></figure>\n<p>再次查看路由信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hw076:~ # route</span><br><span class=\"line\">Kernel IP routing table</span><br><span class=\"line\">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class=\"line\">default         172.18.0.254    0.0.0.0         UG    0      0        0 eth0</span><br><span class=\"line\">loopback        *               255.0.0.0       U     0      0        0 lo</span><br><span class=\"line\">link-local      *               255.255.0.0     U     0      0        0 eth0</span><br><span class=\"line\">172.18.0.0      *               255.255.0.0     U     0      0        0 eth0</span><br></pre></td></tr></table></figure>\n<p>再次ping8.8.8.8显示正常，问题解决。</p>"},{"title":"tee命令解析","date":"2018-06-23T09:21:19.000Z","copyright":true,"_content":"\n# make 2>&1 | tee log.txt 命令解析\n\n在安装mpich 的时候遇到了很多这个命令，此处学习下这个命令：`2>&1 | tee log.txt` \n\n<!--more-->\n\n这个命令共有三个部分： `2>&1` `|`  `tee log.txt`\n\n## 2>&1\n\nshell中：最常使用的 FD (file descriptor) 大概有三个 \n\n0表示标准输入Standard Input (STDIN)  \n\n1表示标准输出Standard Output (STDOUT)  \n\n 2表示标准错误输出 Standard Error Output (STDERR)  \n\n'>' 默认为标准输出重定向 （类似于c++ 中的 >>？）\n\n在标准情况下, 这些FD分别跟如下设备关联 \n\nstdin(0): keyboard  键盘输入,并返回在前端   \n\nstdout(1): monitor  正确返回值 输出到前端   \n\nstderr(2): monitor 错误返回值 输出到前端  \n\n1>&2  正确返回值传递给2输出通道 &2表示2输出通道   如果此处错写成 1>2, 就表示把1输出重定向到文件2中  2>&1 错误返回值传递给1输出通道, 同样&1表示1输出通道.  \n\n## |管道\n\n管道的作用是提供一个通道，将上一个程序的标准输出重定向到下一个程序作为下一个程序的标准输入。 \n\n## tee log.txt\n\ntee从标准输入中读取，并将读入的内容写到标准输出以及文件中。  此处将数据读入并写入到log.txt中\n\n## 总结\n\n这个命令将标准错误输出重定向到标准输出，然后再将标准输出重定向到log.txt文件中\n\n常用于make 后面将log信息保存下来。","source":"_posts/tee命令解析.md","raw":"---\ntitle: tee命令解析\ndate: 2018-06-23 17:21:19\ncategories: Linux\ntags: \n- Linux\n- command\ncopyright: true\n---\n\n# make 2>&1 | tee log.txt 命令解析\n\n在安装mpich 的时候遇到了很多这个命令，此处学习下这个命令：`2>&1 | tee log.txt` \n\n<!--more-->\n\n这个命令共有三个部分： `2>&1` `|`  `tee log.txt`\n\n## 2>&1\n\nshell中：最常使用的 FD (file descriptor) 大概有三个 \n\n0表示标准输入Standard Input (STDIN)  \n\n1表示标准输出Standard Output (STDOUT)  \n\n 2表示标准错误输出 Standard Error Output (STDERR)  \n\n'>' 默认为标准输出重定向 （类似于c++ 中的 >>？）\n\n在标准情况下, 这些FD分别跟如下设备关联 \n\nstdin(0): keyboard  键盘输入,并返回在前端   \n\nstdout(1): monitor  正确返回值 输出到前端   \n\nstderr(2): monitor 错误返回值 输出到前端  \n\n1>&2  正确返回值传递给2输出通道 &2表示2输出通道   如果此处错写成 1>2, 就表示把1输出重定向到文件2中  2>&1 错误返回值传递给1输出通道, 同样&1表示1输出通道.  \n\n## |管道\n\n管道的作用是提供一个通道，将上一个程序的标准输出重定向到下一个程序作为下一个程序的标准输入。 \n\n## tee log.txt\n\ntee从标准输入中读取，并将读入的内容写到标准输出以及文件中。  此处将数据读入并写入到log.txt中\n\n## 总结\n\n这个命令将标准错误输出重定向到标准输出，然后再将标准输出重定向到log.txt文件中\n\n常用于make 后面将log信息保存下来。","slug":"tee命令解析","published":1,"updated":"2019-11-14T03:15:41.475Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2yelxi10023m8tz326yiyh1","content":"<h1 id=\"make-2-gt-amp-1-tee-log-txt-命令解析\"><a href=\"#make-2-gt-amp-1-tee-log-txt-命令解析\" class=\"headerlink\" title=\"make 2&gt;&amp;1 | tee log.txt 命令解析\"></a>make 2&gt;&amp;1 | tee log.txt 命令解析</h1><p>在安装mpich 的时候遇到了很多这个命令，此处学习下这个命令：<code>2&gt;&amp;1 | tee log.txt</code> </p>\n<a id=\"more\"></a>\n<p>这个命令共有三个部分： <code>2&gt;&amp;1</code> <code>|</code>  <code>tee log.txt</code></p>\n<h2 id=\"2-gt-amp-1\"><a href=\"#2-gt-amp-1\" class=\"headerlink\" title=\"2&gt;&amp;1\"></a>2&gt;&amp;1</h2><p>shell中：最常使用的 FD (file descriptor) 大概有三个 </p>\n<p>0表示标准输入Standard Input (STDIN)  </p>\n<p>1表示标准输出Standard Output (STDOUT)  </p>\n<p> 2表示标准错误输出 Standard Error Output (STDERR)  </p>\n<p>‘&gt;’ 默认为标准输出重定向 （类似于c++ 中的 &gt;&gt;？）</p>\n<p>在标准情况下, 这些FD分别跟如下设备关联 </p>\n<p>stdin(0): keyboard  键盘输入,并返回在前端   </p>\n<p>stdout(1): monitor  正确返回值 输出到前端   </p>\n<p>stderr(2): monitor 错误返回值 输出到前端  </p>\n<p>1&gt;&amp;2  正确返回值传递给2输出通道 &amp;2表示2输出通道   如果此处错写成 1&gt;2, 就表示把1输出重定向到文件2中  2&gt;&amp;1 错误返回值传递给1输出通道, 同样&amp;1表示1输出通道.  </p>\n<h2 id=\"管道\"><a href=\"#管道\" class=\"headerlink\" title=\"|管道\"></a>|管道</h2><p>管道的作用是提供一个通道，将上一个程序的标准输出重定向到下一个程序作为下一个程序的标准输入。 </p>\n<h2 id=\"tee-log-txt\"><a href=\"#tee-log-txt\" class=\"headerlink\" title=\"tee log.txt\"></a>tee log.txt</h2><p>tee从标准输入中读取，并将读入的内容写到标准输出以及文件中。  此处将数据读入并写入到log.txt中</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>这个命令将标准错误输出重定向到标准输出，然后再将标准输出重定向到log.txt文件中</p>\n<p>常用于make 后面将log信息保存下来。</p>\n","site":{"data":{}},"length":671,"excerpt":"<h1 id=\"make-2-gt-amp-1-tee-log-txt-命令解析\"><a href=\"#make-2-gt-amp-1-tee-log-txt-命令解析\" class=\"headerlink\" title=\"make 2&gt;&amp;1 | tee log.txt 命令解析\"></a>make 2&gt;&amp;1 | tee log.txt 命令解析</h1><p>在安装mpich 的时候遇到了很多这个命令，此处学习下这个命令：<code>2&gt;&amp;1 | tee log.txt</code> </p>","more":"<p>这个命令共有三个部分： <code>2&gt;&amp;1</code> <code>|</code>  <code>tee log.txt</code></p>\n<h2 id=\"2-gt-amp-1\"><a href=\"#2-gt-amp-1\" class=\"headerlink\" title=\"2&gt;&amp;1\"></a>2&gt;&amp;1</h2><p>shell中：最常使用的 FD (file descriptor) 大概有三个 </p>\n<p>0表示标准输入Standard Input (STDIN)  </p>\n<p>1表示标准输出Standard Output (STDOUT)  </p>\n<p> 2表示标准错误输出 Standard Error Output (STDERR)  </p>\n<p>‘&gt;’ 默认为标准输出重定向 （类似于c++ 中的 &gt;&gt;？）</p>\n<p>在标准情况下, 这些FD分别跟如下设备关联 </p>\n<p>stdin(0): keyboard  键盘输入,并返回在前端   </p>\n<p>stdout(1): monitor  正确返回值 输出到前端   </p>\n<p>stderr(2): monitor 错误返回值 输出到前端  </p>\n<p>1&gt;&amp;2  正确返回值传递给2输出通道 &amp;2表示2输出通道   如果此处错写成 1&gt;2, 就表示把1输出重定向到文件2中  2&gt;&amp;1 错误返回值传递给1输出通道, 同样&amp;1表示1输出通道.  </p>\n<h2 id=\"管道\"><a href=\"#管道\" class=\"headerlink\" title=\"|管道\"></a>|管道</h2><p>管道的作用是提供一个通道，将上一个程序的标准输出重定向到下一个程序作为下一个程序的标准输入。 </p>\n<h2 id=\"tee-log-txt\"><a href=\"#tee-log-txt\" class=\"headerlink\" title=\"tee log.txt\"></a>tee log.txt</h2><p>tee从标准输入中读取，并将读入的内容写到标准输出以及文件中。  此处将数据读入并写入到log.txt中</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>这个命令将标准错误输出重定向到标准输出，然后再将标准输出重定向到log.txt文件中</p>\n<p>常用于make 后面将log信息保存下来。</p>"},{"title":"使用YCSB 评测redis性能","date":"2019-03-12T09:11:44.000Z","copyright":true,"_content":"\n# 使用YCSB 评测redis性能\n\nYCSB是雅虎推出的可以评测许多主流数据库性能的基准测试，其中包括Redis。\n\n<!--more-->\n\n## 安装YCSB\n\n1. 安装java和maven\n\n   1. 机子已经有了java，所以只用安装maven Ubuntu安装命令为：\n\n      `sudo apt-get install maven`\n\n2. 安装YCSB \n\n   ````\n   git clone http://github.com/brianfrankcooper/YCSB.git\n   cd YCSB\n   mvn -pl com.yahoo.ycsb:redis-binding -am clean package\n   ````\n\n   必须是gitclone的源码包才能执行mvn 命令。wget或者curl下来包是已经编译好了的无需执行mvn命令。\n\n3. `mvn -pl com.yahoo.ycsb:redis-binding -am clean package` 报错：\n\n   ````\n   [INFO] Scanning for projects...\n   [ERROR] [ERROR] Could not find the selected project in the reactor: com.yahoo.ycsb:redis-binding @ \n   [ERROR] Could not find the selected project in the reactor: com.yahoo.ycsb:redis-binding -> [Help 1]\n   [ERROR] \n   [ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch.\n   [ERROR] Re-run Maven using the -X switch to enable full debug logging.\n   [ERROR] \n   [ERROR] For more information about the errors and possible solutions, please read the following articles:\n   [ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MavenExecutionException\n   ````\n\n原因：此命令是在gitclone后未编译的时候使用的。而我之前是下载的编译好的tar.gz包，解压后是已经编译好了的。所以再次执行编译的命令时会报错。\n\n## 使用YCSB\n\n将redis-server启动后开始使用YCSB\n\n### 设置数据库\n\n需要先创建`usertable`的表，因为YCSB客户端默认是对`usertable` 进行操作。Redis将数据存储在内存中，不需要相关操作。\n\n### 选择合适的DB interface\n\nYCSB的操作是通过DB interface来实现的。最基本的DB interface是`com.yahoo.ycsb.BasicDB`，会将输出输出到`System.out`里。可以通过继承DB interface来自定义DB interface，也可以使用原有的DB interface。Redis不需要此步操作。\n\n### 选择合适的负载\n\nYCSB提供了6种负载，负载在worloads目录下。详情见<https://github.com/brianfrankcooper/YCSB/wiki/Core-Workloads>\n\n1. **Workload A: Update heavy workload** 读写比例为： 50/50 混合负载 \n2. **Workload A: Update heavy workload** 读写比例为：95/5  读为主的负载\n3. **Workload C: Read only**  100% 的读  只读负载\n4. **Workload D: Read latest workload**  读取最近的数据负载\n5. **Workload E: Short ranges**  小范围的查询负载\n6. **Workload F: Read-modify-write** 读修改写负载\n\n自定义负载：参考<https://github.com/brianfrankcooper/YCSB/wiki/Implementing-New-Workloads>\n\n可以通过修改参数文件或者新建java类来实现\n\n需要注意的是YCSB的读写负载是针对哈希类型的数据而不是简单的字符串\n\n### 指定需要的运行参数\n\n主要是指定redis的ip ，端口，密码等。\n\n命令如下：\n\n```\n./bin/ycsb load redis -s -P workloads/workloada -p \"redis.host=127.0.0.1\" -p \"redis.port=6379\" > outputLoad.txt\n```\n\n`-s` : **status**.十秒打印一次状态\n\n### 加载负载\n\n命令如下：\n\n```\n./bin/ycsb load redis -s -P workloads/workloada > outputLoad.txt\n```\n\n### 运行负载\n\n命令如下：\n\n```\n./bin/ycsb run redis -s -P workloads/workloada > outputRun.txt\n```\n\n可以使用basic数据库来打印YCSB向数据库中写入的具体数据\n\n```\nbin/ycsb.sh load basic -P workloads/workloada\nbin/ycsb.sh run basic -P workloads/workloada\n```\n\n\n\n## 参考\n\nhttps://datawine.github.io/2018/12/11/YCSB%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/\n\nhttps://github.com/brianfrankcooper/YCSB/tree/master/redis  \n\n","source":"_posts/使用YCSB 评测redis性能.md","raw":"---\ntitle: 使用YCSB 评测redis性能\ndate: 2019-03-12 17:11:44\ncategories:\ntags:\n- redis\n- benchmark\ncopyright: true\n---\n\n# 使用YCSB 评测redis性能\n\nYCSB是雅虎推出的可以评测许多主流数据库性能的基准测试，其中包括Redis。\n\n<!--more-->\n\n## 安装YCSB\n\n1. 安装java和maven\n\n   1. 机子已经有了java，所以只用安装maven Ubuntu安装命令为：\n\n      `sudo apt-get install maven`\n\n2. 安装YCSB \n\n   ````\n   git clone http://github.com/brianfrankcooper/YCSB.git\n   cd YCSB\n   mvn -pl com.yahoo.ycsb:redis-binding -am clean package\n   ````\n\n   必须是gitclone的源码包才能执行mvn 命令。wget或者curl下来包是已经编译好了的无需执行mvn命令。\n\n3. `mvn -pl com.yahoo.ycsb:redis-binding -am clean package` 报错：\n\n   ````\n   [INFO] Scanning for projects...\n   [ERROR] [ERROR] Could not find the selected project in the reactor: com.yahoo.ycsb:redis-binding @ \n   [ERROR] Could not find the selected project in the reactor: com.yahoo.ycsb:redis-binding -> [Help 1]\n   [ERROR] \n   [ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch.\n   [ERROR] Re-run Maven using the -X switch to enable full debug logging.\n   [ERROR] \n   [ERROR] For more information about the errors and possible solutions, please read the following articles:\n   [ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MavenExecutionException\n   ````\n\n原因：此命令是在gitclone后未编译的时候使用的。而我之前是下载的编译好的tar.gz包，解压后是已经编译好了的。所以再次执行编译的命令时会报错。\n\n## 使用YCSB\n\n将redis-server启动后开始使用YCSB\n\n### 设置数据库\n\n需要先创建`usertable`的表，因为YCSB客户端默认是对`usertable` 进行操作。Redis将数据存储在内存中，不需要相关操作。\n\n### 选择合适的DB interface\n\nYCSB的操作是通过DB interface来实现的。最基本的DB interface是`com.yahoo.ycsb.BasicDB`，会将输出输出到`System.out`里。可以通过继承DB interface来自定义DB interface，也可以使用原有的DB interface。Redis不需要此步操作。\n\n### 选择合适的负载\n\nYCSB提供了6种负载，负载在worloads目录下。详情见<https://github.com/brianfrankcooper/YCSB/wiki/Core-Workloads>\n\n1. **Workload A: Update heavy workload** 读写比例为： 50/50 混合负载 \n2. **Workload A: Update heavy workload** 读写比例为：95/5  读为主的负载\n3. **Workload C: Read only**  100% 的读  只读负载\n4. **Workload D: Read latest workload**  读取最近的数据负载\n5. **Workload E: Short ranges**  小范围的查询负载\n6. **Workload F: Read-modify-write** 读修改写负载\n\n自定义负载：参考<https://github.com/brianfrankcooper/YCSB/wiki/Implementing-New-Workloads>\n\n可以通过修改参数文件或者新建java类来实现\n\n需要注意的是YCSB的读写负载是针对哈希类型的数据而不是简单的字符串\n\n### 指定需要的运行参数\n\n主要是指定redis的ip ，端口，密码等。\n\n命令如下：\n\n```\n./bin/ycsb load redis -s -P workloads/workloada -p \"redis.host=127.0.0.1\" -p \"redis.port=6379\" > outputLoad.txt\n```\n\n`-s` : **status**.十秒打印一次状态\n\n### 加载负载\n\n命令如下：\n\n```\n./bin/ycsb load redis -s -P workloads/workloada > outputLoad.txt\n```\n\n### 运行负载\n\n命令如下：\n\n```\n./bin/ycsb run redis -s -P workloads/workloada > outputRun.txt\n```\n\n可以使用basic数据库来打印YCSB向数据库中写入的具体数据\n\n```\nbin/ycsb.sh load basic -P workloads/workloada\nbin/ycsb.sh run basic -P workloads/workloada\n```\n\n\n\n## 参考\n\nhttps://datawine.github.io/2018/12/11/YCSB%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/\n\nhttps://github.com/brianfrankcooper/YCSB/tree/master/redis  \n\n","slug":"使用YCSB 评测redis性能","published":1,"updated":"2019-11-08T13:16:04.265Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2yelxi20025m8tzqyblu62c","content":"<h1 id=\"使用YCSB-评测redis性能\"><a href=\"#使用YCSB-评测redis性能\" class=\"headerlink\" title=\"使用YCSB 评测redis性能\"></a>使用YCSB 评测redis性能</h1><p>YCSB是雅虎推出的可以评测许多主流数据库性能的基准测试，其中包括Redis。</p>\n<a id=\"more\"></a>\n<h2 id=\"安装YCSB\"><a href=\"#安装YCSB\" class=\"headerlink\" title=\"安装YCSB\"></a>安装YCSB</h2><ol>\n<li><p>安装java和maven</p>\n<ol>\n<li><p>机子已经有了java，所以只用安装maven Ubuntu安装命令为：</p>\n<p><code>sudo apt-get install maven</code></p>\n</li>\n</ol>\n</li>\n<li><p>安装YCSB </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone http://github.com/brianfrankcooper/YCSB.git</span><br><span class=\"line\">cd YCSB</span><br><span class=\"line\">mvn -pl com.yahoo.ycsb:redis-binding -am clean package</span><br></pre></td></tr></table></figure>\n<p>必须是gitclone的源码包才能执行mvn 命令。wget或者curl下来包是已经编译好了的无需执行mvn命令。</p>\n</li>\n<li><p><code>mvn -pl com.yahoo.ycsb:redis-binding -am clean package</code> 报错：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[INFO] Scanning for projects...</span><br><span class=\"line\">[ERROR] [ERROR] Could not find the selected project in the reactor: com.yahoo.ycsb:redis-binding @ </span><br><span class=\"line\">[ERROR] Could not find the selected project in the reactor: com.yahoo.ycsb:redis-binding -&gt; [Help 1]</span><br><span class=\"line\">[ERROR] </span><br><span class=\"line\">[ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch.</span><br><span class=\"line\">[ERROR] Re-run Maven using the -X switch to enable full debug logging.</span><br><span class=\"line\">[ERROR] </span><br><span class=\"line\">[ERROR] For more information about the errors and possible solutions, please read the following articles:</span><br><span class=\"line\">[ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MavenExecutionException</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>原因：此命令是在gitclone后未编译的时候使用的。而我之前是下载的编译好的tar.gz包，解压后是已经编译好了的。所以再次执行编译的命令时会报错。</p>\n<h2 id=\"使用YCSB\"><a href=\"#使用YCSB\" class=\"headerlink\" title=\"使用YCSB\"></a>使用YCSB</h2><p>将redis-server启动后开始使用YCSB</p>\n<h3 id=\"设置数据库\"><a href=\"#设置数据库\" class=\"headerlink\" title=\"设置数据库\"></a>设置数据库</h3><p>需要先创建<code>usertable</code>的表，因为YCSB客户端默认是对<code>usertable</code> 进行操作。Redis将数据存储在内存中，不需要相关操作。</p>\n<h3 id=\"选择合适的DB-interface\"><a href=\"#选择合适的DB-interface\" class=\"headerlink\" title=\"选择合适的DB interface\"></a>选择合适的DB interface</h3><p>YCSB的操作是通过DB interface来实现的。最基本的DB interface是<code>com.yahoo.ycsb.BasicDB</code>，会将输出输出到<code>System.out</code>里。可以通过继承DB interface来自定义DB interface，也可以使用原有的DB interface。Redis不需要此步操作。</p>\n<h3 id=\"选择合适的负载\"><a href=\"#选择合适的负载\" class=\"headerlink\" title=\"选择合适的负载\"></a>选择合适的负载</h3><p>YCSB提供了6种负载，负载在worloads目录下。详情见<a href=\"https://github.com/brianfrankcooper/YCSB/wiki/Core-Workloads\" target=\"_blank\" rel=\"noopener\">https://github.com/brianfrankcooper/YCSB/wiki/Core-Workloads</a></p>\n<ol>\n<li><strong>Workload A: Update heavy workload</strong> 读写比例为： 50/50 混合负载 </li>\n<li><strong>Workload A: Update heavy workload</strong> 读写比例为：95/5  读为主的负载</li>\n<li><strong>Workload C: Read only</strong>  100% 的读  只读负载</li>\n<li><strong>Workload D: Read latest workload</strong>  读取最近的数据负载</li>\n<li><strong>Workload E: Short ranges</strong>  小范围的查询负载</li>\n<li><strong>Workload F: Read-modify-write</strong> 读修改写负载</li>\n</ol>\n<p>自定义负载：参考<a href=\"https://github.com/brianfrankcooper/YCSB/wiki/Implementing-New-Workloads\" target=\"_blank\" rel=\"noopener\">https://github.com/brianfrankcooper/YCSB/wiki/Implementing-New-Workloads</a></p>\n<p>可以通过修改参数文件或者新建java类来实现</p>\n<p>需要注意的是YCSB的读写负载是针对哈希类型的数据而不是简单的字符串</p>\n<h3 id=\"指定需要的运行参数\"><a href=\"#指定需要的运行参数\" class=\"headerlink\" title=\"指定需要的运行参数\"></a>指定需要的运行参数</h3><p>主要是指定redis的ip ，端口，密码等。</p>\n<p>命令如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./bin/ycsb load redis -s -P workloads/workloada -p &quot;redis.host=127.0.0.1&quot; -p &quot;redis.port=6379&quot; &gt; outputLoad.txt</span><br></pre></td></tr></table></figure>\n<p><code>-s</code> : <strong>status</strong>.十秒打印一次状态</p>\n<h3 id=\"加载负载\"><a href=\"#加载负载\" class=\"headerlink\" title=\"加载负载\"></a>加载负载</h3><p>命令如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./bin/ycsb load redis -s -P workloads/workloada &gt; outputLoad.txt</span><br></pre></td></tr></table></figure>\n<h3 id=\"运行负载\"><a href=\"#运行负载\" class=\"headerlink\" title=\"运行负载\"></a>运行负载</h3><p>命令如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./bin/ycsb run redis -s -P workloads/workloada &gt; outputRun.txt</span><br></pre></td></tr></table></figure>\n<p>可以使用basic数据库来打印YCSB向数据库中写入的具体数据</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bin/ycsb.sh load basic -P workloads/workloada</span><br><span class=\"line\">bin/ycsb.sh run basic -P workloads/workloada</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://datawine.github.io/2018/12/11/YCSB%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/\" target=\"_blank\" rel=\"noopener\">https://datawine.github.io/2018/12/11/YCSB%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/</a></p>\n<p><a href=\"https://github.com/brianfrankcooper/YCSB/tree/master/redis\" target=\"_blank\" rel=\"noopener\">https://github.com/brianfrankcooper/YCSB/tree/master/redis</a>  </p>\n","site":{"data":{}},"length":2243,"excerpt":"<h1 id=\"使用YCSB-评测redis性能\"><a href=\"#使用YCSB-评测redis性能\" class=\"headerlink\" title=\"使用YCSB 评测redis性能\"></a>使用YCSB 评测redis性能</h1><p>YCSB是雅虎推出的可以评测许多主流数据库性能的基准测试，其中包括Redis。</p>","more":"<h2 id=\"安装YCSB\"><a href=\"#安装YCSB\" class=\"headerlink\" title=\"安装YCSB\"></a>安装YCSB</h2><ol>\n<li><p>安装java和maven</p>\n<ol>\n<li><p>机子已经有了java，所以只用安装maven Ubuntu安装命令为：</p>\n<p><code>sudo apt-get install maven</code></p>\n</li>\n</ol>\n</li>\n<li><p>安装YCSB </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone http://github.com/brianfrankcooper/YCSB.git</span><br><span class=\"line\">cd YCSB</span><br><span class=\"line\">mvn -pl com.yahoo.ycsb:redis-binding -am clean package</span><br></pre></td></tr></table></figure>\n<p>必须是gitclone的源码包才能执行mvn 命令。wget或者curl下来包是已经编译好了的无需执行mvn命令。</p>\n</li>\n<li><p><code>mvn -pl com.yahoo.ycsb:redis-binding -am clean package</code> 报错：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[INFO] Scanning for projects...</span><br><span class=\"line\">[ERROR] [ERROR] Could not find the selected project in the reactor: com.yahoo.ycsb:redis-binding @ </span><br><span class=\"line\">[ERROR] Could not find the selected project in the reactor: com.yahoo.ycsb:redis-binding -&gt; [Help 1]</span><br><span class=\"line\">[ERROR] </span><br><span class=\"line\">[ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch.</span><br><span class=\"line\">[ERROR] Re-run Maven using the -X switch to enable full debug logging.</span><br><span class=\"line\">[ERROR] </span><br><span class=\"line\">[ERROR] For more information about the errors and possible solutions, please read the following articles:</span><br><span class=\"line\">[ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MavenExecutionException</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>原因：此命令是在gitclone后未编译的时候使用的。而我之前是下载的编译好的tar.gz包，解压后是已经编译好了的。所以再次执行编译的命令时会报错。</p>\n<h2 id=\"使用YCSB\"><a href=\"#使用YCSB\" class=\"headerlink\" title=\"使用YCSB\"></a>使用YCSB</h2><p>将redis-server启动后开始使用YCSB</p>\n<h3 id=\"设置数据库\"><a href=\"#设置数据库\" class=\"headerlink\" title=\"设置数据库\"></a>设置数据库</h3><p>需要先创建<code>usertable</code>的表，因为YCSB客户端默认是对<code>usertable</code> 进行操作。Redis将数据存储在内存中，不需要相关操作。</p>\n<h3 id=\"选择合适的DB-interface\"><a href=\"#选择合适的DB-interface\" class=\"headerlink\" title=\"选择合适的DB interface\"></a>选择合适的DB interface</h3><p>YCSB的操作是通过DB interface来实现的。最基本的DB interface是<code>com.yahoo.ycsb.BasicDB</code>，会将输出输出到<code>System.out</code>里。可以通过继承DB interface来自定义DB interface，也可以使用原有的DB interface。Redis不需要此步操作。</p>\n<h3 id=\"选择合适的负载\"><a href=\"#选择合适的负载\" class=\"headerlink\" title=\"选择合适的负载\"></a>选择合适的负载</h3><p>YCSB提供了6种负载，负载在worloads目录下。详情见<a href=\"https://github.com/brianfrankcooper/YCSB/wiki/Core-Workloads\" target=\"_blank\" rel=\"noopener\">https://github.com/brianfrankcooper/YCSB/wiki/Core-Workloads</a></p>\n<ol>\n<li><strong>Workload A: Update heavy workload</strong> 读写比例为： 50/50 混合负载 </li>\n<li><strong>Workload A: Update heavy workload</strong> 读写比例为：95/5  读为主的负载</li>\n<li><strong>Workload C: Read only</strong>  100% 的读  只读负载</li>\n<li><strong>Workload D: Read latest workload</strong>  读取最近的数据负载</li>\n<li><strong>Workload E: Short ranges</strong>  小范围的查询负载</li>\n<li><strong>Workload F: Read-modify-write</strong> 读修改写负载</li>\n</ol>\n<p>自定义负载：参考<a href=\"https://github.com/brianfrankcooper/YCSB/wiki/Implementing-New-Workloads\" target=\"_blank\" rel=\"noopener\">https://github.com/brianfrankcooper/YCSB/wiki/Implementing-New-Workloads</a></p>\n<p>可以通过修改参数文件或者新建java类来实现</p>\n<p>需要注意的是YCSB的读写负载是针对哈希类型的数据而不是简单的字符串</p>\n<h3 id=\"指定需要的运行参数\"><a href=\"#指定需要的运行参数\" class=\"headerlink\" title=\"指定需要的运行参数\"></a>指定需要的运行参数</h3><p>主要是指定redis的ip ，端口，密码等。</p>\n<p>命令如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./bin/ycsb load redis -s -P workloads/workloada -p &quot;redis.host=127.0.0.1&quot; -p &quot;redis.port=6379&quot; &gt; outputLoad.txt</span><br></pre></td></tr></table></figure>\n<p><code>-s</code> : <strong>status</strong>.十秒打印一次状态</p>\n<h3 id=\"加载负载\"><a href=\"#加载负载\" class=\"headerlink\" title=\"加载负载\"></a>加载负载</h3><p>命令如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./bin/ycsb load redis -s -P workloads/workloada &gt; outputLoad.txt</span><br></pre></td></tr></table></figure>\n<h3 id=\"运行负载\"><a href=\"#运行负载\" class=\"headerlink\" title=\"运行负载\"></a>运行负载</h3><p>命令如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./bin/ycsb run redis -s -P workloads/workloada &gt; outputRun.txt</span><br></pre></td></tr></table></figure>\n<p>可以使用basic数据库来打印YCSB向数据库中写入的具体数据</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bin/ycsb.sh load basic -P workloads/workloada</span><br><span class=\"line\">bin/ycsb.sh run basic -P workloads/workloada</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://datawine.github.io/2018/12/11/YCSB%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/\" target=\"_blank\" rel=\"noopener\">https://datawine.github.io/2018/12/11/YCSB%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/</a></p>\n<p><a href=\"https://github.com/brianfrankcooper/YCSB/tree/master/redis\" target=\"_blank\" rel=\"noopener\">https://github.com/brianfrankcooper/YCSB/tree/master/redis</a>  </p>"},{"title":"shell 脚本遍历redis数据库","date":"2019-03-14T12:00:46.000Z","copyright":true,"_content":"\n## 使用shell脚本遍历redis数据库中的所有kv对\n\n记录下如何使用shell通过redis-cli 命令来操作redis数据库，因为直接在命令行中输入\n\n`redis-cli command` 的话command必须是单个单词，不能像是`KEYS *` 这种.\n\n<!--more-->\n\n````\n#!/bin/bash\nfilename='redis'`date +%Y-%m-%d_%H:%M`\nwork_path=$(dirname \"$0\") \necho \"实例化redis数据文件为:$work_path/$filename\"\necho \"keys *\" | redis-cli > key_db.txt\necho \"将所有key保存到:$work_path/key_db.txt\"\nfor line in `cat key_db.txt`\ndo\n        echo \"key:$line \" >>$work_path/$filename.txt\n        echo \"key-value:\" >>$work_path/$filename.txt\n        echo \"hgetall $line\" | redis-cli >>$work_path/$filename.txt\ndone\n````\n\n使用echo 来把命令输出到管道然后再传递给redis-cli。在循环里面也是使用echo来把字符串输入到文件中。","source":"_posts/使用shell脚本遍历redis数据库中的所有kv对.md","raw":"---\ntitle: shell 脚本遍历redis数据库\ndate: 2019-03-14 20:00:46\ncategories: Linux\ntags:\n- shell\n- redis\ncopyright: true\n---\n\n## 使用shell脚本遍历redis数据库中的所有kv对\n\n记录下如何使用shell通过redis-cli 命令来操作redis数据库，因为直接在命令行中输入\n\n`redis-cli command` 的话command必须是单个单词，不能像是`KEYS *` 这种.\n\n<!--more-->\n\n````\n#!/bin/bash\nfilename='redis'`date +%Y-%m-%d_%H:%M`\nwork_path=$(dirname \"$0\") \necho \"实例化redis数据文件为:$work_path/$filename\"\necho \"keys *\" | redis-cli > key_db.txt\necho \"将所有key保存到:$work_path/key_db.txt\"\nfor line in `cat key_db.txt`\ndo\n        echo \"key:$line \" >>$work_path/$filename.txt\n        echo \"key-value:\" >>$work_path/$filename.txt\n        echo \"hgetall $line\" | redis-cli >>$work_path/$filename.txt\ndone\n````\n\n使用echo 来把命令输出到管道然后再传递给redis-cli。在循环里面也是使用echo来把字符串输入到文件中。","slug":"使用shell脚本遍历redis数据库中的所有kv对","published":1,"updated":"2019-11-08T13:15:39.540Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2yelxi30028m8tz121dhpz1","content":"<h2 id=\"使用shell脚本遍历redis数据库中的所有kv对\"><a href=\"#使用shell脚本遍历redis数据库中的所有kv对\" class=\"headerlink\" title=\"使用shell脚本遍历redis数据库中的所有kv对\"></a>使用shell脚本遍历redis数据库中的所有kv对</h2><p>记录下如何使用shell通过redis-cli 命令来操作redis数据库，因为直接在命令行中输入</p>\n<p><code>redis-cli command</code> 的话command必须是单个单词，不能像是<code>KEYS *</code> 这种.</p>\n<a id=\"more\"></a>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/bash</span><br><span class=\"line\">filename=&apos;redis&apos;`date +%Y-%m-%d_%H:%M`</span><br><span class=\"line\">work_path=$(dirname &quot;$0&quot;) </span><br><span class=\"line\">echo &quot;实例化redis数据文件为:$work_path/$filename&quot;</span><br><span class=\"line\">echo &quot;keys *&quot; | redis-cli &gt; key_db.txt</span><br><span class=\"line\">echo &quot;将所有key保存到:$work_path/key_db.txt&quot;</span><br><span class=\"line\">for line in `cat key_db.txt`</span><br><span class=\"line\">do</span><br><span class=\"line\">        echo &quot;key:$line &quot; &gt;&gt;$work_path/$filename.txt</span><br><span class=\"line\">        echo &quot;key-value:&quot; &gt;&gt;$work_path/$filename.txt</span><br><span class=\"line\">        echo &quot;hgetall $line&quot; | redis-cli &gt;&gt;$work_path/$filename.txt</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure>\n<p>使用echo 来把命令输出到管道然后再传递给redis-cli。在循环里面也是使用echo来把字符串输入到文件中。</p>\n","site":{"data":{}},"length":639,"excerpt":"<h2 id=\"使用shell脚本遍历redis数据库中的所有kv对\"><a href=\"#使用shell脚本遍历redis数据库中的所有kv对\" class=\"headerlink\" title=\"使用shell脚本遍历redis数据库中的所有kv对\"></a>使用shell脚本遍历redis数据库中的所有kv对</h2><p>记录下如何使用shell通过redis-cli 命令来操作redis数据库，因为直接在命令行中输入</p>\n<p><code>redis-cli command</code> 的话command必须是单个单词，不能像是<code>KEYS *</code> 这种.</p>","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/bash</span><br><span class=\"line\">filename=&apos;redis&apos;`date +%Y-%m-%d_%H:%M`</span><br><span class=\"line\">work_path=$(dirname &quot;$0&quot;) </span><br><span class=\"line\">echo &quot;实例化redis数据文件为:$work_path/$filename&quot;</span><br><span class=\"line\">echo &quot;keys *&quot; | redis-cli &gt; key_db.txt</span><br><span class=\"line\">echo &quot;将所有key保存到:$work_path/key_db.txt&quot;</span><br><span class=\"line\">for line in `cat key_db.txt`</span><br><span class=\"line\">do</span><br><span class=\"line\">        echo &quot;key:$line &quot; &gt;&gt;$work_path/$filename.txt</span><br><span class=\"line\">        echo &quot;key-value:&quot; &gt;&gt;$work_path/$filename.txt</span><br><span class=\"line\">        echo &quot;hgetall $line&quot; | redis-cli &gt;&gt;$work_path/$filename.txt</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure>\n<p>使用echo 来把命令输出到管道然后再传递给redis-cli。在循环里面也是使用echo来把字符串输入到文件中。</p>"},{"title":"图计算常用算法","date":"2018-04-24T03:20:17.000Z","copyright":true,"_content":"\n# 图算法的典型操作\n\n关于一些常见图算法的调研与学习。\n\n<!--more-->\n\n## 常用图算法\n\n### PageRank\n\n1. 背景\t\n\n   1. 既考虑入链数量，又考虑了网页质量因素，二者相结合 数量与权重的结合\n   2. 算法与主题无关，因为PR值是根据图计算出来的\n\n2. 算法原理\n\n   1. 基本思想\n\n      A有链接指向B，表明A认为B比A重要。A将自身权重分配一部分给B。\n\n      $W(B)=W(A)/N$   W(A) 是A的PR值，W(B)是A 分配的权重，N是A的出链数\n\n   2. PageRank公式修正\n\n      存在出链为0的孤立网页，增加阻力系数q ，一般取q=0.85，其意义是用户有1-q的概率不点击此页面上面的所有链接。同时还有随机直接跳转的概率，如直接输入网址，点击书签等。完整公式如下：\n\n      ![](E:\\data\\ict\\docs\\page rank.png)\n\n### Connected component\n\n1. 定义\n   1. 连通分支：图中，某个子图的任意两点有边连接，而子图之间无边连接\n   2. 问题：cc是寻找连通分支的算法？？\n2. 通过BFS、DFS算法的便利就可以找到连通分支，每个白色节点开始的就是一个连通分支。\n3. 常见算法\n   1. DFS\n      1. 原理：访问某个顶点后只有当某个节点是叶结点后才会访问其余相邻节点。\n      2. 步骤：\n         1. 选择一个结点作为起始结点，标记为灰色\n         2. 从该节点的邻居结点中选择一个结点，标记为灰色，继续这个操作\n         3. 当选中的结点时叶子结点时，将其涂黑并返回到上一个父节点。\n         4. 重复2,3直到所有结点都被访问。\n   2. BFS   （DFS，BFS不是图的遍历算法吗）。\n      1. 原理：在进一步遍历中顶点之前，先访问当前结点的所有邻接结点。\n      2. 步骤：\n         1. 选择一个顶点作为起始节点，放入队列，标记为灰色，其余标记为白色\n         2. 寻找队列首部结点的所有邻居节点，将其放入队列中并标记为灰色，将队列首部结点出队，并标记为黑色  \n         3. 重复2步骤，直到队列中的节点全部为空。\n\n### SSSP (single-source shortest paths)\n\n1. 单独的起点与目标点之间最短路径的计算。起点固定，寻找与其他所有结点之间的最短路径。包括单源单汇，单源多汇\n2. 常见算法\n   1. Dijkstra\n      1. 步骤\n         1. 将所有顶点分成两个集合A、B，其中集合A表示已经求得从V0出发的最短路径的顶点集合，集合B为为待求解的顶点集合。初始时有A={V0}\n         2. 将集合A与集合B相连的边（A中的所有结点与B中所有的结点形成的边）按照从V0出发的最短权重和递增次序排序，取最短的边，将该条边在集合B中所对应的顶点加入到集合A中\n         3. 重复第二步，直至B为空集。\n      2. 总结：\n         1. 最短中的最短：每次迭代时比较的是当前状态下以V0为起点，A中顶点为中间点的到各顶点之间的最短路径权重，最后再选择在当前所有最短路径中路径最短的一个顶点加入A。也就是说每次加入A集合的点是最短路径中的最短。\n         2. 给定目标点，在每次迭代时，并不知道能否到达最后的目标点，所以把到所有结点的最短距离都算出来了。\n\n### Betweenness Centrality（中介中心性）\n\n1. 定义 ：中心性用来衡量节结点的重要性。Betweenness Centrality ：考虑的是该节点出现在其他两节点之间的最短路径上的比率。\n\n2. 思想：如果一个成员位于其他成员的多条最短路上，那么该成员就是核心成员，就具有较大的中介中心性。\n\n3. 步骤\n\n   其中![\\sigma_{st}](https://i2.wp.com/upload.wikimedia.org/math/b/b/7/bb79bd91213d03edf0c8fc04fbd51085.png)表示的是节点s和t之间的最短路径的数量，而![\\sigma_{st}(v)](https://i2.wp.com/upload.wikimedia.org/math/4/2/c/42c33f5f78864175f0d9c9af1c492f5d.png)是最短路径中经过节点v的数量。\n\n   1. 计算各个点对之间最短路径的长度和条数，用于计算pair-dependencies: δst(v) =σst(v)/σst\n\n      ![clip_image004](http://static.oschina.net/uploads/img/201305/11121047_IQnh.jpg)\n\n   2. 对于每个节点，累积属于自己的pair-dependencies\n\n   ![](https://i2.wp.com/upload.wikimedia.org/math/4/c/c/4cc6eaa2dce9d504feeed5bd88b96d73.png)\n\n### LBP算法(Local Binary Pattern, 局部二值模式)\n\n1. 定义：LBP是一种用来描述图像局部纹理特征的算子。\n\n   1. 原始的LBP算子定义为在3*3的窗口内，以窗口中心像素为阈值，将相邻的8个像素的灰度值与其进行比较，若周围像素值大于中心像素值，则该像素点的位置被标记为1，否则为0\n\n   ![img](http://hi.csdn.net/attachment/201104/13/0_1302700245WllL.gif)\n\n2. 作用是进行特征提取，而且，提取的特征是图像的纹理特征，并且，是局部的纹理特征.\n\n3. 改进版本\n\n   1. 原型LBP算子 \n   2. LBP等价模式\n\n### 最小生成树\n\n1. 定义：无环连通图，图中所有结点均参与，所有边的权重加起来最小。\n2. 算法\n   1. Prim算法  \n      1. 步骤：设N=(V,{E})是连通网， TE是N上最小生成树中边的集合 \n         1. 初始令U={u0},(u0V), TE=φ\n         2. 在所有uU,vV-U的边(u,v)E中，找一条代价最小\n            的边(u0,v0), 并保证不形成回路 \n         3. 将(u0,v0)并入集合TE，同时v0并入U \n         4. 重复上述操作直至U=V为止，则T=(V,{TE})为N的\n            最小生成树  \n      2. 总结：每次迭代加入所有连通边中权值最小的。\n\n### 三角计数\n\n1. 定义：寻找无向图中的所有三角形\n2. 步骤\n   1. 建立邻接表：\n      1. 如果A-B & A < B，则将B加入A的邻接表 如果A-B & B < A，则将A加入B的邻接表  A<B比较的是id\n   2. 遍历每个节点，对于结点A，遍历A邻接表中的结点，如果邻接结点B,C两两之间存在边，则A、B、C三者之间存在三角形\n\n### 社区发现\n\n1. 社区定义：同一社区内的节点与节点之间的连接很紧密，而社区与社区之间的连接比较稀疏。社区是一个子图\n\n2. 数学描述：![](https://img-blog.csdn.net/20130710080910046)\n\n3. 衡量标准：模块度\n\n   1. 计算公式\n\n   ![](https://img-blog.csdn.net/20130710081032203)\n\n4. 常见算法\n\n   1. GN算法\n      1. 思想：在一个网络之中，通过社区内部的边的最短路径相对较少，而通过社区之间的边的最短路径的数目则相对较多。从社区内部走大概率会走很多条边。\n      2. 步骤\n         1. 计算每一条边的边介数。边介数（betweenness）：网络中任意两个节点通过此边的最短路径的数目。\n         2. 删除边介数最大的边\n         3. 重复（1）（2），直到网络中的任一顶点作为一个社区为止。\n      3. 缺陷\n         1. 不知道最后会有多少个社区\n         2. 在计算边介数的时候可能会有很对重复计算最短路径的情况，时间复杂度太高\n         3. GN算法不能判断算法终止位置\n   2. LPA算法（标签传播算法）\n      1. 思路\n         1. 自己是什么标签，由邻居决定。邻居中什么标签最多，则此结点是什么标签\n      2. 步骤\n         1. 为所有结点指定一个唯一的标签\n         2. 逐轮刷新所有结点的标签，直到达到收敛要求位置。刷新规则： 对于某一个节点，考察其所有邻居节点的标签，并进行统计，将出现个数最多的那个标签赋给当前节点。当个数最多的标签不唯一时，随机选一个。\n\n### 拓扑排序\n\n1. 定义 ：**拓扑排序（Topological Sorting）**是一个**有向无环图（DAG, Directed Acyclic Graph）**的所有顶点的线性序列。且该序列必须满足下面两个条件：\n   1. 每个顶点出现且只出现一次\n   2. 若存在一条从顶点 A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面\n2. 步骤\n   1. 从 DAG 图中选择一个 没有前驱（即入度为0）的顶点并输出\n   2. 从图中删除该顶点和所有以它为起点的有向边\n   3. 重复 1 和 2 直到当前的 DAG 图为空或**当前图中不存在无前驱的顶点为止**。后一种情况说明有向图中必然存在环\n      ![img](http://img.blog.csdn.net/20150507001759702)\n\n","source":"_posts/图计算常用算法.md","raw":"---\ntitle: 图计算常用算法\ndate: 2018-04-24 11:20:17\ncategories: algorithm\ntags:\n- graph \ncopyright: true\n---\n\n# 图算法的典型操作\n\n关于一些常见图算法的调研与学习。\n\n<!--more-->\n\n## 常用图算法\n\n### PageRank\n\n1. 背景\t\n\n   1. 既考虑入链数量，又考虑了网页质量因素，二者相结合 数量与权重的结合\n   2. 算法与主题无关，因为PR值是根据图计算出来的\n\n2. 算法原理\n\n   1. 基本思想\n\n      A有链接指向B，表明A认为B比A重要。A将自身权重分配一部分给B。\n\n      $W(B)=W(A)/N$   W(A) 是A的PR值，W(B)是A 分配的权重，N是A的出链数\n\n   2. PageRank公式修正\n\n      存在出链为0的孤立网页，增加阻力系数q ，一般取q=0.85，其意义是用户有1-q的概率不点击此页面上面的所有链接。同时还有随机直接跳转的概率，如直接输入网址，点击书签等。完整公式如下：\n\n      ![](E:\\data\\ict\\docs\\page rank.png)\n\n### Connected component\n\n1. 定义\n   1. 连通分支：图中，某个子图的任意两点有边连接，而子图之间无边连接\n   2. 问题：cc是寻找连通分支的算法？？\n2. 通过BFS、DFS算法的便利就可以找到连通分支，每个白色节点开始的就是一个连通分支。\n3. 常见算法\n   1. DFS\n      1. 原理：访问某个顶点后只有当某个节点是叶结点后才会访问其余相邻节点。\n      2. 步骤：\n         1. 选择一个结点作为起始结点，标记为灰色\n         2. 从该节点的邻居结点中选择一个结点，标记为灰色，继续这个操作\n         3. 当选中的结点时叶子结点时，将其涂黑并返回到上一个父节点。\n         4. 重复2,3直到所有结点都被访问。\n   2. BFS   （DFS，BFS不是图的遍历算法吗）。\n      1. 原理：在进一步遍历中顶点之前，先访问当前结点的所有邻接结点。\n      2. 步骤：\n         1. 选择一个顶点作为起始节点，放入队列，标记为灰色，其余标记为白色\n         2. 寻找队列首部结点的所有邻居节点，将其放入队列中并标记为灰色，将队列首部结点出队，并标记为黑色  \n         3. 重复2步骤，直到队列中的节点全部为空。\n\n### SSSP (single-source shortest paths)\n\n1. 单独的起点与目标点之间最短路径的计算。起点固定，寻找与其他所有结点之间的最短路径。包括单源单汇，单源多汇\n2. 常见算法\n   1. Dijkstra\n      1. 步骤\n         1. 将所有顶点分成两个集合A、B，其中集合A表示已经求得从V0出发的最短路径的顶点集合，集合B为为待求解的顶点集合。初始时有A={V0}\n         2. 将集合A与集合B相连的边（A中的所有结点与B中所有的结点形成的边）按照从V0出发的最短权重和递增次序排序，取最短的边，将该条边在集合B中所对应的顶点加入到集合A中\n         3. 重复第二步，直至B为空集。\n      2. 总结：\n         1. 最短中的最短：每次迭代时比较的是当前状态下以V0为起点，A中顶点为中间点的到各顶点之间的最短路径权重，最后再选择在当前所有最短路径中路径最短的一个顶点加入A。也就是说每次加入A集合的点是最短路径中的最短。\n         2. 给定目标点，在每次迭代时，并不知道能否到达最后的目标点，所以把到所有结点的最短距离都算出来了。\n\n### Betweenness Centrality（中介中心性）\n\n1. 定义 ：中心性用来衡量节结点的重要性。Betweenness Centrality ：考虑的是该节点出现在其他两节点之间的最短路径上的比率。\n\n2. 思想：如果一个成员位于其他成员的多条最短路上，那么该成员就是核心成员，就具有较大的中介中心性。\n\n3. 步骤\n\n   其中![\\sigma_{st}](https://i2.wp.com/upload.wikimedia.org/math/b/b/7/bb79bd91213d03edf0c8fc04fbd51085.png)表示的是节点s和t之间的最短路径的数量，而![\\sigma_{st}(v)](https://i2.wp.com/upload.wikimedia.org/math/4/2/c/42c33f5f78864175f0d9c9af1c492f5d.png)是最短路径中经过节点v的数量。\n\n   1. 计算各个点对之间最短路径的长度和条数，用于计算pair-dependencies: δst(v) =σst(v)/σst\n\n      ![clip_image004](http://static.oschina.net/uploads/img/201305/11121047_IQnh.jpg)\n\n   2. 对于每个节点，累积属于自己的pair-dependencies\n\n   ![](https://i2.wp.com/upload.wikimedia.org/math/4/c/c/4cc6eaa2dce9d504feeed5bd88b96d73.png)\n\n### LBP算法(Local Binary Pattern, 局部二值模式)\n\n1. 定义：LBP是一种用来描述图像局部纹理特征的算子。\n\n   1. 原始的LBP算子定义为在3*3的窗口内，以窗口中心像素为阈值，将相邻的8个像素的灰度值与其进行比较，若周围像素值大于中心像素值，则该像素点的位置被标记为1，否则为0\n\n   ![img](http://hi.csdn.net/attachment/201104/13/0_1302700245WllL.gif)\n\n2. 作用是进行特征提取，而且，提取的特征是图像的纹理特征，并且，是局部的纹理特征.\n\n3. 改进版本\n\n   1. 原型LBP算子 \n   2. LBP等价模式\n\n### 最小生成树\n\n1. 定义：无环连通图，图中所有结点均参与，所有边的权重加起来最小。\n2. 算法\n   1. Prim算法  \n      1. 步骤：设N=(V,{E})是连通网， TE是N上最小生成树中边的集合 \n         1. 初始令U={u0},(u0V), TE=φ\n         2. 在所有uU,vV-U的边(u,v)E中，找一条代价最小\n            的边(u0,v0), 并保证不形成回路 \n         3. 将(u0,v0)并入集合TE，同时v0并入U \n         4. 重复上述操作直至U=V为止，则T=(V,{TE})为N的\n            最小生成树  \n      2. 总结：每次迭代加入所有连通边中权值最小的。\n\n### 三角计数\n\n1. 定义：寻找无向图中的所有三角形\n2. 步骤\n   1. 建立邻接表：\n      1. 如果A-B & A < B，则将B加入A的邻接表 如果A-B & B < A，则将A加入B的邻接表  A<B比较的是id\n   2. 遍历每个节点，对于结点A，遍历A邻接表中的结点，如果邻接结点B,C两两之间存在边，则A、B、C三者之间存在三角形\n\n### 社区发现\n\n1. 社区定义：同一社区内的节点与节点之间的连接很紧密，而社区与社区之间的连接比较稀疏。社区是一个子图\n\n2. 数学描述：![](https://img-blog.csdn.net/20130710080910046)\n\n3. 衡量标准：模块度\n\n   1. 计算公式\n\n   ![](https://img-blog.csdn.net/20130710081032203)\n\n4. 常见算法\n\n   1. GN算法\n      1. 思想：在一个网络之中，通过社区内部的边的最短路径相对较少，而通过社区之间的边的最短路径的数目则相对较多。从社区内部走大概率会走很多条边。\n      2. 步骤\n         1. 计算每一条边的边介数。边介数（betweenness）：网络中任意两个节点通过此边的最短路径的数目。\n         2. 删除边介数最大的边\n         3. 重复（1）（2），直到网络中的任一顶点作为一个社区为止。\n      3. 缺陷\n         1. 不知道最后会有多少个社区\n         2. 在计算边介数的时候可能会有很对重复计算最短路径的情况，时间复杂度太高\n         3. GN算法不能判断算法终止位置\n   2. LPA算法（标签传播算法）\n      1. 思路\n         1. 自己是什么标签，由邻居决定。邻居中什么标签最多，则此结点是什么标签\n      2. 步骤\n         1. 为所有结点指定一个唯一的标签\n         2. 逐轮刷新所有结点的标签，直到达到收敛要求位置。刷新规则： 对于某一个节点，考察其所有邻居节点的标签，并进行统计，将出现个数最多的那个标签赋给当前节点。当个数最多的标签不唯一时，随机选一个。\n\n### 拓扑排序\n\n1. 定义 ：**拓扑排序（Topological Sorting）**是一个**有向无环图（DAG, Directed Acyclic Graph）**的所有顶点的线性序列。且该序列必须满足下面两个条件：\n   1. 每个顶点出现且只出现一次\n   2. 若存在一条从顶点 A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面\n2. 步骤\n   1. 从 DAG 图中选择一个 没有前驱（即入度为0）的顶点并输出\n   2. 从图中删除该顶点和所有以它为起点的有向边\n   3. 重复 1 和 2 直到当前的 DAG 图为空或**当前图中不存在无前驱的顶点为止**。后一种情况说明有向图中必然存在环\n      ![img](http://img.blog.csdn.net/20150507001759702)\n\n","slug":"图计算常用算法","published":1,"updated":"2019-11-08T13:15:48.042Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2yelxi5002bm8tzr2fmg1eu","content":"<h1 id=\"图算法的典型操作\"><a href=\"#图算法的典型操作\" class=\"headerlink\" title=\"图算法的典型操作\"></a>图算法的典型操作</h1><p>关于一些常见图算法的调研与学习。</p>\n<a id=\"more\"></a>\n<h2 id=\"常用图算法\"><a href=\"#常用图算法\" class=\"headerlink\" title=\"常用图算法\"></a>常用图算法</h2><h3 id=\"PageRank\"><a href=\"#PageRank\" class=\"headerlink\" title=\"PageRank\"></a>PageRank</h3><ol>\n<li><p>背景    </p>\n<ol>\n<li>既考虑入链数量，又考虑了网页质量因素，二者相结合 数量与权重的结合</li>\n<li>算法与主题无关，因为PR值是根据图计算出来的</li>\n</ol>\n</li>\n<li><p>算法原理</p>\n<ol>\n<li><p>基本思想</p>\n<p>A有链接指向B，表明A认为B比A重要。A将自身权重分配一部分给B。</p>\n<p>$W(B)=W(A)/N$   W(A) 是A的PR值，W(B)是A 分配的权重，N是A的出链数</p>\n</li>\n<li><p>PageRank公式修正</p>\n<p>存在出链为0的孤立网页，增加阻力系数q ，一般取q=0.85，其意义是用户有1-q的概率不点击此页面上面的所有链接。同时还有随机直接跳转的概率，如直接输入网址，点击书签等。完整公式如下：</p>\n<p><img src=\"/图计算常用算法.htm/data\\ict\\docs\\page rank.png\" alt=\"\"></p>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"Connected-component\"><a href=\"#Connected-component\" class=\"headerlink\" title=\"Connected component\"></a>Connected component</h3><ol>\n<li>定义<ol>\n<li>连通分支：图中，某个子图的任意两点有边连接，而子图之间无边连接</li>\n<li>问题：cc是寻找连通分支的算法？？</li>\n</ol>\n</li>\n<li>通过BFS、DFS算法的便利就可以找到连通分支，每个白色节点开始的就是一个连通分支。</li>\n<li>常见算法<ol>\n<li>DFS<ol>\n<li>原理：访问某个顶点后只有当某个节点是叶结点后才会访问其余相邻节点。</li>\n<li>步骤：<ol>\n<li>选择一个结点作为起始结点，标记为灰色</li>\n<li>从该节点的邻居结点中选择一个结点，标记为灰色，继续这个操作</li>\n<li>当选中的结点时叶子结点时，将其涂黑并返回到上一个父节点。</li>\n<li>重复2,3直到所有结点都被访问。</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>BFS   （DFS，BFS不是图的遍历算法吗）。<ol>\n<li>原理：在进一步遍历中顶点之前，先访问当前结点的所有邻接结点。</li>\n<li>步骤：<ol>\n<li>选择一个顶点作为起始节点，放入队列，标记为灰色，其余标记为白色</li>\n<li>寻找队列首部结点的所有邻居节点，将其放入队列中并标记为灰色，将队列首部结点出队，并标记为黑色  </li>\n<li>重复2步骤，直到队列中的节点全部为空。</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"SSSP-single-source-shortest-paths\"><a href=\"#SSSP-single-source-shortest-paths\" class=\"headerlink\" title=\"SSSP (single-source shortest paths)\"></a>SSSP (single-source shortest paths)</h3><ol>\n<li>单独的起点与目标点之间最短路径的计算。起点固定，寻找与其他所有结点之间的最短路径。包括单源单汇，单源多汇</li>\n<li>常见算法<ol>\n<li>Dijkstra<ol>\n<li>步骤<ol>\n<li>将所有顶点分成两个集合A、B，其中集合A表示已经求得从V0出发的最短路径的顶点集合，集合B为为待求解的顶点集合。初始时有A={V0}</li>\n<li>将集合A与集合B相连的边（A中的所有结点与B中所有的结点形成的边）按照从V0出发的最短权重和递增次序排序，取最短的边，将该条边在集合B中所对应的顶点加入到集合A中</li>\n<li>重复第二步，直至B为空集。</li>\n</ol>\n</li>\n<li>总结：<ol>\n<li>最短中的最短：每次迭代时比较的是当前状态下以V0为起点，A中顶点为中间点的到各顶点之间的最短路径权重，最后再选择在当前所有最短路径中路径最短的一个顶点加入A。也就是说每次加入A集合的点是最短路径中的最短。</li>\n<li>给定目标点，在每次迭代时，并不知道能否到达最后的目标点，所以把到所有结点的最短距离都算出来了。</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"Betweenness-Centrality（中介中心性）\"><a href=\"#Betweenness-Centrality（中介中心性）\" class=\"headerlink\" title=\"Betweenness Centrality（中介中心性）\"></a>Betweenness Centrality（中介中心性）</h3><ol>\n<li><p>定义 ：中心性用来衡量节结点的重要性。Betweenness Centrality ：考虑的是该节点出现在其他两节点之间的最短路径上的比率。</p>\n</li>\n<li><p>思想：如果一个成员位于其他成员的多条最短路上，那么该成员就是核心成员，就具有较大的中介中心性。</p>\n</li>\n<li><p>步骤</p>\n<p>其中<img src=\"https://i2.wp.com/upload.wikimedia.org/math/b/b/7/bb79bd91213d03edf0c8fc04fbd51085.png\" alt=\"\\sigma_{st}\">表示的是节点s和t之间的最短路径的数量，而<img src=\"https://i2.wp.com/upload.wikimedia.org/math/4/2/c/42c33f5f78864175f0d9c9af1c492f5d.png\" alt=\"\\sigma_{st}(v)\">是最短路径中经过节点v的数量。</p>\n<ol>\n<li><p>计算各个点对之间最短路径的长度和条数，用于计算pair-dependencies: δst(v) =σst(v)/σst</p>\n<p><img src=\"http://static.oschina.net/uploads/img/201305/11121047_IQnh.jpg\" alt=\"clip_image004\"></p>\n</li>\n<li><p>对于每个节点，累积属于自己的pair-dependencies</p>\n</li>\n</ol>\n<p><img src=\"https://i2.wp.com/upload.wikimedia.org/math/4/c/c/4cc6eaa2dce9d504feeed5bd88b96d73.png\" alt=\"\"></p>\n</li>\n</ol>\n<h3 id=\"LBP算法-Local-Binary-Pattern-局部二值模式\"><a href=\"#LBP算法-Local-Binary-Pattern-局部二值模式\" class=\"headerlink\" title=\"LBP算法(Local Binary Pattern, 局部二值模式)\"></a>LBP算法(Local Binary Pattern, 局部二值模式)</h3><ol>\n<li><p>定义：LBP是一种用来描述图像局部纹理特征的算子。</p>\n<ol>\n<li>原始的LBP算子定义为在3*3的窗口内，以窗口中心像素为阈值，将相邻的8个像素的灰度值与其进行比较，若周围像素值大于中心像素值，则该像素点的位置被标记为1，否则为0</li>\n</ol>\n<p><img src=\"http://hi.csdn.net/attachment/201104/13/0_1302700245WllL.gif\" alt=\"img\"></p>\n</li>\n<li><p>作用是进行特征提取，而且，提取的特征是图像的纹理特征，并且，是局部的纹理特征.</p>\n</li>\n<li><p>改进版本</p>\n<ol>\n<li>原型LBP算子 </li>\n<li>LBP等价模式</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"最小生成树\"><a href=\"#最小生成树\" class=\"headerlink\" title=\"最小生成树\"></a>最小生成树</h3><ol>\n<li>定义：无环连通图，图中所有结点均参与，所有边的权重加起来最小。</li>\n<li>算法<ol>\n<li>Prim算法  <ol>\n<li>步骤：设N=(V,{E})是连通网， TE是N上最小生成树中边的集合 <ol>\n<li>初始令U={u0},(u0V), TE=φ</li>\n<li>在所有uU,vV-U的边(u,v)E中，找一条代价最小<br>的边(u0,v0), 并保证不形成回路 </li>\n<li>将(u0,v0)并入集合TE，同时v0并入U </li>\n<li>重复上述操作直至U=V为止，则T=(V,{TE})为N的<br>最小生成树  </li>\n</ol>\n</li>\n<li>总结：每次迭代加入所有连通边中权值最小的。</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"三角计数\"><a href=\"#三角计数\" class=\"headerlink\" title=\"三角计数\"></a>三角计数</h3><ol>\n<li>定义：寻找无向图中的所有三角形</li>\n<li>步骤<ol>\n<li>建立邻接表：<ol>\n<li>如果A-B &amp; A &lt; B，则将B加入A的邻接表 如果A-B &amp; B &lt; A，则将A加入B的邻接表  A&lt;B比较的是id</li>\n</ol>\n</li>\n<li>遍历每个节点，对于结点A，遍历A邻接表中的结点，如果邻接结点B,C两两之间存在边，则A、B、C三者之间存在三角形</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"社区发现\"><a href=\"#社区发现\" class=\"headerlink\" title=\"社区发现\"></a>社区发现</h3><ol>\n<li><p>社区定义：同一社区内的节点与节点之间的连接很紧密，而社区与社区之间的连接比较稀疏。社区是一个子图</p>\n</li>\n<li><p>数学描述：<img src=\"https://img-blog.csdn.net/20130710080910046\" alt=\"\"></p>\n</li>\n<li><p>衡量标准：模块度</p>\n<ol>\n<li>计算公式</li>\n</ol>\n<p><img src=\"https://img-blog.csdn.net/20130710081032203\" alt=\"\"></p>\n</li>\n<li><p>常见算法</p>\n<ol>\n<li>GN算法<ol>\n<li>思想：在一个网络之中，通过社区内部的边的最短路径相对较少，而通过社区之间的边的最短路径的数目则相对较多。从社区内部走大概率会走很多条边。</li>\n<li>步骤<ol>\n<li>计算每一条边的边介数。边介数（betweenness）：网络中任意两个节点通过此边的最短路径的数目。</li>\n<li>删除边介数最大的边</li>\n<li>重复（1）（2），直到网络中的任一顶点作为一个社区为止。</li>\n</ol>\n</li>\n<li>缺陷<ol>\n<li>不知道最后会有多少个社区</li>\n<li>在计算边介数的时候可能会有很对重复计算最短路径的情况，时间复杂度太高</li>\n<li>GN算法不能判断算法终止位置</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>LPA算法（标签传播算法）<ol>\n<li>思路<ol>\n<li>自己是什么标签，由邻居决定。邻居中什么标签最多，则此结点是什么标签</li>\n</ol>\n</li>\n<li>步骤<ol>\n<li>为所有结点指定一个唯一的标签</li>\n<li>逐轮刷新所有结点的标签，直到达到收敛要求位置。刷新规则： 对于某一个节点，考察其所有邻居节点的标签，并进行统计，将出现个数最多的那个标签赋给当前节点。当个数最多的标签不唯一时，随机选一个。</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"拓扑排序\"><a href=\"#拓扑排序\" class=\"headerlink\" title=\"拓扑排序\"></a>拓扑排序</h3><ol>\n<li>定义 ：<strong>拓扑排序（Topological Sorting）</strong>是一个<strong>有向无环图（DAG, Directed Acyclic Graph）</strong>的所有顶点的线性序列。且该序列必须满足下面两个条件：<ol>\n<li>每个顶点出现且只出现一次</li>\n<li>若存在一条从顶点 A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面</li>\n</ol>\n</li>\n<li>步骤<ol>\n<li>从 DAG 图中选择一个 没有前驱（即入度为0）的顶点并输出</li>\n<li>从图中删除该顶点和所有以它为起点的有向边</li>\n<li>重复 1 和 2 直到当前的 DAG 图为空或<strong>当前图中不存在无前驱的顶点为止</strong>。后一种情况说明有向图中必然存在环<br><img src=\"http://img.blog.csdn.net/20150507001759702\" alt=\"img\"></li>\n</ol>\n</li>\n</ol>\n","site":{"data":{}},"length":2613,"excerpt":"<h1 id=\"图算法的典型操作\"><a href=\"#图算法的典型操作\" class=\"headerlink\" title=\"图算法的典型操作\"></a>图算法的典型操作</h1><p>关于一些常见图算法的调研与学习。</p>","more":"<h2 id=\"常用图算法\"><a href=\"#常用图算法\" class=\"headerlink\" title=\"常用图算法\"></a>常用图算法</h2><h3 id=\"PageRank\"><a href=\"#PageRank\" class=\"headerlink\" title=\"PageRank\"></a>PageRank</h3><ol>\n<li><p>背景    </p>\n<ol>\n<li>既考虑入链数量，又考虑了网页质量因素，二者相结合 数量与权重的结合</li>\n<li>算法与主题无关，因为PR值是根据图计算出来的</li>\n</ol>\n</li>\n<li><p>算法原理</p>\n<ol>\n<li><p>基本思想</p>\n<p>A有链接指向B，表明A认为B比A重要。A将自身权重分配一部分给B。</p>\n<p>$W(B)=W(A)/N$   W(A) 是A的PR值，W(B)是A 分配的权重，N是A的出链数</p>\n</li>\n<li><p>PageRank公式修正</p>\n<p>存在出链为0的孤立网页，增加阻力系数q ，一般取q=0.85，其意义是用户有1-q的概率不点击此页面上面的所有链接。同时还有随机直接跳转的概率，如直接输入网址，点击书签等。完整公式如下：</p>\n<p><img src=\"/图计算常用算法.htm/data\\ict\\docs\\page rank.png\" alt=\"\"></p>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"Connected-component\"><a href=\"#Connected-component\" class=\"headerlink\" title=\"Connected component\"></a>Connected component</h3><ol>\n<li>定义<ol>\n<li>连通分支：图中，某个子图的任意两点有边连接，而子图之间无边连接</li>\n<li>问题：cc是寻找连通分支的算法？？</li>\n</ol>\n</li>\n<li>通过BFS、DFS算法的便利就可以找到连通分支，每个白色节点开始的就是一个连通分支。</li>\n<li>常见算法<ol>\n<li>DFS<ol>\n<li>原理：访问某个顶点后只有当某个节点是叶结点后才会访问其余相邻节点。</li>\n<li>步骤：<ol>\n<li>选择一个结点作为起始结点，标记为灰色</li>\n<li>从该节点的邻居结点中选择一个结点，标记为灰色，继续这个操作</li>\n<li>当选中的结点时叶子结点时，将其涂黑并返回到上一个父节点。</li>\n<li>重复2,3直到所有结点都被访问。</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>BFS   （DFS，BFS不是图的遍历算法吗）。<ol>\n<li>原理：在进一步遍历中顶点之前，先访问当前结点的所有邻接结点。</li>\n<li>步骤：<ol>\n<li>选择一个顶点作为起始节点，放入队列，标记为灰色，其余标记为白色</li>\n<li>寻找队列首部结点的所有邻居节点，将其放入队列中并标记为灰色，将队列首部结点出队，并标记为黑色  </li>\n<li>重复2步骤，直到队列中的节点全部为空。</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"SSSP-single-source-shortest-paths\"><a href=\"#SSSP-single-source-shortest-paths\" class=\"headerlink\" title=\"SSSP (single-source shortest paths)\"></a>SSSP (single-source shortest paths)</h3><ol>\n<li>单独的起点与目标点之间最短路径的计算。起点固定，寻找与其他所有结点之间的最短路径。包括单源单汇，单源多汇</li>\n<li>常见算法<ol>\n<li>Dijkstra<ol>\n<li>步骤<ol>\n<li>将所有顶点分成两个集合A、B，其中集合A表示已经求得从V0出发的最短路径的顶点集合，集合B为为待求解的顶点集合。初始时有A={V0}</li>\n<li>将集合A与集合B相连的边（A中的所有结点与B中所有的结点形成的边）按照从V0出发的最短权重和递增次序排序，取最短的边，将该条边在集合B中所对应的顶点加入到集合A中</li>\n<li>重复第二步，直至B为空集。</li>\n</ol>\n</li>\n<li>总结：<ol>\n<li>最短中的最短：每次迭代时比较的是当前状态下以V0为起点，A中顶点为中间点的到各顶点之间的最短路径权重，最后再选择在当前所有最短路径中路径最短的一个顶点加入A。也就是说每次加入A集合的点是最短路径中的最短。</li>\n<li>给定目标点，在每次迭代时，并不知道能否到达最后的目标点，所以把到所有结点的最短距离都算出来了。</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"Betweenness-Centrality（中介中心性）\"><a href=\"#Betweenness-Centrality（中介中心性）\" class=\"headerlink\" title=\"Betweenness Centrality（中介中心性）\"></a>Betweenness Centrality（中介中心性）</h3><ol>\n<li><p>定义 ：中心性用来衡量节结点的重要性。Betweenness Centrality ：考虑的是该节点出现在其他两节点之间的最短路径上的比率。</p>\n</li>\n<li><p>思想：如果一个成员位于其他成员的多条最短路上，那么该成员就是核心成员，就具有较大的中介中心性。</p>\n</li>\n<li><p>步骤</p>\n<p>其中<img src=\"https://i2.wp.com/upload.wikimedia.org/math/b/b/7/bb79bd91213d03edf0c8fc04fbd51085.png\" alt=\"\\sigma_{st}\">表示的是节点s和t之间的最短路径的数量，而<img src=\"https://i2.wp.com/upload.wikimedia.org/math/4/2/c/42c33f5f78864175f0d9c9af1c492f5d.png\" alt=\"\\sigma_{st}(v)\">是最短路径中经过节点v的数量。</p>\n<ol>\n<li><p>计算各个点对之间最短路径的长度和条数，用于计算pair-dependencies: δst(v) =σst(v)/σst</p>\n<p><img src=\"http://static.oschina.net/uploads/img/201305/11121047_IQnh.jpg\" alt=\"clip_image004\"></p>\n</li>\n<li><p>对于每个节点，累积属于自己的pair-dependencies</p>\n</li>\n</ol>\n<p><img src=\"https://i2.wp.com/upload.wikimedia.org/math/4/c/c/4cc6eaa2dce9d504feeed5bd88b96d73.png\" alt=\"\"></p>\n</li>\n</ol>\n<h3 id=\"LBP算法-Local-Binary-Pattern-局部二值模式\"><a href=\"#LBP算法-Local-Binary-Pattern-局部二值模式\" class=\"headerlink\" title=\"LBP算法(Local Binary Pattern, 局部二值模式)\"></a>LBP算法(Local Binary Pattern, 局部二值模式)</h3><ol>\n<li><p>定义：LBP是一种用来描述图像局部纹理特征的算子。</p>\n<ol>\n<li>原始的LBP算子定义为在3*3的窗口内，以窗口中心像素为阈值，将相邻的8个像素的灰度值与其进行比较，若周围像素值大于中心像素值，则该像素点的位置被标记为1，否则为0</li>\n</ol>\n<p><img src=\"http://hi.csdn.net/attachment/201104/13/0_1302700245WllL.gif\" alt=\"img\"></p>\n</li>\n<li><p>作用是进行特征提取，而且，提取的特征是图像的纹理特征，并且，是局部的纹理特征.</p>\n</li>\n<li><p>改进版本</p>\n<ol>\n<li>原型LBP算子 </li>\n<li>LBP等价模式</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"最小生成树\"><a href=\"#最小生成树\" class=\"headerlink\" title=\"最小生成树\"></a>最小生成树</h3><ol>\n<li>定义：无环连通图，图中所有结点均参与，所有边的权重加起来最小。</li>\n<li>算法<ol>\n<li>Prim算法  <ol>\n<li>步骤：设N=(V,{E})是连通网， TE是N上最小生成树中边的集合 <ol>\n<li>初始令U={u0},(u0V), TE=φ</li>\n<li>在所有uU,vV-U的边(u,v)E中，找一条代价最小<br>的边(u0,v0), 并保证不形成回路 </li>\n<li>将(u0,v0)并入集合TE，同时v0并入U </li>\n<li>重复上述操作直至U=V为止，则T=(V,{TE})为N的<br>最小生成树  </li>\n</ol>\n</li>\n<li>总结：每次迭代加入所有连通边中权值最小的。</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"三角计数\"><a href=\"#三角计数\" class=\"headerlink\" title=\"三角计数\"></a>三角计数</h3><ol>\n<li>定义：寻找无向图中的所有三角形</li>\n<li>步骤<ol>\n<li>建立邻接表：<ol>\n<li>如果A-B &amp; A &lt; B，则将B加入A的邻接表 如果A-B &amp; B &lt; A，则将A加入B的邻接表  A&lt;B比较的是id</li>\n</ol>\n</li>\n<li>遍历每个节点，对于结点A，遍历A邻接表中的结点，如果邻接结点B,C两两之间存在边，则A、B、C三者之间存在三角形</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"社区发现\"><a href=\"#社区发现\" class=\"headerlink\" title=\"社区发现\"></a>社区发现</h3><ol>\n<li><p>社区定义：同一社区内的节点与节点之间的连接很紧密，而社区与社区之间的连接比较稀疏。社区是一个子图</p>\n</li>\n<li><p>数学描述：<img src=\"https://img-blog.csdn.net/20130710080910046\" alt=\"\"></p>\n</li>\n<li><p>衡量标准：模块度</p>\n<ol>\n<li>计算公式</li>\n</ol>\n<p><img src=\"https://img-blog.csdn.net/20130710081032203\" alt=\"\"></p>\n</li>\n<li><p>常见算法</p>\n<ol>\n<li>GN算法<ol>\n<li>思想：在一个网络之中，通过社区内部的边的最短路径相对较少，而通过社区之间的边的最短路径的数目则相对较多。从社区内部走大概率会走很多条边。</li>\n<li>步骤<ol>\n<li>计算每一条边的边介数。边介数（betweenness）：网络中任意两个节点通过此边的最短路径的数目。</li>\n<li>删除边介数最大的边</li>\n<li>重复（1）（2），直到网络中的任一顶点作为一个社区为止。</li>\n</ol>\n</li>\n<li>缺陷<ol>\n<li>不知道最后会有多少个社区</li>\n<li>在计算边介数的时候可能会有很对重复计算最短路径的情况，时间复杂度太高</li>\n<li>GN算法不能判断算法终止位置</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>LPA算法（标签传播算法）<ol>\n<li>思路<ol>\n<li>自己是什么标签，由邻居决定。邻居中什么标签最多，则此结点是什么标签</li>\n</ol>\n</li>\n<li>步骤<ol>\n<li>为所有结点指定一个唯一的标签</li>\n<li>逐轮刷新所有结点的标签，直到达到收敛要求位置。刷新规则： 对于某一个节点，考察其所有邻居节点的标签，并进行统计，将出现个数最多的那个标签赋给当前节点。当个数最多的标签不唯一时，随机选一个。</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"拓扑排序\"><a href=\"#拓扑排序\" class=\"headerlink\" title=\"拓扑排序\"></a>拓扑排序</h3><ol>\n<li>定义 ：<strong>拓扑排序（Topological Sorting）</strong>是一个<strong>有向无环图（DAG, Directed Acyclic Graph）</strong>的所有顶点的线性序列。且该序列必须满足下面两个条件：<ol>\n<li>每个顶点出现且只出现一次</li>\n<li>若存在一条从顶点 A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面</li>\n</ol>\n</li>\n<li>步骤<ol>\n<li>从 DAG 图中选择一个 没有前驱（即入度为0）的顶点并输出</li>\n<li>从图中删除该顶点和所有以它为起点的有向边</li>\n<li>重复 1 和 2 直到当前的 DAG 图为空或<strong>当前图中不存在无前驱的顶点为止</strong>。后一种情况说明有向图中必然存在环<br><img src=\"http://img.blog.csdn.net/20150507001759702\" alt=\"img\"></li>\n</ol>\n</li>\n</ol>"},{"title":"Redis源码阅读——SDS","date":"2019-03-22T07:58:45.000Z","copyright":true,"_content":"\n# Redis源码阅读——SDS\n\n参考Redis设计与实现 以及网上博客阅读Redis源码。\n\n<!--more-->\n\nSDS相关知识点见读书笔记。\n\n## 创建和销毁\n\n为了能够对sds进行相关API的测试，因此把sds模块单独提出来。阅读Redis的Makefile发现，编译sds模块需要的源文件包括`sds.c`, `sds.h` `zmalloc.c` \n\n```Make\ntest-sds: sds.c sds.h\n        $(REDIS_CC) sds.c zmalloc.c -DSDS_TEST_MAIN $(FINAL_LIBS) -o /tmp/sds_test\n        /tmp/sds_test\n```\n\n但是实际编译后会发现会报很多函数未定义的错。原因是redis源码里面sds的内存分配、释放、重分配这些函数是封装成zmalloc,zfee这些函数的，只单纯的把zmalloc.c提取出来是远远不够的。后面发现redis的作者已经把sds给单独提出来了。包括三个源文件`sds.c`,`sds.h`,`sdsalloc.h` 因此执行如下操作即可单独把redis的sds模块提取出来。\n\n### 提取sds模块\n\n1. 新建redis_sds测试目录\n\n   选择合适的目录下新建\n\n   `mkdir redis_sds`\n\n2. 复制源文件至redis_sds目录下\n\n   在redis源码的src目录下执行：\n\n   `cp sds.c ~/redis_sds/`\n\n   `cp sds.h ~/redis_sds/`\n\n   `cp sdsalloc.h ~/redis_sds/`\n\n3. 修改sdsalloc.h \n\n   复制过来的sdsalloc.h 将sds模块的内存函数封装为使用zmalloc函数。为了简化处理直接使用libc的malloc函数来进行内存管理，同时将zmalloc.h给注释掉。\n\n   ```c\n   //#include \"zmalloc.h\"\n   #define s_malloc malloc\n   #define s_realloc realloc\n   #define s_free free\n   ```\n\n4. 新建主函数\n\n   新建主函数sds_test.c\n\n   ```c\n   #include <stdio.h>\n   #include <stdlib.h>\n   #include \"sds.c\"\n   //#include \"sds.h\"\n   int main(int argc, char *argv[]) {\n       sds s = sdsnew(\"Hello World!\");\n       printf(\"Length:%d, Type:%d\\n\", sdslen(s), sdsReqType(sdslen(s)));\n   \n       s = sdscat(s, \"The length of this sentence is greater than 32 bytes\");\n       printf(\"Length:%d, Type:%d\\n\", sdslen(s), sdsReqType(sdslen(s)));\n   \n       sdsfree(s);\n       return 0;\n   }\n   ```\n\n   直接include sds.c 即可，因为如果#include “sds.h” 的话，sdsReqType这个函数并没有在sds.h里面声明，而且因为sdsReqType的申明是：\n\n   `static inline char sdsReqType(size_t string_size) {`  有static限制所以不能在sds.h中先声明，所以为了简单就直接#include 了sds.c了\n\n5. 编译  \n\n   为了方便重复编译，所以写了个简单的Makefile。\n\n   ```\n   test : sds_test.c sds.h sds.c sdsalloc.h\n           gcc -o sdstest sds_test.c\n   ```\n\n   只需要编译sds_test.c 即可。因为sds_test.c 里面是直接#include sds.c 了所以再\n\n   `gcc -o sdstest sds_test.c sds.c` 会将sds.c 里面的函数重复编译两次，造成Multiple definition 问题。\n\n   之后只需要执行make命令就可以生成可执行文件sdstest。\n\n   执行后输出为：\n\n   ```\n   ./sdstest \n   Length:12, Type:0\n   Length:64, Type:1\n   ```\n\n   ### sds的创建\n\n   通过`sdsnew` 来创建了一个sds。sdsnew源码为：\n\n   ```c\n   /* Create a new sds string starting from a null terminated C string. */\n   sds sdsnew(const char *init) {\n       //使用？条件判断符来简化if语句对NULL的判断，直接使用strlen来返回字符指针的长度。\n       size_t initlen = (init == NULL) ? 0 : strlen(init); \n       return sdsnewlen(init, initlen);\n   }\n   ```\n\n   需要注意的是字符数组和字符指针是有区别的：字符指针的数据是存放在进程的虚拟地址空间的程序代码和数据段，是只读的不能修改。字符数组存放的字符串数据是存放在用户栈的，是可以更改的。且字符指针的数据没有\"\\0\"这个结束符。\n\n   参考博客讲的很好：<https://blog.csdn.net/on_1y/article/details/13030439>\n\n   `sdsnew` 通过把字符串长度和字符串传递给`sdsnewlen`，来完成创建。\n\n   ```c\n   \n   /* Create a new sds string with the content specified by the 'init' pointer\n    * and 'initlen'.\n    * If NULL is used for 'init' the string is initialized with zero bytes.\n    *\n    * The string is always null-termined (all the sds strings are, always) so\n    * even if you create an sds string with:\n    *\n    * mystring = n(\"abc\",3);\n    *\n    * You can print the string with printf() as there is an implicit \\0 at the\n    * end of the string. However the string is binary safe and can contain\n    * \\0 characters in the middle, as the length is stored in the sds header. */\n   sds sdsnewlen(const void *init, size_t initlen) {\n       void *sh;\n       sds s;\n       char type = sdsReqType(initlen);  //返回字符串对应的type\n       /* Empty strings are usually created in order to append. Use type 8\n        * since type 5 is not good at this. */\n       /*\n       空字符串使用sdshdr8来存储，而不是sdshdr5,（虽然长度小于32），因为sdshdr5不适合扩容。\n       */\n       if (type == SDS_TYPE_5 && initlen == 0) type = SDS_TYPE_8;\n       int hdrlen = sdsHdrSize(type); // 返回对应类型的sdsheader长度。\n       unsigned char *fp; /* flags pointer. */\n   \n       sh = s_malloc(hdrlen+initlen+1); // 申请头部+字符串+NULL的大小。(单位为byte)\n       if (!init)\n           memset(sh, 0, hdrlen+initlen+1); // 将sh后面对应大小的字节全部置为0；\n       if (sh == NULL) return NULL;\n       s = (char*)sh+hdrlen; //s指针指向字符串的首字节。\n       fp = ((unsigned char*)s)-1; // fp指针指向flag\n       switch(type) {  // 初始化sdshdr\n           case SDS_TYPE_5: {\n               *fp = type | (initlen << SDS_TYPE_BITS);// 设置flag这个字节的具体值\n               break;\n           }\n           case SDS_TYPE_8: {\n               SDS_HDR_VAR(8,s); // 获取header指针sh\n               sh->len = initlen; //header中len的初始\n               sh->alloc = initlen; //header 中alloc的初试\n               *fp = type;  //flag 的初始。\n               break;\n           }\n           case SDS_TYPE_16: {\n               SDS_HDR_VAR(16,s);\n               sh->len = initlen;\n               sh->alloc = initlen;\n               *fp = type; \n               break;\n           }\n           case SDS_TYPE_32: {\n               SDS_HDR_VAR(32,s);\n               sh->len = initlen;\n               sh->alloc = initlen;\n               *fp = type;\n               break;\n           }\n           case SDS_TYPE_64: {\n               SDS_HDR_VAR(64,s);\n               sh->len = initlen;\n               sh->alloc = initlen;\n               *fp = type;\n               break;\n           }\n       }\n       if (initlen && init)\n           memcpy(s, init, initlen); // 将字符串拷贝到s(也就是buf数组)\n       s[initlen] = '\\0'; //在字符串后面添加终止符\n       return s;\n   }\n   ```\n\n   `    char type = sdsReqType(initlen);` 获取sds类型，源码分析在读书笔记里面有记录。源码为\n\n   ```c\n   static inline char sdsReqType(size_t string_size) {\n       if (string_size < 1<<5) // string_size < 2^5\n           return SDS_TYPE_5;\n       if (string_size < 1<<8)  //string_size < 2^8\n           return SDS_TYPE_8;\n       if (string_size < 1<<16)\t//string_size < 2^16\n           return SDS_TYPE_16;\n   #if (LONG_MAX == LLONG_MAX)\n       if (string_size < 1ll<<32)  //string_size < 2^32\n           return SDS_TYPE_32;\n   #endif\n       return SDS_TYPE_64; \n   }\n   ```\n\n   采用左移来计算对应多少位的范围，而不是用2^5 这样的乘法。**直接移位比使用幂来计算快很多**。\n\n   `1<<5`   计算出来就是2^5 次方。1是int型，4byte32位。最低8bit位的二进制为：00000001 左移5位后变成了：00100000 对应的十进制既是32。\n\n   计算n个bit位的最大值：(1<<n) -1\n\n   但是需要注意位数不够的情况。因为1是int型，只有32个bit。所以在左移32个bit时，需要使用long long int型。用1ll来表示，此时1ll为64个bit。\n\n   还得考虑机器是否为64位机器，在32位机器上LONG_MAX = 2147483647L，64位机器上LONG_MAX = 9223372036854775807L 。不论32位机器还是64位机器上 LLONG_MAX 都是9223372036854775807L 。所以当LONG_MAX == LLONG_MAX 说明字长为64bit。加上条件编译，说明在32位机器上不使用sdshdr32而直接跳到了sdshdr64，仅仅在64位机器上使用sdshdr32。原因是什么？还没想通\n\n   ```c\n   static inline int sdsHdrSize(char type) {\n       switch(type&SDS_TYPE_MASK) {\n           case SDS_TYPE_5:\n               return sizeof(struct sdshdr5);\n           case SDS_TYPE_8:\n               return sizeof(struct sdshdr8);\n           case SDS_TYPE_16:\n               return sizeof(struct sdshdr16);\n           case SDS_TYPE_32:\n               return sizeof(struct sdshdr32);\n           case SDS_TYPE_64:\n               return sizeof(struct sdshdr64);\n       }\n       return 0;\n   }\n   ```\n\n   因为struct里面的buf数组是柔性数组，计算结构体的大小的时候不会计算在内。\n\n   `memset(sh, 0, hdrlen+initlen+1);`  memset函数会将sh中当前位置后面的`hdrlen+initlen+1`个字节全部置于0。 注意sh指向的是`hdrlen+initlen+1` 个字节的首个字节。（sh指针存储的地址就是首个字节的地址。） \n\n   memset源码为：<https://github.com/gcc-mirror/gcc/blob/master/libgcc/memset.c>\n\n   ```c\n   /* Public domain.  */\n   #include <stddef.h>\n   \n   void *\n   memset (void *dest, int val, size_t len)\n   {\n     unsigned char *ptr = dest; // 用char来限定每次指针+1只移动一个字节。\n     while (len-- > 0)\n       *ptr++ = val;\n     return dest;\n   }\n   ```\n\n   假设`hdrlen+initlen+1` 为8 ，经过memset后，从sh首字节开始共有8个字节都被置为0。\n\n   ![](https://res.cloudinary.com/bravey/image/upload/v1553525055/blog/memset.png)\n\n   指针的类型时用来确定指针需要从首地址寻址（偏移）多少个字节。比如int * 指针说明指针存储的地址朝后面偏移3个字节才是这个int类型的所有数据。即指针存储的地址时起点，而终点是由类型来确定的。此外，类型也是指针加减的步长，比如char类型的步长就是1byte，而uint_16类型的指针步长就是2byte。\n\n   随后用switch语句对不同类型的sdshdr设置初始值。\n\n   首先是sdshdr5\n\n    `*fp = type | (initlen << SDS_TYPE_BITS)` 使用移位和或操作的方式来对8个bit位赋值。(不得不感慨这些操作真的是太巧妙了)\n\n   假设initlen为3。则initlen的二进制为0000 0011（应该是8byte（64位机器）或者4byte（32位机器），为了简单用1byte的二进制表示）而SDS_TYPE_BITS 为3。所以先将initlen 左移3个bit 变成0000 0001 1000(共有8byte或者4byte)。再与type进行或运算。type为0000 0000 进行或运算后，得到的内容是8bit的，因为type是char类型，即0001 1000 。\n\n   其他sdshdr类型的设置都差不多，详解下sdshdr8.\n\n   `SDS_HDR_VAR(8,s)`  `SDS_HDR_VAR` 是个宏定义的函数\n\n   `#define SDS_HDR_VAR(T,s) struct sdshdr##T *sh = (void*)((s)-(sizeof(struct sdshdr##T)));`\n\n   采用宏定义函数的好处是\n\n   1. 能够减少额外的开销 因为如果写成普通函数的话，函数的调用会在用户栈开辟空间，形参压栈，返回时还需要释放栈，可想而知的开销。使用宏定义函数则在代码规模和速度方面都比函数更胜一筹。宏定义的本质就是替换，所以在使用宏定义函数的地方，执行的时候相当于是在直接执行`struct sdshdr##T *sh = (void*)((s)-(sizeof(struct sdshdr##T)))` 这句代码\n   2. 函数的参数必须被声明为一种特定的类型，所以它只能在类型合适的表达式上使用。而宏定义则可以用于整形、长整形、单浮点型、双浮点型以及其他任何可以用“>”操作符比较值大小的类型，也就是说，宏是与类型无关的。（有点C++模版类的感觉）\n\n   宏定义函数中的## 是（token-pasting）**符号连接操作符** 直接将形参T链接到sdshdr上面。也就是sdshdrT。\n\n   所以这句代码也就很简单了，将字符串指针s向后移动header的大小，也就得到了header的指针。（不过有个疑问是为什么还要重新获取headr的地址，最开始不就是指向了header吗？，难道memset是直接对sh进行操作的？测试过了，memset不会修改sh的地址，所以应该是为了再次确保sh一定指向header）\n\n   解释一下：SDS_HDR_VAR 的作用是将sh的类型修改为结构体指针，因为之前sh 一直都是空指针，(虽然指针的指向地址是headr，但是没有限定它类型)不然后面没法用sh->len, sh->alloc 来访问对应的结构体成员。\n\n   最开始创建的时候alloc 和len是一样大的，没有分配多余空间）\n\n   `memcpy(s, init, initlen);` 函数将init的前initlen个字符拷贝给s。\n\n   memcpy源码为：\n\n   ```\n   /* Public domain.  */\n   #include <stddef.h>\n   \n   void *\n   memcpy (void *dest, const void *src, size_t len)\n   {\n     char *d = dest;\n     const char *s = src;\n     while (len--)\n       *d++ = *s++;\n     return dest;\n   }\n   ```\n\n   整个过程中的三个指针sh,s,fp对应关系如下图\n\n   ![](https://res.cloudinary.com/bravey/image/upload/v1553525055/blog/sds.png)\n\n\n\n## 销毁\n\n销毁使用sdsfree来实现\n\n源码为：\n\n```c\n/* Free an sds string. No operation is performed if 's' is NULL. */\nvoid sdsfree(sds s) {\n    if (s == NULL) return;\n    s_free((char*)s-sdsHdrSize(s[-1]));\n}\n```\n\ns[-1],就是指针s向后移动移位，也就是flag的位置。将s移动到sh的位置，释放sh指针也就释放了整个sds内存。\n\n疑惑：sh指针在sdsnewlen函数中是个局部变量，在sdsnewlen函数中是自动释放的，这里并没有传递sh指针为什么也可以释放对应的空间？\n\n自己想了下：malloc 函数传递的参数是需要分配的内存大小(len)，返回的是指针也就是地址。free()函数只用将malloc函数返回的指针(地址)作为参数传入，就可以释放之前该地址分配到的内存空间。而地址只是首地址，总共的偏移量（大小），应该是由操作系统在内存分配的时候就记录了的。\n\n博客中记录：申请的时候实际上占用的内存要比申请的大。因为超出的空间是用来记录对这块内存的管理信息。额外的空间用来记录管理信息——分配块的长度，指向下一个分配块的指针等等。果然malloc的时候用来一个struct来记录分配的信息。\n\n```c\n  struct mem_control_block { \n    int is_available;    //一般来说应该是一个可用空间的首地址，但这里英文单词却显示出空间是否可用的一个标记\n    int size;            //这是实际空间的大小 \n    };\n```\n\n<http://www.cnblogs.com/hanyonglu/archive/2011/04/28/2031271.html>\n\nfree()就是根据这个结构体的信息来释放malloc()申请的空间\n\n另外的疑惑：释放完空间后，s 指针不用把它指向null吗？  \n\n\n\n暂时就只是创建和销毁的源码把，看了两天，阅读源码真的是酣畅淋漓，收获良多。学到了很多奇妙的C技巧，还对操作系统的知识有了更具象的理解。\n\n## 其他\n\n阅读sdsfromlonglong部分的源码：\n\nsdsfromlonglong 函数用于将一个long long 类型的整形数字转换为字符数组。\n\n```c\n/* Create an sds string from a long long value. It is much faster than:\n *\n * sdscatprintf(sdsempty(),\"%lld\\n\", value);\n */\nsds sdsfromlonglong(long long value) {\n    char buf[SDS_LLSTR_SIZE];  // 给buf数组分配最小的空间，21的长度\n    int len = sdsll2str(buf,value); //将long long 转为字符数组存储在buf中，并返回字符串的长度\n\n    return sdsnewlen(buf,len);\n}\n```\n\n可以看到主要的转换操作在sdsll2str这个函数中：\n\n```c\n/* Helper for sdscatlonglong() doing the actual number -> string\n * conversion. 's' must point to a string with room for at least\n * SDS_LLSTR_SIZE bytes.\n *\n * The function returns the length of the null-terminated string\n * representation stored at 's'. */\n#define SDS_LLSTR_SIZE 21\nint sdsll2str(char *s, long long value) {\n    char *p, aux;\n    unsigned long long v; \n    size_t l;\n\n    /* Generate the string representation, this method produces\n     * an reversed string. */\n    v = (value < 0) ? -value : value;  //判断是否为负数\n    p = s;\n    do {\n        *p++ = '0'+(v%10); // 除以10取余数\n        v /= 10;     //去除个位\n    } while(v);\n    if (value < 0) *p++ = '-';\n\n    /* Compute length and add null term. */\n    l = p-s;   // 计算出字符串的长度 不含终止符\n    *p = '\\0'; // 首地址填终止符。\n\n    /* Reverse the string. */\n    p--;\n    while(s < p) {\n        aux = *s;\n        *s = *p;\n        *p = aux;\n        s++;\n        p--;\n    }\n    return l;\n}\n```\n\n```c\n    do {\n        *p++ = '0'+(v%10); // 除以10取余数\n        v /= 10;     //去除个位\n    } while(v);\n```\n\n假设v是352，变成字符串是将每一个对应的10进制上面的3,5,2这三个个位、十位、百位的数字给单独变成字符。\n\n`*p++ = '0'+(v%10); ` p 指针是字符数组buf的首地址，而将整型变成字符型的操作就是与字符'0' 相加，这样就可以对应的数字变成字符类型。同时p相应的加1来指向下一个byte用来存储下一个被转换的char。\n\nchar类型存储的是对应字符的ascii值，ASCII表为：<https://baike.baidu.com/item/ASCII/309296> ，所以字符的运算实际上是对应的ASCII的值的运算。\nv%10是除以10取余数，352%10 =2； 35%10=5，所以也就是取得v值的10进制上面的个位数。\n所以在while循环里面每次对v除以10并取余，就可以得到对应long long 型的字符串。\n但是因为每次得到的字符都是最后面的个位数，所以352，所输出的字符串数组为：‘2’， ‘3’， ‘5’ 是一个倒序的，因此还需要再反转一次。\n\n```c\n/* Reverse the string. */ \np--;\nwhile(s < p) {\n    aux = *s;\n    *s = *p;\n    *p = aux;\n    s++;\n    p--;\n}\n```\n字符串反转，首尾各有一个指针，当首指针小于尾指针的时候，交换数字，并同时向中间移动\n\n## 参考资料\n\n<https://blog.csdn.net/yangbodong22011/article/details/78419966>","source":"_posts/Redis源码阅读——SDS/2019-03-22-Redis源码阅读——SDS.md","raw":"---\ntitle: Redis源码阅读——SDS\ndate: 2019-03-22 15:58:45\ncategories: 源码阅读\ntags:\n- redis\n- 源码阅读\ncopyright: true\n---\n\n# Redis源码阅读——SDS\n\n参考Redis设计与实现 以及网上博客阅读Redis源码。\n\n<!--more-->\n\nSDS相关知识点见读书笔记。\n\n## 创建和销毁\n\n为了能够对sds进行相关API的测试，因此把sds模块单独提出来。阅读Redis的Makefile发现，编译sds模块需要的源文件包括`sds.c`, `sds.h` `zmalloc.c` \n\n```Make\ntest-sds: sds.c sds.h\n        $(REDIS_CC) sds.c zmalloc.c -DSDS_TEST_MAIN $(FINAL_LIBS) -o /tmp/sds_test\n        /tmp/sds_test\n```\n\n但是实际编译后会发现会报很多函数未定义的错。原因是redis源码里面sds的内存分配、释放、重分配这些函数是封装成zmalloc,zfee这些函数的，只单纯的把zmalloc.c提取出来是远远不够的。后面发现redis的作者已经把sds给单独提出来了。包括三个源文件`sds.c`,`sds.h`,`sdsalloc.h` 因此执行如下操作即可单独把redis的sds模块提取出来。\n\n### 提取sds模块\n\n1. 新建redis_sds测试目录\n\n   选择合适的目录下新建\n\n   `mkdir redis_sds`\n\n2. 复制源文件至redis_sds目录下\n\n   在redis源码的src目录下执行：\n\n   `cp sds.c ~/redis_sds/`\n\n   `cp sds.h ~/redis_sds/`\n\n   `cp sdsalloc.h ~/redis_sds/`\n\n3. 修改sdsalloc.h \n\n   复制过来的sdsalloc.h 将sds模块的内存函数封装为使用zmalloc函数。为了简化处理直接使用libc的malloc函数来进行内存管理，同时将zmalloc.h给注释掉。\n\n   ```c\n   //#include \"zmalloc.h\"\n   #define s_malloc malloc\n   #define s_realloc realloc\n   #define s_free free\n   ```\n\n4. 新建主函数\n\n   新建主函数sds_test.c\n\n   ```c\n   #include <stdio.h>\n   #include <stdlib.h>\n   #include \"sds.c\"\n   //#include \"sds.h\"\n   int main(int argc, char *argv[]) {\n       sds s = sdsnew(\"Hello World!\");\n       printf(\"Length:%d, Type:%d\\n\", sdslen(s), sdsReqType(sdslen(s)));\n   \n       s = sdscat(s, \"The length of this sentence is greater than 32 bytes\");\n       printf(\"Length:%d, Type:%d\\n\", sdslen(s), sdsReqType(sdslen(s)));\n   \n       sdsfree(s);\n       return 0;\n   }\n   ```\n\n   直接include sds.c 即可，因为如果#include “sds.h” 的话，sdsReqType这个函数并没有在sds.h里面声明，而且因为sdsReqType的申明是：\n\n   `static inline char sdsReqType(size_t string_size) {`  有static限制所以不能在sds.h中先声明，所以为了简单就直接#include 了sds.c了\n\n5. 编译  \n\n   为了方便重复编译，所以写了个简单的Makefile。\n\n   ```\n   test : sds_test.c sds.h sds.c sdsalloc.h\n           gcc -o sdstest sds_test.c\n   ```\n\n   只需要编译sds_test.c 即可。因为sds_test.c 里面是直接#include sds.c 了所以再\n\n   `gcc -o sdstest sds_test.c sds.c` 会将sds.c 里面的函数重复编译两次，造成Multiple definition 问题。\n\n   之后只需要执行make命令就可以生成可执行文件sdstest。\n\n   执行后输出为：\n\n   ```\n   ./sdstest \n   Length:12, Type:0\n   Length:64, Type:1\n   ```\n\n   ### sds的创建\n\n   通过`sdsnew` 来创建了一个sds。sdsnew源码为：\n\n   ```c\n   /* Create a new sds string starting from a null terminated C string. */\n   sds sdsnew(const char *init) {\n       //使用？条件判断符来简化if语句对NULL的判断，直接使用strlen来返回字符指针的长度。\n       size_t initlen = (init == NULL) ? 0 : strlen(init); \n       return sdsnewlen(init, initlen);\n   }\n   ```\n\n   需要注意的是字符数组和字符指针是有区别的：字符指针的数据是存放在进程的虚拟地址空间的程序代码和数据段，是只读的不能修改。字符数组存放的字符串数据是存放在用户栈的，是可以更改的。且字符指针的数据没有\"\\0\"这个结束符。\n\n   参考博客讲的很好：<https://blog.csdn.net/on_1y/article/details/13030439>\n\n   `sdsnew` 通过把字符串长度和字符串传递给`sdsnewlen`，来完成创建。\n\n   ```c\n   \n   /* Create a new sds string with the content specified by the 'init' pointer\n    * and 'initlen'.\n    * If NULL is used for 'init' the string is initialized with zero bytes.\n    *\n    * The string is always null-termined (all the sds strings are, always) so\n    * even if you create an sds string with:\n    *\n    * mystring = n(\"abc\",3);\n    *\n    * You can print the string with printf() as there is an implicit \\0 at the\n    * end of the string. However the string is binary safe and can contain\n    * \\0 characters in the middle, as the length is stored in the sds header. */\n   sds sdsnewlen(const void *init, size_t initlen) {\n       void *sh;\n       sds s;\n       char type = sdsReqType(initlen);  //返回字符串对应的type\n       /* Empty strings are usually created in order to append. Use type 8\n        * since type 5 is not good at this. */\n       /*\n       空字符串使用sdshdr8来存储，而不是sdshdr5,（虽然长度小于32），因为sdshdr5不适合扩容。\n       */\n       if (type == SDS_TYPE_5 && initlen == 0) type = SDS_TYPE_8;\n       int hdrlen = sdsHdrSize(type); // 返回对应类型的sdsheader长度。\n       unsigned char *fp; /* flags pointer. */\n   \n       sh = s_malloc(hdrlen+initlen+1); // 申请头部+字符串+NULL的大小。(单位为byte)\n       if (!init)\n           memset(sh, 0, hdrlen+initlen+1); // 将sh后面对应大小的字节全部置为0；\n       if (sh == NULL) return NULL;\n       s = (char*)sh+hdrlen; //s指针指向字符串的首字节。\n       fp = ((unsigned char*)s)-1; // fp指针指向flag\n       switch(type) {  // 初始化sdshdr\n           case SDS_TYPE_5: {\n               *fp = type | (initlen << SDS_TYPE_BITS);// 设置flag这个字节的具体值\n               break;\n           }\n           case SDS_TYPE_8: {\n               SDS_HDR_VAR(8,s); // 获取header指针sh\n               sh->len = initlen; //header中len的初始\n               sh->alloc = initlen; //header 中alloc的初试\n               *fp = type;  //flag 的初始。\n               break;\n           }\n           case SDS_TYPE_16: {\n               SDS_HDR_VAR(16,s);\n               sh->len = initlen;\n               sh->alloc = initlen;\n               *fp = type; \n               break;\n           }\n           case SDS_TYPE_32: {\n               SDS_HDR_VAR(32,s);\n               sh->len = initlen;\n               sh->alloc = initlen;\n               *fp = type;\n               break;\n           }\n           case SDS_TYPE_64: {\n               SDS_HDR_VAR(64,s);\n               sh->len = initlen;\n               sh->alloc = initlen;\n               *fp = type;\n               break;\n           }\n       }\n       if (initlen && init)\n           memcpy(s, init, initlen); // 将字符串拷贝到s(也就是buf数组)\n       s[initlen] = '\\0'; //在字符串后面添加终止符\n       return s;\n   }\n   ```\n\n   `    char type = sdsReqType(initlen);` 获取sds类型，源码分析在读书笔记里面有记录。源码为\n\n   ```c\n   static inline char sdsReqType(size_t string_size) {\n       if (string_size < 1<<5) // string_size < 2^5\n           return SDS_TYPE_5;\n       if (string_size < 1<<8)  //string_size < 2^8\n           return SDS_TYPE_8;\n       if (string_size < 1<<16)\t//string_size < 2^16\n           return SDS_TYPE_16;\n   #if (LONG_MAX == LLONG_MAX)\n       if (string_size < 1ll<<32)  //string_size < 2^32\n           return SDS_TYPE_32;\n   #endif\n       return SDS_TYPE_64; \n   }\n   ```\n\n   采用左移来计算对应多少位的范围，而不是用2^5 这样的乘法。**直接移位比使用幂来计算快很多**。\n\n   `1<<5`   计算出来就是2^5 次方。1是int型，4byte32位。最低8bit位的二进制为：00000001 左移5位后变成了：00100000 对应的十进制既是32。\n\n   计算n个bit位的最大值：(1<<n) -1\n\n   但是需要注意位数不够的情况。因为1是int型，只有32个bit。所以在左移32个bit时，需要使用long long int型。用1ll来表示，此时1ll为64个bit。\n\n   还得考虑机器是否为64位机器，在32位机器上LONG_MAX = 2147483647L，64位机器上LONG_MAX = 9223372036854775807L 。不论32位机器还是64位机器上 LLONG_MAX 都是9223372036854775807L 。所以当LONG_MAX == LLONG_MAX 说明字长为64bit。加上条件编译，说明在32位机器上不使用sdshdr32而直接跳到了sdshdr64，仅仅在64位机器上使用sdshdr32。原因是什么？还没想通\n\n   ```c\n   static inline int sdsHdrSize(char type) {\n       switch(type&SDS_TYPE_MASK) {\n           case SDS_TYPE_5:\n               return sizeof(struct sdshdr5);\n           case SDS_TYPE_8:\n               return sizeof(struct sdshdr8);\n           case SDS_TYPE_16:\n               return sizeof(struct sdshdr16);\n           case SDS_TYPE_32:\n               return sizeof(struct sdshdr32);\n           case SDS_TYPE_64:\n               return sizeof(struct sdshdr64);\n       }\n       return 0;\n   }\n   ```\n\n   因为struct里面的buf数组是柔性数组，计算结构体的大小的时候不会计算在内。\n\n   `memset(sh, 0, hdrlen+initlen+1);`  memset函数会将sh中当前位置后面的`hdrlen+initlen+1`个字节全部置于0。 注意sh指向的是`hdrlen+initlen+1` 个字节的首个字节。（sh指针存储的地址就是首个字节的地址。） \n\n   memset源码为：<https://github.com/gcc-mirror/gcc/blob/master/libgcc/memset.c>\n\n   ```c\n   /* Public domain.  */\n   #include <stddef.h>\n   \n   void *\n   memset (void *dest, int val, size_t len)\n   {\n     unsigned char *ptr = dest; // 用char来限定每次指针+1只移动一个字节。\n     while (len-- > 0)\n       *ptr++ = val;\n     return dest;\n   }\n   ```\n\n   假设`hdrlen+initlen+1` 为8 ，经过memset后，从sh首字节开始共有8个字节都被置为0。\n\n   ![](https://res.cloudinary.com/bravey/image/upload/v1553525055/blog/memset.png)\n\n   指针的类型时用来确定指针需要从首地址寻址（偏移）多少个字节。比如int * 指针说明指针存储的地址朝后面偏移3个字节才是这个int类型的所有数据。即指针存储的地址时起点，而终点是由类型来确定的。此外，类型也是指针加减的步长，比如char类型的步长就是1byte，而uint_16类型的指针步长就是2byte。\n\n   随后用switch语句对不同类型的sdshdr设置初始值。\n\n   首先是sdshdr5\n\n    `*fp = type | (initlen << SDS_TYPE_BITS)` 使用移位和或操作的方式来对8个bit位赋值。(不得不感慨这些操作真的是太巧妙了)\n\n   假设initlen为3。则initlen的二进制为0000 0011（应该是8byte（64位机器）或者4byte（32位机器），为了简单用1byte的二进制表示）而SDS_TYPE_BITS 为3。所以先将initlen 左移3个bit 变成0000 0001 1000(共有8byte或者4byte)。再与type进行或运算。type为0000 0000 进行或运算后，得到的内容是8bit的，因为type是char类型，即0001 1000 。\n\n   其他sdshdr类型的设置都差不多，详解下sdshdr8.\n\n   `SDS_HDR_VAR(8,s)`  `SDS_HDR_VAR` 是个宏定义的函数\n\n   `#define SDS_HDR_VAR(T,s) struct sdshdr##T *sh = (void*)((s)-(sizeof(struct sdshdr##T)));`\n\n   采用宏定义函数的好处是\n\n   1. 能够减少额外的开销 因为如果写成普通函数的话，函数的调用会在用户栈开辟空间，形参压栈，返回时还需要释放栈，可想而知的开销。使用宏定义函数则在代码规模和速度方面都比函数更胜一筹。宏定义的本质就是替换，所以在使用宏定义函数的地方，执行的时候相当于是在直接执行`struct sdshdr##T *sh = (void*)((s)-(sizeof(struct sdshdr##T)))` 这句代码\n   2. 函数的参数必须被声明为一种特定的类型，所以它只能在类型合适的表达式上使用。而宏定义则可以用于整形、长整形、单浮点型、双浮点型以及其他任何可以用“>”操作符比较值大小的类型，也就是说，宏是与类型无关的。（有点C++模版类的感觉）\n\n   宏定义函数中的## 是（token-pasting）**符号连接操作符** 直接将形参T链接到sdshdr上面。也就是sdshdrT。\n\n   所以这句代码也就很简单了，将字符串指针s向后移动header的大小，也就得到了header的指针。（不过有个疑问是为什么还要重新获取headr的地址，最开始不就是指向了header吗？，难道memset是直接对sh进行操作的？测试过了，memset不会修改sh的地址，所以应该是为了再次确保sh一定指向header）\n\n   解释一下：SDS_HDR_VAR 的作用是将sh的类型修改为结构体指针，因为之前sh 一直都是空指针，(虽然指针的指向地址是headr，但是没有限定它类型)不然后面没法用sh->len, sh->alloc 来访问对应的结构体成员。\n\n   最开始创建的时候alloc 和len是一样大的，没有分配多余空间）\n\n   `memcpy(s, init, initlen);` 函数将init的前initlen个字符拷贝给s。\n\n   memcpy源码为：\n\n   ```\n   /* Public domain.  */\n   #include <stddef.h>\n   \n   void *\n   memcpy (void *dest, const void *src, size_t len)\n   {\n     char *d = dest;\n     const char *s = src;\n     while (len--)\n       *d++ = *s++;\n     return dest;\n   }\n   ```\n\n   整个过程中的三个指针sh,s,fp对应关系如下图\n\n   ![](https://res.cloudinary.com/bravey/image/upload/v1553525055/blog/sds.png)\n\n\n\n## 销毁\n\n销毁使用sdsfree来实现\n\n源码为：\n\n```c\n/* Free an sds string. No operation is performed if 's' is NULL. */\nvoid sdsfree(sds s) {\n    if (s == NULL) return;\n    s_free((char*)s-sdsHdrSize(s[-1]));\n}\n```\n\ns[-1],就是指针s向后移动移位，也就是flag的位置。将s移动到sh的位置，释放sh指针也就释放了整个sds内存。\n\n疑惑：sh指针在sdsnewlen函数中是个局部变量，在sdsnewlen函数中是自动释放的，这里并没有传递sh指针为什么也可以释放对应的空间？\n\n自己想了下：malloc 函数传递的参数是需要分配的内存大小(len)，返回的是指针也就是地址。free()函数只用将malloc函数返回的指针(地址)作为参数传入，就可以释放之前该地址分配到的内存空间。而地址只是首地址，总共的偏移量（大小），应该是由操作系统在内存分配的时候就记录了的。\n\n博客中记录：申请的时候实际上占用的内存要比申请的大。因为超出的空间是用来记录对这块内存的管理信息。额外的空间用来记录管理信息——分配块的长度，指向下一个分配块的指针等等。果然malloc的时候用来一个struct来记录分配的信息。\n\n```c\n  struct mem_control_block { \n    int is_available;    //一般来说应该是一个可用空间的首地址，但这里英文单词却显示出空间是否可用的一个标记\n    int size;            //这是实际空间的大小 \n    };\n```\n\n<http://www.cnblogs.com/hanyonglu/archive/2011/04/28/2031271.html>\n\nfree()就是根据这个结构体的信息来释放malloc()申请的空间\n\n另外的疑惑：释放完空间后，s 指针不用把它指向null吗？  \n\n\n\n暂时就只是创建和销毁的源码把，看了两天，阅读源码真的是酣畅淋漓，收获良多。学到了很多奇妙的C技巧，还对操作系统的知识有了更具象的理解。\n\n## 其他\n\n阅读sdsfromlonglong部分的源码：\n\nsdsfromlonglong 函数用于将一个long long 类型的整形数字转换为字符数组。\n\n```c\n/* Create an sds string from a long long value. It is much faster than:\n *\n * sdscatprintf(sdsempty(),\"%lld\\n\", value);\n */\nsds sdsfromlonglong(long long value) {\n    char buf[SDS_LLSTR_SIZE];  // 给buf数组分配最小的空间，21的长度\n    int len = sdsll2str(buf,value); //将long long 转为字符数组存储在buf中，并返回字符串的长度\n\n    return sdsnewlen(buf,len);\n}\n```\n\n可以看到主要的转换操作在sdsll2str这个函数中：\n\n```c\n/* Helper for sdscatlonglong() doing the actual number -> string\n * conversion. 's' must point to a string with room for at least\n * SDS_LLSTR_SIZE bytes.\n *\n * The function returns the length of the null-terminated string\n * representation stored at 's'. */\n#define SDS_LLSTR_SIZE 21\nint sdsll2str(char *s, long long value) {\n    char *p, aux;\n    unsigned long long v; \n    size_t l;\n\n    /* Generate the string representation, this method produces\n     * an reversed string. */\n    v = (value < 0) ? -value : value;  //判断是否为负数\n    p = s;\n    do {\n        *p++ = '0'+(v%10); // 除以10取余数\n        v /= 10;     //去除个位\n    } while(v);\n    if (value < 0) *p++ = '-';\n\n    /* Compute length and add null term. */\n    l = p-s;   // 计算出字符串的长度 不含终止符\n    *p = '\\0'; // 首地址填终止符。\n\n    /* Reverse the string. */\n    p--;\n    while(s < p) {\n        aux = *s;\n        *s = *p;\n        *p = aux;\n        s++;\n        p--;\n    }\n    return l;\n}\n```\n\n```c\n    do {\n        *p++ = '0'+(v%10); // 除以10取余数\n        v /= 10;     //去除个位\n    } while(v);\n```\n\n假设v是352，变成字符串是将每一个对应的10进制上面的3,5,2这三个个位、十位、百位的数字给单独变成字符。\n\n`*p++ = '0'+(v%10); ` p 指针是字符数组buf的首地址，而将整型变成字符型的操作就是与字符'0' 相加，这样就可以对应的数字变成字符类型。同时p相应的加1来指向下一个byte用来存储下一个被转换的char。\n\nchar类型存储的是对应字符的ascii值，ASCII表为：<https://baike.baidu.com/item/ASCII/309296> ，所以字符的运算实际上是对应的ASCII的值的运算。\nv%10是除以10取余数，352%10 =2； 35%10=5，所以也就是取得v值的10进制上面的个位数。\n所以在while循环里面每次对v除以10并取余，就可以得到对应long long 型的字符串。\n但是因为每次得到的字符都是最后面的个位数，所以352，所输出的字符串数组为：‘2’， ‘3’， ‘5’ 是一个倒序的，因此还需要再反转一次。\n\n```c\n/* Reverse the string. */ \np--;\nwhile(s < p) {\n    aux = *s;\n    *s = *p;\n    *p = aux;\n    s++;\n    p--;\n}\n```\n字符串反转，首尾各有一个指针，当首指针小于尾指针的时候，交换数字，并同时向中间移动\n\n## 参考资料\n\n<https://blog.csdn.net/yangbodong22011/article/details/78419966>","slug":"Redis源码阅读——SDS/2019-03-22-Redis源码阅读——SDS","published":1,"updated":"2019-11-08T13:17:24.974Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2yelxjr005hm8tzd5i2lo20","content":"<h1 id=\"Redis源码阅读——SDS\"><a href=\"#Redis源码阅读——SDS\" class=\"headerlink\" title=\"Redis源码阅读——SDS\"></a>Redis源码阅读——SDS</h1><p>参考Redis设计与实现 以及网上博客阅读Redis源码。</p>\n<a id=\"more\"></a>\n<p>SDS相关知识点见读书笔记。</p>\n<h2 id=\"创建和销毁\"><a href=\"#创建和销毁\" class=\"headerlink\" title=\"创建和销毁\"></a>创建和销毁</h2><p>为了能够对sds进行相关API的测试，因此把sds模块单独提出来。阅读Redis的Makefile发现，编译sds模块需要的源文件包括<code>sds.c</code>, <code>sds.h</code> <code>zmalloc.c</code> </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test-sds: sds.c sds.h</span><br><span class=\"line\">        $(REDIS_CC) sds.c zmalloc.c -DSDS_TEST_MAIN $(FINAL_LIBS) -o /tmp/sds_test</span><br><span class=\"line\">        /tmp/sds_test</span><br></pre></td></tr></table></figure>\n<p>但是实际编译后会发现会报很多函数未定义的错。原因是redis源码里面sds的内存分配、释放、重分配这些函数是封装成zmalloc,zfee这些函数的，只单纯的把zmalloc.c提取出来是远远不够的。后面发现redis的作者已经把sds给单独提出来了。包括三个源文件<code>sds.c</code>,<code>sds.h</code>,<code>sdsalloc.h</code> 因此执行如下操作即可单独把redis的sds模块提取出来。</p>\n<h3 id=\"提取sds模块\"><a href=\"#提取sds模块\" class=\"headerlink\" title=\"提取sds模块\"></a>提取sds模块</h3><ol>\n<li><p>新建redis_sds测试目录</p>\n<p>选择合适的目录下新建</p>\n<p><code>mkdir redis_sds</code></p>\n</li>\n<li><p>复制源文件至redis_sds目录下</p>\n<p>在redis源码的src目录下执行：</p>\n<p><code>cp sds.c ~/redis_sds/</code></p>\n<p><code>cp sds.h ~/redis_sds/</code></p>\n<p><code>cp sdsalloc.h ~/redis_sds/</code></p>\n</li>\n<li><p>修改sdsalloc.h </p>\n<p>复制过来的sdsalloc.h 将sds模块的内存函数封装为使用zmalloc函数。为了简化处理直接使用libc的malloc函数来进行内存管理，同时将zmalloc.h给注释掉。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//#include \"zmalloc.h\"</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> s_malloc malloc</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> s_realloc realloc</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> s_free free</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>新建主函数</p>\n<p>新建主函数sds_test.c</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"sds.c\"</span></span></span><br><span class=\"line\"><span class=\"comment\">//#include \"sds.h\"</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span> </span>&#123;</span><br><span class=\"line\">    sds s = sdsnew(<span class=\"string\">\"Hello World!\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Length:%d, Type:%d\\n\"</span>, sdslen(s), sdsReqType(sdslen(s)));</span><br><span class=\"line\"></span><br><span class=\"line\">    s = sdscat(s, <span class=\"string\">\"The length of this sentence is greater than 32 bytes\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Length:%d, Type:%d\\n\"</span>, sdslen(s), sdsReqType(sdslen(s)));</span><br><span class=\"line\"></span><br><span class=\"line\">    sdsfree(s);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>直接include sds.c 即可，因为如果#include “sds.h” 的话，sdsReqType这个函数并没有在sds.h里面声明，而且因为sdsReqType的申明是：</p>\n<p><code>static inline char sdsReqType(size_t string_size) {</code>  有static限制所以不能在sds.h中先声明，所以为了简单就直接#include 了sds.c了</p>\n</li>\n<li><p>编译  </p>\n<p>为了方便重复编译，所以写了个简单的Makefile。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test : sds_test.c sds.h sds.c sdsalloc.h</span><br><span class=\"line\">        gcc -o sdstest sds_test.c</span><br></pre></td></tr></table></figure>\n<p>只需要编译sds_test.c 即可。因为sds_test.c 里面是直接#include sds.c 了所以再</p>\n<p><code>gcc -o sdstest sds_test.c sds.c</code> 会将sds.c 里面的函数重复编译两次，造成Multiple definition 问题。</p>\n<p>之后只需要执行make命令就可以生成可执行文件sdstest。</p>\n<p>执行后输出为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./sdstest </span><br><span class=\"line\">Length:12, Type:0</span><br><span class=\"line\">Length:64, Type:1</span><br></pre></td></tr></table></figure>\n<h3 id=\"sds的创建\"><a href=\"#sds的创建\" class=\"headerlink\" title=\"sds的创建\"></a>sds的创建</h3><p>通过<code>sdsnew</code> 来创建了一个sds。sdsnew源码为：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Create a new sds string starting from a null terminated C string. */</span></span><br><span class=\"line\"><span class=\"function\">sds <span class=\"title\">sdsnew</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *init)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//使用？条件判断符来简化if语句对NULL的判断，直接使用strlen来返回字符指针的长度。</span></span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> initlen = (init == <span class=\"literal\">NULL</span>) ? <span class=\"number\">0</span> : <span class=\"built_in\">strlen</span>(init); </span><br><span class=\"line\">    <span class=\"keyword\">return</span> sdsnewlen(init, initlen);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>需要注意的是字符数组和字符指针是有区别的：字符指针的数据是存放在进程的虚拟地址空间的程序代码和数据段，是只读的不能修改。字符数组存放的字符串数据是存放在用户栈的，是可以更改的。且字符指针的数据没有”\\0”这个结束符。</p>\n<p>参考博客讲的很好：<a href=\"https://blog.csdn.net/on_1y/article/details/13030439\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/on_1y/article/details/13030439</a></p>\n<p><code>sdsnew</code> 通过把字符串长度和字符串传递给<code>sdsnewlen</code>，来完成创建。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Create a new sds string with the content specified by the 'init' pointer</span></span><br><span class=\"line\"><span class=\"comment\"> * and 'initlen'.</span></span><br><span class=\"line\"><span class=\"comment\"> * If NULL is used for 'init' the string is initialized with zero bytes.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * The string is always null-termined (all the sds strings are, always) so</span></span><br><span class=\"line\"><span class=\"comment\"> * even if you create an sds string with:</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * mystring = n(\"abc\",3);</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * You can print the string with printf() as there is an implicit \\0 at the</span></span><br><span class=\"line\"><span class=\"comment\"> * end of the string. However the string is binary safe and can contain</span></span><br><span class=\"line\"><span class=\"comment\"> * \\0 characters in the middle, as the length is stored in the sds header. */</span></span><br><span class=\"line\"><span class=\"function\">sds <span class=\"title\">sdsnewlen</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *init, <span class=\"keyword\">size_t</span> initlen)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> *sh;</span><br><span class=\"line\">    sds s;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> type = sdsReqType(initlen);  <span class=\"comment\">//返回字符串对应的type</span></span><br><span class=\"line\">    <span class=\"comment\">/* Empty strings are usually created in order to append. Use type 8</span></span><br><span class=\"line\"><span class=\"comment\">     * since type 5 is not good at this. */</span></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    空字符串使用sdshdr8来存储，而不是sdshdr5,（虽然长度小于32），因为sdshdr5不适合扩容。</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type == SDS_TYPE_5 &amp;&amp; initlen == <span class=\"number\">0</span>) type = SDS_TYPE_8;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> hdrlen = sdsHdrSize(type); <span class=\"comment\">// 返回对应类型的sdsheader长度。</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *fp; <span class=\"comment\">/* flags pointer. */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    sh = s_malloc(hdrlen+initlen+<span class=\"number\">1</span>); <span class=\"comment\">// 申请头部+字符串+NULL的大小。(单位为byte)</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!init)</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(sh, <span class=\"number\">0</span>, hdrlen+initlen+<span class=\"number\">1</span>); <span class=\"comment\">// 将sh后面对应大小的字节全部置为0；</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sh == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    s = (<span class=\"keyword\">char</span>*)sh+hdrlen; <span class=\"comment\">//s指针指向字符串的首字节。</span></span><br><span class=\"line\">    fp = ((<span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span>*)s)<span class=\"number\">-1</span>; <span class=\"comment\">// fp指针指向flag</span></span><br><span class=\"line\">    <span class=\"keyword\">switch</span>(type) &#123;  <span class=\"comment\">// 初始化sdshdr</span></span><br><span class=\"line\">        <span class=\"keyword\">case</span> SDS_TYPE_5: &#123;</span><br><span class=\"line\">            *fp = type | (initlen &lt;&lt; SDS_TYPE_BITS);<span class=\"comment\">// 设置flag这个字节的具体值</span></span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> SDS_TYPE_8: &#123;</span><br><span class=\"line\">            SDS_HDR_VAR(<span class=\"number\">8</span>,s); <span class=\"comment\">// 获取header指针sh</span></span><br><span class=\"line\">            sh-&gt;len = initlen; <span class=\"comment\">//header中len的初始</span></span><br><span class=\"line\">            sh-&gt;alloc = initlen; <span class=\"comment\">//header 中alloc的初试</span></span><br><span class=\"line\">            *fp = type;  <span class=\"comment\">//flag 的初始。</span></span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> SDS_TYPE_16: &#123;</span><br><span class=\"line\">            SDS_HDR_VAR(<span class=\"number\">16</span>,s);</span><br><span class=\"line\">            sh-&gt;len = initlen;</span><br><span class=\"line\">            sh-&gt;alloc = initlen;</span><br><span class=\"line\">            *fp = type; </span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> SDS_TYPE_32: &#123;</span><br><span class=\"line\">            SDS_HDR_VAR(<span class=\"number\">32</span>,s);</span><br><span class=\"line\">            sh-&gt;len = initlen;</span><br><span class=\"line\">            sh-&gt;alloc = initlen;</span><br><span class=\"line\">            *fp = type;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> SDS_TYPE_64: &#123;</span><br><span class=\"line\">            SDS_HDR_VAR(<span class=\"number\">64</span>,s);</span><br><span class=\"line\">            sh-&gt;len = initlen;</span><br><span class=\"line\">            sh-&gt;alloc = initlen;</span><br><span class=\"line\">            *fp = type;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (initlen &amp;&amp; init)</span><br><span class=\"line\">        <span class=\"built_in\">memcpy</span>(s, init, initlen); <span class=\"comment\">// 将字符串拷贝到s(也就是buf数组)</span></span><br><span class=\"line\">    s[initlen] = <span class=\"string\">'\\0'</span>; <span class=\"comment\">//在字符串后面添加终止符</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>char type = sdsReqType(initlen);</code> 获取sds类型，源码分析在读书笔记里面有记录。源码为</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">char</span> <span class=\"title\">sdsReqType</span><span class=\"params\">(<span class=\"keyword\">size_t</span> string_size)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (string_size &lt; <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">5</span>) <span class=\"comment\">// string_size &lt; 2^5</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> SDS_TYPE_5;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (string_size &lt; <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">8</span>)  <span class=\"comment\">//string_size &lt; 2^8</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> SDS_TYPE_8;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (string_size &lt; <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">16</span>)\t<span class=\"comment\">//string_size &lt; 2^16</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> SDS_TYPE_16;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> (LONG_MAX == LLONG_MAX)</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (string_size &lt; <span class=\"number\">1l</span>l&lt;&lt;<span class=\"number\">32</span>)  <span class=\"comment\">//string_size &lt; 2^32</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> SDS_TYPE_32;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> SDS_TYPE_64; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>采用左移来计算对应多少位的范围，而不是用2^5 这样的乘法。<strong>直接移位比使用幂来计算快很多</strong>。</p>\n<p><code>1&lt;&lt;5</code>   计算出来就是2^5 次方。1是int型，4byte32位。最低8bit位的二进制为：00000001 左移5位后变成了：00100000 对应的十进制既是32。</p>\n<p>计算n个bit位的最大值：(1&lt;&lt;n) -1</p>\n<p>但是需要注意位数不够的情况。因为1是int型，只有32个bit。所以在左移32个bit时，需要使用long long int型。用1ll来表示，此时1ll为64个bit。</p>\n<p>还得考虑机器是否为64位机器，在32位机器上LONG_MAX = 2147483647L，64位机器上LONG_MAX = 9223372036854775807L 。不论32位机器还是64位机器上 LLONG_MAX 都是9223372036854775807L 。所以当LONG_MAX == LLONG_MAX 说明字长为64bit。加上条件编译，说明在32位机器上不使用sdshdr32而直接跳到了sdshdr64，仅仅在64位机器上使用sdshdr32。原因是什么？还没想通</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">sdsHdrSize</span><span class=\"params\">(<span class=\"keyword\">char</span> type)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span>(type&amp;SDS_TYPE_MASK) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> SDS_TYPE_5:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">sizeof</span>(struct sdshdr5);</span><br><span class=\"line\">        <span class=\"keyword\">case</span> SDS_TYPE_8:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">sizeof</span>(struct sdshdr8);</span><br><span class=\"line\">        <span class=\"keyword\">case</span> SDS_TYPE_16:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">sizeof</span>(struct sdshdr16);</span><br><span class=\"line\">        <span class=\"keyword\">case</span> SDS_TYPE_32:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">sizeof</span>(struct sdshdr32);</span><br><span class=\"line\">        <span class=\"keyword\">case</span> SDS_TYPE_64:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">sizeof</span>(struct sdshdr64);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>因为struct里面的buf数组是柔性数组，计算结构体的大小的时候不会计算在内。</p>\n<p><code>memset(sh, 0, hdrlen+initlen+1);</code>  memset函数会将sh中当前位置后面的<code>hdrlen+initlen+1</code>个字节全部置于0。 注意sh指向的是<code>hdrlen+initlen+1</code> 个字节的首个字节。（sh指针存储的地址就是首个字节的地址。） </p>\n<p>memset源码为：<a href=\"https://github.com/gcc-mirror/gcc/blob/master/libgcc/memset.c\" target=\"_blank\" rel=\"noopener\">https://github.com/gcc-mirror/gcc/blob/master/libgcc/memset.c</a></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Public domain.  */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stddef.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> *</span><br><span class=\"line\"><span class=\"built_in\">memset</span> (<span class=\"keyword\">void</span> *dest, <span class=\"keyword\">int</span> val, <span class=\"keyword\">size_t</span> len)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *ptr = dest; <span class=\"comment\">// 用char来限定每次指针+1只移动一个字节。</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (len-- &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    *ptr++ = val;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> dest;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>假设<code>hdrlen+initlen+1</code> 为8 ，经过memset后，从sh首字节开始共有8个字节都被置为0。</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1553525055/blog/memset.png\" alt=\"\"></p>\n<p>指针的类型时用来确定指针需要从首地址寻址（偏移）多少个字节。比如int * 指针说明指针存储的地址朝后面偏移3个字节才是这个int类型的所有数据。即指针存储的地址时起点，而终点是由类型来确定的。此外，类型也是指针加减的步长，比如char类型的步长就是1byte，而uint_16类型的指针步长就是2byte。</p>\n<p>随后用switch语句对不同类型的sdshdr设置初始值。</p>\n<p>首先是sdshdr5</p>\n<p> <code>*fp = type | (initlen &lt;&lt; SDS_TYPE_BITS)</code> 使用移位和或操作的方式来对8个bit位赋值。(不得不感慨这些操作真的是太巧妙了)</p>\n<p>假设initlen为3。则initlen的二进制为0000 0011（应该是8byte（64位机器）或者4byte（32位机器），为了简单用1byte的二进制表示）而SDS_TYPE_BITS 为3。所以先将initlen 左移3个bit 变成0000 0001 1000(共有8byte或者4byte)。再与type进行或运算。type为0000 0000 进行或运算后，得到的内容是8bit的，因为type是char类型，即0001 1000 。</p>\n<p>其他sdshdr类型的设置都差不多，详解下sdshdr8.</p>\n<p><code>SDS_HDR_VAR(8,s)</code>  <code>SDS_HDR_VAR</code> 是个宏定义的函数</p>\n<p><code>#define SDS_HDR_VAR(T,s) struct sdshdr##T *sh = (void*)((s)-(sizeof(struct sdshdr##T)));</code></p>\n<p>采用宏定义函数的好处是</p>\n<ol>\n<li>能够减少额外的开销 因为如果写成普通函数的话，函数的调用会在用户栈开辟空间，形参压栈，返回时还需要释放栈，可想而知的开销。使用宏定义函数则在代码规模和速度方面都比函数更胜一筹。宏定义的本质就是替换，所以在使用宏定义函数的地方，执行的时候相当于是在直接执行<code>struct sdshdr##T *sh = (void*)((s)-(sizeof(struct sdshdr##T)))</code> 这句代码</li>\n<li>函数的参数必须被声明为一种特定的类型，所以它只能在类型合适的表达式上使用。而宏定义则可以用于整形、长整形、单浮点型、双浮点型以及其他任何可以用“&gt;”操作符比较值大小的类型，也就是说，宏是与类型无关的。（有点C++模版类的感觉）</li>\n</ol>\n<p>宏定义函数中的## 是（token-pasting）<strong>符号连接操作符</strong> 直接将形参T链接到sdshdr上面。也就是sdshdrT。</p>\n<p>所以这句代码也就很简单了，将字符串指针s向后移动header的大小，也就得到了header的指针。（不过有个疑问是为什么还要重新获取headr的地址，最开始不就是指向了header吗？，难道memset是直接对sh进行操作的？测试过了，memset不会修改sh的地址，所以应该是为了再次确保sh一定指向header）</p>\n<p>解释一下：SDS_HDR_VAR 的作用是将sh的类型修改为结构体指针，因为之前sh 一直都是空指针，(虽然指针的指向地址是headr，但是没有限定它类型)不然后面没法用sh-&gt;len, sh-&gt;alloc 来访问对应的结构体成员。</p>\n<p>最开始创建的时候alloc 和len是一样大的，没有分配多余空间）</p>\n<p><code>memcpy(s, init, initlen);</code> 函数将init的前initlen个字符拷贝给s。</p>\n<p>memcpy源码为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* Public domain.  */</span><br><span class=\"line\">#include &lt;stddef.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">void *</span><br><span class=\"line\">memcpy (void *dest, const void *src, size_t len)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  char *d = dest;</span><br><span class=\"line\">  const char *s = src;</span><br><span class=\"line\">  while (len--)</span><br><span class=\"line\">    *d++ = *s++;</span><br><span class=\"line\">  return dest;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>整个过程中的三个指针sh,s,fp对应关系如下图</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1553525055/blog/sds.png\" alt=\"\"></p>\n</li>\n</ol>\n<h2 id=\"销毁\"><a href=\"#销毁\" class=\"headerlink\" title=\"销毁\"></a>销毁</h2><p>销毁使用sdsfree来实现</p>\n<p>源码为：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Free an sds string. No operation is performed if 's' is NULL. */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sdsfree</span><span class=\"params\">(sds s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    s_free((<span class=\"keyword\">char</span>*)s-sdsHdrSize(s[<span class=\"number\">-1</span>]));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>s[-1],就是指针s向后移动移位，也就是flag的位置。将s移动到sh的位置，释放sh指针也就释放了整个sds内存。</p>\n<p>疑惑：sh指针在sdsnewlen函数中是个局部变量，在sdsnewlen函数中是自动释放的，这里并没有传递sh指针为什么也可以释放对应的空间？</p>\n<p>自己想了下：malloc 函数传递的参数是需要分配的内存大小(len)，返回的是指针也就是地址。free()函数只用将malloc函数返回的指针(地址)作为参数传入，就可以释放之前该地址分配到的内存空间。而地址只是首地址，总共的偏移量（大小），应该是由操作系统在内存分配的时候就记录了的。</p>\n<p>博客中记录：申请的时候实际上占用的内存要比申请的大。因为超出的空间是用来记录对这块内存的管理信息。额外的空间用来记录管理信息——分配块的长度，指向下一个分配块的指针等等。果然malloc的时候用来一个struct来记录分配的信息。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">mem_control_block</span> &#123;</span> </span><br><span class=\"line\">  <span class=\"keyword\">int</span> is_available;    <span class=\"comment\">//一般来说应该是一个可用空间的首地址，但这里英文单词却显示出空间是否可用的一个标记</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> size;            <span class=\"comment\">//这是实际空间的大小 </span></span><br><span class=\"line\">  &#125;;</span><br></pre></td></tr></table></figure>\n<p><a href=\"http://www.cnblogs.com/hanyonglu/archive/2011/04/28/2031271.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/hanyonglu/archive/2011/04/28/2031271.html</a></p>\n<p>free()就是根据这个结构体的信息来释放malloc()申请的空间</p>\n<p>另外的疑惑：释放完空间后，s 指针不用把它指向null吗？  </p>\n<p>暂时就只是创建和销毁的源码把，看了两天，阅读源码真的是酣畅淋漓，收获良多。学到了很多奇妙的C技巧，还对操作系统的知识有了更具象的理解。</p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>阅读sdsfromlonglong部分的源码：</p>\n<p>sdsfromlonglong 函数用于将一个long long 类型的整形数字转换为字符数组。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Create an sds string from a long long value. It is much faster than:</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * sdscatprintf(sdsempty(),\"%lld\\n\", value);</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\">sds <span class=\"title\">sdsfromlonglong</span><span class=\"params\">(<span class=\"keyword\">long</span> <span class=\"keyword\">long</span> value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> buf[SDS_LLSTR_SIZE];  <span class=\"comment\">// 给buf数组分配最小的空间，21的长度</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = sdsll2str(buf,value); <span class=\"comment\">//将long long 转为字符数组存储在buf中，并返回字符串的长度</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> sdsnewlen(buf,len);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到主要的转换操作在sdsll2str这个函数中：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Helper for sdscatlonglong() doing the actual number -&gt; string</span></span><br><span class=\"line\"><span class=\"comment\"> * conversion. 's' must point to a string with room for at least</span></span><br><span class=\"line\"><span class=\"comment\"> * SDS_LLSTR_SIZE bytes.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * The function returns the length of the null-terminated string</span></span><br><span class=\"line\"><span class=\"comment\"> * representation stored at 's'. */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SDS_LLSTR_SIZE 21</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sdsll2str</span><span class=\"params\">(<span class=\"keyword\">char</span> *s, <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *p, aux;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> v; </span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> l;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Generate the string representation, this method produces</span></span><br><span class=\"line\"><span class=\"comment\">     * an reversed string. */</span></span><br><span class=\"line\">    v = (value &lt; <span class=\"number\">0</span>) ? -value : value;  <span class=\"comment\">//判断是否为负数</span></span><br><span class=\"line\">    p = s;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        *p++ = <span class=\"string\">'0'</span>+(v%<span class=\"number\">10</span>); <span class=\"comment\">// 除以10取余数</span></span><br><span class=\"line\">        v /= <span class=\"number\">10</span>;     <span class=\"comment\">//去除个位</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span>(v);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (value &lt; <span class=\"number\">0</span>) *p++ = <span class=\"string\">'-'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Compute length and add null term. */</span></span><br><span class=\"line\">    l = p-s;   <span class=\"comment\">// 计算出字符串的长度 不含终止符</span></span><br><span class=\"line\">    *p = <span class=\"string\">'\\0'</span>; <span class=\"comment\">// 首地址填终止符。</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Reverse the string. */</span></span><br><span class=\"line\">    p--;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(s &lt; p) &#123;</span><br><span class=\"line\">        aux = *s;</span><br><span class=\"line\">        *s = *p;</span><br><span class=\"line\">        *p = aux;</span><br><span class=\"line\">        s++;</span><br><span class=\"line\">        p--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> l;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">    *p++ = <span class=\"string\">'0'</span>+(v%<span class=\"number\">10</span>); <span class=\"comment\">// 除以10取余数</span></span><br><span class=\"line\">    v /= <span class=\"number\">10</span>;     <span class=\"comment\">//去除个位</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">while</span>(v);</span><br></pre></td></tr></table></figure>\n<p>假设v是352，变成字符串是将每一个对应的10进制上面的3,5,2这三个个位、十位、百位的数字给单独变成字符。</p>\n<p><code>*p++ = &#39;0&#39;+(v%10);</code> p 指针是字符数组buf的首地址，而将整型变成字符型的操作就是与字符’0’ 相加，这样就可以对应的数字变成字符类型。同时p相应的加1来指向下一个byte用来存储下一个被转换的char。</p>\n<p>char类型存储的是对应字符的ascii值，ASCII表为：<a href=\"https://baike.baidu.com/item/ASCII/309296\" target=\"_blank\" rel=\"noopener\">https://baike.baidu.com/item/ASCII/309296</a> ，所以字符的运算实际上是对应的ASCII的值的运算。<br>v%10是除以10取余数，352%10 =2； 35%10=5，所以也就是取得v值的10进制上面的个位数。<br>所以在while循环里面每次对v除以10并取余，就可以得到对应long long 型的字符串。<br>但是因为每次得到的字符都是最后面的个位数，所以352，所输出的字符串数组为：‘2’， ‘3’， ‘5’ 是一个倒序的，因此还需要再反转一次。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Reverse the string. */</span> </span><br><span class=\"line\">p--;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(s &lt; p) &#123;</span><br><span class=\"line\">    aux = *s;</span><br><span class=\"line\">    *s = *p;</span><br><span class=\"line\">    *p = aux;</span><br><span class=\"line\">    s++;</span><br><span class=\"line\">    p--;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>字符串反转，首尾各有一个指针，当首指针小于尾指针的时候，交换数字，并同时向中间移动</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://blog.csdn.net/yangbodong22011/article/details/78419966\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/yangbodong22011/article/details/78419966</a></p>\n","site":{"data":{}},"length":9911,"excerpt":"<h1 id=\"Redis源码阅读——SDS\"><a href=\"#Redis源码阅读——SDS\" class=\"headerlink\" title=\"Redis源码阅读——SDS\"></a>Redis源码阅读——SDS</h1><p>参考Redis设计与实现 以及网上博客阅读Redis源码。</p>","more":"<p>SDS相关知识点见读书笔记。</p>\n<h2 id=\"创建和销毁\"><a href=\"#创建和销毁\" class=\"headerlink\" title=\"创建和销毁\"></a>创建和销毁</h2><p>为了能够对sds进行相关API的测试，因此把sds模块单独提出来。阅读Redis的Makefile发现，编译sds模块需要的源文件包括<code>sds.c</code>, <code>sds.h</code> <code>zmalloc.c</code> </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test-sds: sds.c sds.h</span><br><span class=\"line\">        $(REDIS_CC) sds.c zmalloc.c -DSDS_TEST_MAIN $(FINAL_LIBS) -o /tmp/sds_test</span><br><span class=\"line\">        /tmp/sds_test</span><br></pre></td></tr></table></figure>\n<p>但是实际编译后会发现会报很多函数未定义的错。原因是redis源码里面sds的内存分配、释放、重分配这些函数是封装成zmalloc,zfee这些函数的，只单纯的把zmalloc.c提取出来是远远不够的。后面发现redis的作者已经把sds给单独提出来了。包括三个源文件<code>sds.c</code>,<code>sds.h</code>,<code>sdsalloc.h</code> 因此执行如下操作即可单独把redis的sds模块提取出来。</p>\n<h3 id=\"提取sds模块\"><a href=\"#提取sds模块\" class=\"headerlink\" title=\"提取sds模块\"></a>提取sds模块</h3><ol>\n<li><p>新建redis_sds测试目录</p>\n<p>选择合适的目录下新建</p>\n<p><code>mkdir redis_sds</code></p>\n</li>\n<li><p>复制源文件至redis_sds目录下</p>\n<p>在redis源码的src目录下执行：</p>\n<p><code>cp sds.c ~/redis_sds/</code></p>\n<p><code>cp sds.h ~/redis_sds/</code></p>\n<p><code>cp sdsalloc.h ~/redis_sds/</code></p>\n</li>\n<li><p>修改sdsalloc.h </p>\n<p>复制过来的sdsalloc.h 将sds模块的内存函数封装为使用zmalloc函数。为了简化处理直接使用libc的malloc函数来进行内存管理，同时将zmalloc.h给注释掉。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//#include \"zmalloc.h\"</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> s_malloc malloc</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> s_realloc realloc</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> s_free free</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>新建主函数</p>\n<p>新建主函数sds_test.c</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"sds.c\"</span></span></span><br><span class=\"line\"><span class=\"comment\">//#include \"sds.h\"</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span> </span>&#123;</span><br><span class=\"line\">    sds s = sdsnew(<span class=\"string\">\"Hello World!\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Length:%d, Type:%d\\n\"</span>, sdslen(s), sdsReqType(sdslen(s)));</span><br><span class=\"line\"></span><br><span class=\"line\">    s = sdscat(s, <span class=\"string\">\"The length of this sentence is greater than 32 bytes\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Length:%d, Type:%d\\n\"</span>, sdslen(s), sdsReqType(sdslen(s)));</span><br><span class=\"line\"></span><br><span class=\"line\">    sdsfree(s);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>直接include sds.c 即可，因为如果#include “sds.h” 的话，sdsReqType这个函数并没有在sds.h里面声明，而且因为sdsReqType的申明是：</p>\n<p><code>static inline char sdsReqType(size_t string_size) {</code>  有static限制所以不能在sds.h中先声明，所以为了简单就直接#include 了sds.c了</p>\n</li>\n<li><p>编译  </p>\n<p>为了方便重复编译，所以写了个简单的Makefile。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test : sds_test.c sds.h sds.c sdsalloc.h</span><br><span class=\"line\">        gcc -o sdstest sds_test.c</span><br></pre></td></tr></table></figure>\n<p>只需要编译sds_test.c 即可。因为sds_test.c 里面是直接#include sds.c 了所以再</p>\n<p><code>gcc -o sdstest sds_test.c sds.c</code> 会将sds.c 里面的函数重复编译两次，造成Multiple definition 问题。</p>\n<p>之后只需要执行make命令就可以生成可执行文件sdstest。</p>\n<p>执行后输出为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./sdstest </span><br><span class=\"line\">Length:12, Type:0</span><br><span class=\"line\">Length:64, Type:1</span><br></pre></td></tr></table></figure>\n<h3 id=\"sds的创建\"><a href=\"#sds的创建\" class=\"headerlink\" title=\"sds的创建\"></a>sds的创建</h3><p>通过<code>sdsnew</code> 来创建了一个sds。sdsnew源码为：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Create a new sds string starting from a null terminated C string. */</span></span><br><span class=\"line\"><span class=\"function\">sds <span class=\"title\">sdsnew</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *init)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//使用？条件判断符来简化if语句对NULL的判断，直接使用strlen来返回字符指针的长度。</span></span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> initlen = (init == <span class=\"literal\">NULL</span>) ? <span class=\"number\">0</span> : <span class=\"built_in\">strlen</span>(init); </span><br><span class=\"line\">    <span class=\"keyword\">return</span> sdsnewlen(init, initlen);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>需要注意的是字符数组和字符指针是有区别的：字符指针的数据是存放在进程的虚拟地址空间的程序代码和数据段，是只读的不能修改。字符数组存放的字符串数据是存放在用户栈的，是可以更改的。且字符指针的数据没有”\\0”这个结束符。</p>\n<p>参考博客讲的很好：<a href=\"https://blog.csdn.net/on_1y/article/details/13030439\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/on_1y/article/details/13030439</a></p>\n<p><code>sdsnew</code> 通过把字符串长度和字符串传递给<code>sdsnewlen</code>，来完成创建。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Create a new sds string with the content specified by the 'init' pointer</span></span><br><span class=\"line\"><span class=\"comment\"> * and 'initlen'.</span></span><br><span class=\"line\"><span class=\"comment\"> * If NULL is used for 'init' the string is initialized with zero bytes.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * The string is always null-termined (all the sds strings are, always) so</span></span><br><span class=\"line\"><span class=\"comment\"> * even if you create an sds string with:</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * mystring = n(\"abc\",3);</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * You can print the string with printf() as there is an implicit \\0 at the</span></span><br><span class=\"line\"><span class=\"comment\"> * end of the string. However the string is binary safe and can contain</span></span><br><span class=\"line\"><span class=\"comment\"> * \\0 characters in the middle, as the length is stored in the sds header. */</span></span><br><span class=\"line\"><span class=\"function\">sds <span class=\"title\">sdsnewlen</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *init, <span class=\"keyword\">size_t</span> initlen)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> *sh;</span><br><span class=\"line\">    sds s;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> type = sdsReqType(initlen);  <span class=\"comment\">//返回字符串对应的type</span></span><br><span class=\"line\">    <span class=\"comment\">/* Empty strings are usually created in order to append. Use type 8</span></span><br><span class=\"line\"><span class=\"comment\">     * since type 5 is not good at this. */</span></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    空字符串使用sdshdr8来存储，而不是sdshdr5,（虽然长度小于32），因为sdshdr5不适合扩容。</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type == SDS_TYPE_5 &amp;&amp; initlen == <span class=\"number\">0</span>) type = SDS_TYPE_8;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> hdrlen = sdsHdrSize(type); <span class=\"comment\">// 返回对应类型的sdsheader长度。</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *fp; <span class=\"comment\">/* flags pointer. */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    sh = s_malloc(hdrlen+initlen+<span class=\"number\">1</span>); <span class=\"comment\">// 申请头部+字符串+NULL的大小。(单位为byte)</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!init)</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(sh, <span class=\"number\">0</span>, hdrlen+initlen+<span class=\"number\">1</span>); <span class=\"comment\">// 将sh后面对应大小的字节全部置为0；</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sh == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    s = (<span class=\"keyword\">char</span>*)sh+hdrlen; <span class=\"comment\">//s指针指向字符串的首字节。</span></span><br><span class=\"line\">    fp = ((<span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span>*)s)<span class=\"number\">-1</span>; <span class=\"comment\">// fp指针指向flag</span></span><br><span class=\"line\">    <span class=\"keyword\">switch</span>(type) &#123;  <span class=\"comment\">// 初始化sdshdr</span></span><br><span class=\"line\">        <span class=\"keyword\">case</span> SDS_TYPE_5: &#123;</span><br><span class=\"line\">            *fp = type | (initlen &lt;&lt; SDS_TYPE_BITS);<span class=\"comment\">// 设置flag这个字节的具体值</span></span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> SDS_TYPE_8: &#123;</span><br><span class=\"line\">            SDS_HDR_VAR(<span class=\"number\">8</span>,s); <span class=\"comment\">// 获取header指针sh</span></span><br><span class=\"line\">            sh-&gt;len = initlen; <span class=\"comment\">//header中len的初始</span></span><br><span class=\"line\">            sh-&gt;alloc = initlen; <span class=\"comment\">//header 中alloc的初试</span></span><br><span class=\"line\">            *fp = type;  <span class=\"comment\">//flag 的初始。</span></span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> SDS_TYPE_16: &#123;</span><br><span class=\"line\">            SDS_HDR_VAR(<span class=\"number\">16</span>,s);</span><br><span class=\"line\">            sh-&gt;len = initlen;</span><br><span class=\"line\">            sh-&gt;alloc = initlen;</span><br><span class=\"line\">            *fp = type; </span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> SDS_TYPE_32: &#123;</span><br><span class=\"line\">            SDS_HDR_VAR(<span class=\"number\">32</span>,s);</span><br><span class=\"line\">            sh-&gt;len = initlen;</span><br><span class=\"line\">            sh-&gt;alloc = initlen;</span><br><span class=\"line\">            *fp = type;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> SDS_TYPE_64: &#123;</span><br><span class=\"line\">            SDS_HDR_VAR(<span class=\"number\">64</span>,s);</span><br><span class=\"line\">            sh-&gt;len = initlen;</span><br><span class=\"line\">            sh-&gt;alloc = initlen;</span><br><span class=\"line\">            *fp = type;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (initlen &amp;&amp; init)</span><br><span class=\"line\">        <span class=\"built_in\">memcpy</span>(s, init, initlen); <span class=\"comment\">// 将字符串拷贝到s(也就是buf数组)</span></span><br><span class=\"line\">    s[initlen] = <span class=\"string\">'\\0'</span>; <span class=\"comment\">//在字符串后面添加终止符</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>char type = sdsReqType(initlen);</code> 获取sds类型，源码分析在读书笔记里面有记录。源码为</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">char</span> <span class=\"title\">sdsReqType</span><span class=\"params\">(<span class=\"keyword\">size_t</span> string_size)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (string_size &lt; <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">5</span>) <span class=\"comment\">// string_size &lt; 2^5</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> SDS_TYPE_5;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (string_size &lt; <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">8</span>)  <span class=\"comment\">//string_size &lt; 2^8</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> SDS_TYPE_8;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (string_size &lt; <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">16</span>)\t<span class=\"comment\">//string_size &lt; 2^16</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> SDS_TYPE_16;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> (LONG_MAX == LLONG_MAX)</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (string_size &lt; <span class=\"number\">1l</span>l&lt;&lt;<span class=\"number\">32</span>)  <span class=\"comment\">//string_size &lt; 2^32</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> SDS_TYPE_32;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> SDS_TYPE_64; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>采用左移来计算对应多少位的范围，而不是用2^5 这样的乘法。<strong>直接移位比使用幂来计算快很多</strong>。</p>\n<p><code>1&lt;&lt;5</code>   计算出来就是2^5 次方。1是int型，4byte32位。最低8bit位的二进制为：00000001 左移5位后变成了：00100000 对应的十进制既是32。</p>\n<p>计算n个bit位的最大值：(1&lt;&lt;n) -1</p>\n<p>但是需要注意位数不够的情况。因为1是int型，只有32个bit。所以在左移32个bit时，需要使用long long int型。用1ll来表示，此时1ll为64个bit。</p>\n<p>还得考虑机器是否为64位机器，在32位机器上LONG_MAX = 2147483647L，64位机器上LONG_MAX = 9223372036854775807L 。不论32位机器还是64位机器上 LLONG_MAX 都是9223372036854775807L 。所以当LONG_MAX == LLONG_MAX 说明字长为64bit。加上条件编译，说明在32位机器上不使用sdshdr32而直接跳到了sdshdr64，仅仅在64位机器上使用sdshdr32。原因是什么？还没想通</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">sdsHdrSize</span><span class=\"params\">(<span class=\"keyword\">char</span> type)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span>(type&amp;SDS_TYPE_MASK) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> SDS_TYPE_5:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">sizeof</span>(struct sdshdr5);</span><br><span class=\"line\">        <span class=\"keyword\">case</span> SDS_TYPE_8:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">sizeof</span>(struct sdshdr8);</span><br><span class=\"line\">        <span class=\"keyword\">case</span> SDS_TYPE_16:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">sizeof</span>(struct sdshdr16);</span><br><span class=\"line\">        <span class=\"keyword\">case</span> SDS_TYPE_32:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">sizeof</span>(struct sdshdr32);</span><br><span class=\"line\">        <span class=\"keyword\">case</span> SDS_TYPE_64:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">sizeof</span>(struct sdshdr64);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>因为struct里面的buf数组是柔性数组，计算结构体的大小的时候不会计算在内。</p>\n<p><code>memset(sh, 0, hdrlen+initlen+1);</code>  memset函数会将sh中当前位置后面的<code>hdrlen+initlen+1</code>个字节全部置于0。 注意sh指向的是<code>hdrlen+initlen+1</code> 个字节的首个字节。（sh指针存储的地址就是首个字节的地址。） </p>\n<p>memset源码为：<a href=\"https://github.com/gcc-mirror/gcc/blob/master/libgcc/memset.c\" target=\"_blank\" rel=\"noopener\">https://github.com/gcc-mirror/gcc/blob/master/libgcc/memset.c</a></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Public domain.  */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stddef.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> *</span><br><span class=\"line\"><span class=\"built_in\">memset</span> (<span class=\"keyword\">void</span> *dest, <span class=\"keyword\">int</span> val, <span class=\"keyword\">size_t</span> len)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *ptr = dest; <span class=\"comment\">// 用char来限定每次指针+1只移动一个字节。</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (len-- &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    *ptr++ = val;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> dest;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>假设<code>hdrlen+initlen+1</code> 为8 ，经过memset后，从sh首字节开始共有8个字节都被置为0。</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1553525055/blog/memset.png\" alt=\"\"></p>\n<p>指针的类型时用来确定指针需要从首地址寻址（偏移）多少个字节。比如int * 指针说明指针存储的地址朝后面偏移3个字节才是这个int类型的所有数据。即指针存储的地址时起点，而终点是由类型来确定的。此外，类型也是指针加减的步长，比如char类型的步长就是1byte，而uint_16类型的指针步长就是2byte。</p>\n<p>随后用switch语句对不同类型的sdshdr设置初始值。</p>\n<p>首先是sdshdr5</p>\n<p> <code>*fp = type | (initlen &lt;&lt; SDS_TYPE_BITS)</code> 使用移位和或操作的方式来对8个bit位赋值。(不得不感慨这些操作真的是太巧妙了)</p>\n<p>假设initlen为3。则initlen的二进制为0000 0011（应该是8byte（64位机器）或者4byte（32位机器），为了简单用1byte的二进制表示）而SDS_TYPE_BITS 为3。所以先将initlen 左移3个bit 变成0000 0001 1000(共有8byte或者4byte)。再与type进行或运算。type为0000 0000 进行或运算后，得到的内容是8bit的，因为type是char类型，即0001 1000 。</p>\n<p>其他sdshdr类型的设置都差不多，详解下sdshdr8.</p>\n<p><code>SDS_HDR_VAR(8,s)</code>  <code>SDS_HDR_VAR</code> 是个宏定义的函数</p>\n<p><code>#define SDS_HDR_VAR(T,s) struct sdshdr##T *sh = (void*)((s)-(sizeof(struct sdshdr##T)));</code></p>\n<p>采用宏定义函数的好处是</p>\n<ol>\n<li>能够减少额外的开销 因为如果写成普通函数的话，函数的调用会在用户栈开辟空间，形参压栈，返回时还需要释放栈，可想而知的开销。使用宏定义函数则在代码规模和速度方面都比函数更胜一筹。宏定义的本质就是替换，所以在使用宏定义函数的地方，执行的时候相当于是在直接执行<code>struct sdshdr##T *sh = (void*)((s)-(sizeof(struct sdshdr##T)))</code> 这句代码</li>\n<li>函数的参数必须被声明为一种特定的类型，所以它只能在类型合适的表达式上使用。而宏定义则可以用于整形、长整形、单浮点型、双浮点型以及其他任何可以用“&gt;”操作符比较值大小的类型，也就是说，宏是与类型无关的。（有点C++模版类的感觉）</li>\n</ol>\n<p>宏定义函数中的## 是（token-pasting）<strong>符号连接操作符</strong> 直接将形参T链接到sdshdr上面。也就是sdshdrT。</p>\n<p>所以这句代码也就很简单了，将字符串指针s向后移动header的大小，也就得到了header的指针。（不过有个疑问是为什么还要重新获取headr的地址，最开始不就是指向了header吗？，难道memset是直接对sh进行操作的？测试过了，memset不会修改sh的地址，所以应该是为了再次确保sh一定指向header）</p>\n<p>解释一下：SDS_HDR_VAR 的作用是将sh的类型修改为结构体指针，因为之前sh 一直都是空指针，(虽然指针的指向地址是headr，但是没有限定它类型)不然后面没法用sh-&gt;len, sh-&gt;alloc 来访问对应的结构体成员。</p>\n<p>最开始创建的时候alloc 和len是一样大的，没有分配多余空间）</p>\n<p><code>memcpy(s, init, initlen);</code> 函数将init的前initlen个字符拷贝给s。</p>\n<p>memcpy源码为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* Public domain.  */</span><br><span class=\"line\">#include &lt;stddef.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">void *</span><br><span class=\"line\">memcpy (void *dest, const void *src, size_t len)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  char *d = dest;</span><br><span class=\"line\">  const char *s = src;</span><br><span class=\"line\">  while (len--)</span><br><span class=\"line\">    *d++ = *s++;</span><br><span class=\"line\">  return dest;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>整个过程中的三个指针sh,s,fp对应关系如下图</p>\n<p><img src=\"https://res.cloudinary.com/bravey/image/upload/v1553525055/blog/sds.png\" alt=\"\"></p>\n</li>\n</ol>\n<h2 id=\"销毁\"><a href=\"#销毁\" class=\"headerlink\" title=\"销毁\"></a>销毁</h2><p>销毁使用sdsfree来实现</p>\n<p>源码为：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Free an sds string. No operation is performed if 's' is NULL. */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sdsfree</span><span class=\"params\">(sds s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    s_free((<span class=\"keyword\">char</span>*)s-sdsHdrSize(s[<span class=\"number\">-1</span>]));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>s[-1],就是指针s向后移动移位，也就是flag的位置。将s移动到sh的位置，释放sh指针也就释放了整个sds内存。</p>\n<p>疑惑：sh指针在sdsnewlen函数中是个局部变量，在sdsnewlen函数中是自动释放的，这里并没有传递sh指针为什么也可以释放对应的空间？</p>\n<p>自己想了下：malloc 函数传递的参数是需要分配的内存大小(len)，返回的是指针也就是地址。free()函数只用将malloc函数返回的指针(地址)作为参数传入，就可以释放之前该地址分配到的内存空间。而地址只是首地址，总共的偏移量（大小），应该是由操作系统在内存分配的时候就记录了的。</p>\n<p>博客中记录：申请的时候实际上占用的内存要比申请的大。因为超出的空间是用来记录对这块内存的管理信息。额外的空间用来记录管理信息——分配块的长度，指向下一个分配块的指针等等。果然malloc的时候用来一个struct来记录分配的信息。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">mem_control_block</span> &#123;</span> </span><br><span class=\"line\">  <span class=\"keyword\">int</span> is_available;    <span class=\"comment\">//一般来说应该是一个可用空间的首地址，但这里英文单词却显示出空间是否可用的一个标记</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> size;            <span class=\"comment\">//这是实际空间的大小 </span></span><br><span class=\"line\">  &#125;;</span><br></pre></td></tr></table></figure>\n<p><a href=\"http://www.cnblogs.com/hanyonglu/archive/2011/04/28/2031271.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/hanyonglu/archive/2011/04/28/2031271.html</a></p>\n<p>free()就是根据这个结构体的信息来释放malloc()申请的空间</p>\n<p>另外的疑惑：释放完空间后，s 指针不用把它指向null吗？  </p>\n<p>暂时就只是创建和销毁的源码把，看了两天，阅读源码真的是酣畅淋漓，收获良多。学到了很多奇妙的C技巧，还对操作系统的知识有了更具象的理解。</p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>阅读sdsfromlonglong部分的源码：</p>\n<p>sdsfromlonglong 函数用于将一个long long 类型的整形数字转换为字符数组。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Create an sds string from a long long value. It is much faster than:</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * sdscatprintf(sdsempty(),\"%lld\\n\", value);</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\">sds <span class=\"title\">sdsfromlonglong</span><span class=\"params\">(<span class=\"keyword\">long</span> <span class=\"keyword\">long</span> value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> buf[SDS_LLSTR_SIZE];  <span class=\"comment\">// 给buf数组分配最小的空间，21的长度</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = sdsll2str(buf,value); <span class=\"comment\">//将long long 转为字符数组存储在buf中，并返回字符串的长度</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> sdsnewlen(buf,len);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到主要的转换操作在sdsll2str这个函数中：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Helper for sdscatlonglong() doing the actual number -&gt; string</span></span><br><span class=\"line\"><span class=\"comment\"> * conversion. 's' must point to a string with room for at least</span></span><br><span class=\"line\"><span class=\"comment\"> * SDS_LLSTR_SIZE bytes.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * The function returns the length of the null-terminated string</span></span><br><span class=\"line\"><span class=\"comment\"> * representation stored at 's'. */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SDS_LLSTR_SIZE 21</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sdsll2str</span><span class=\"params\">(<span class=\"keyword\">char</span> *s, <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *p, aux;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> v; </span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> l;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Generate the string representation, this method produces</span></span><br><span class=\"line\"><span class=\"comment\">     * an reversed string. */</span></span><br><span class=\"line\">    v = (value &lt; <span class=\"number\">0</span>) ? -value : value;  <span class=\"comment\">//判断是否为负数</span></span><br><span class=\"line\">    p = s;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        *p++ = <span class=\"string\">'0'</span>+(v%<span class=\"number\">10</span>); <span class=\"comment\">// 除以10取余数</span></span><br><span class=\"line\">        v /= <span class=\"number\">10</span>;     <span class=\"comment\">//去除个位</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span>(v);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (value &lt; <span class=\"number\">0</span>) *p++ = <span class=\"string\">'-'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Compute length and add null term. */</span></span><br><span class=\"line\">    l = p-s;   <span class=\"comment\">// 计算出字符串的长度 不含终止符</span></span><br><span class=\"line\">    *p = <span class=\"string\">'\\0'</span>; <span class=\"comment\">// 首地址填终止符。</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Reverse the string. */</span></span><br><span class=\"line\">    p--;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(s &lt; p) &#123;</span><br><span class=\"line\">        aux = *s;</span><br><span class=\"line\">        *s = *p;</span><br><span class=\"line\">        *p = aux;</span><br><span class=\"line\">        s++;</span><br><span class=\"line\">        p--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> l;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">    *p++ = <span class=\"string\">'0'</span>+(v%<span class=\"number\">10</span>); <span class=\"comment\">// 除以10取余数</span></span><br><span class=\"line\">    v /= <span class=\"number\">10</span>;     <span class=\"comment\">//去除个位</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">while</span>(v);</span><br></pre></td></tr></table></figure>\n<p>假设v是352，变成字符串是将每一个对应的10进制上面的3,5,2这三个个位、十位、百位的数字给单独变成字符。</p>\n<p><code>*p++ = &#39;0&#39;+(v%10);</code> p 指针是字符数组buf的首地址，而将整型变成字符型的操作就是与字符’0’ 相加，这样就可以对应的数字变成字符类型。同时p相应的加1来指向下一个byte用来存储下一个被转换的char。</p>\n<p>char类型存储的是对应字符的ascii值，ASCII表为：<a href=\"https://baike.baidu.com/item/ASCII/309296\" target=\"_blank\" rel=\"noopener\">https://baike.baidu.com/item/ASCII/309296</a> ，所以字符的运算实际上是对应的ASCII的值的运算。<br>v%10是除以10取余数，352%10 =2； 35%10=5，所以也就是取得v值的10进制上面的个位数。<br>所以在while循环里面每次对v除以10并取余，就可以得到对应long long 型的字符串。<br>但是因为每次得到的字符都是最后面的个位数，所以352，所输出的字符串数组为：‘2’， ‘3’， ‘5’ 是一个倒序的，因此还需要再反转一次。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Reverse the string. */</span> </span><br><span class=\"line\">p--;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(s &lt; p) &#123;</span><br><span class=\"line\">    aux = *s;</span><br><span class=\"line\">    *s = *p;</span><br><span class=\"line\">    *p = aux;</span><br><span class=\"line\">    s++;</span><br><span class=\"line\">    p--;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>字符串反转，首尾各有一个指针，当首指针小于尾指针的时候，交换数字，并同时向中间移动</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://blog.csdn.net/yangbodong22011/article/details/78419966\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/yangbodong22011/article/details/78419966</a></p>"}],"PostAsset":[{"_id":"source/_posts/BigdataBench-deploy/runcc.png","slug":"runcc.png","post":"ck2yelxht001nm8tzvg8aeqoi","modified":0,"renderable":0}],"PostCategory":[{"post_id":"ck2yelxgn0000m8tzj4bx8zls","category_id":"ck2yelxgw0004m8tzgck557ju","_id":"ck2yelxh4000dm8tzlhtnthla"},{"post_id":"ck2yelxh2000bm8tz5xi33bp7","category_id":"ck2yelxh10009m8tz9jkml368","_id":"ck2yelxh9000jm8tz5bwg2lzg"},{"post_id":"ck2yelxgs0002m8tze8eh0xmf","category_id":"ck2yelxh10009m8tz9jkml368","_id":"ck2yelxhb000om8tzq2kxxzhn"},{"post_id":"ck2yelxgy0006m8tzvlupb8ja","category_id":"ck2yelxh10009m8tz9jkml368","_id":"ck2yelxhd000qm8tzhszvo08h"},{"post_id":"ck2yelxgz0007m8tzox9bcmlg","category_id":"ck2yelxha000lm8tzagoiunz1","_id":"ck2yelxhg000xm8tzuxxx0e0w"},{"post_id":"ck2yelxhe000tm8tzcimady2q","category_id":"ck2yelxha000lm8tzagoiunz1","_id":"ck2yelxhj0012m8tz37ipir7s"},{"post_id":"ck2yelxh00008m8tzixp8trq7","category_id":"ck2yelxh10009m8tz9jkml368","_id":"ck2yelxhl0015m8tzl1mi3bak"},{"post_id":"ck2yelxh3000cm8tzyx62c0wo","category_id":"ck2yelxha000lm8tzagoiunz1","_id":"ck2yelxhn001am8tz437qdnjo"},{"post_id":"ck2yelxh6000gm8tz0c5z2c5p","category_id":"ck2yelxha000lm8tzagoiunz1","_id":"ck2yelxhq001gm8tzkxwios16"},{"post_id":"ck2yelxh9000im8tz8enkbqqv","category_id":"ck2yelxha000lm8tzagoiunz1","_id":"ck2yelxhs001lm8tz5zq2mn4t"},{"post_id":"ck2yelxhq001hm8tzf8c5porz","category_id":"ck2yelxha000lm8tzagoiunz1","_id":"ck2yelxhw001rm8tz3phlegcq"},{"post_id":"ck2yelxhb000nm8tz2poqxrdh","category_id":"ck2yelxhp001fm8tza7cgnbct","_id":"ck2yelxhx001um8tzbx7kptpa"},{"post_id":"ck2yelxhc000pm8tzr2pmpp8t","category_id":"ck2yelxhp001fm8tza7cgnbct","_id":"ck2yelxhz001xm8tztao3g2k0"},{"post_id":"ck2yelxhv001qm8tzv52lln7y","category_id":"ck2yelxha000lm8tzagoiunz1","_id":"ck2yelxi00021m8tzsefep0d1"},{"post_id":"ck2yelxhf000vm8tz89pkozz7","category_id":"ck2yelxhw001sm8tz1aatnytb","_id":"ck2yelxi30026m8tzipwmsicx"},{"post_id":"ck2yelxhz001zm8tz8jjpyfv1","category_id":"ck2yelxha000lm8tzagoiunz1","_id":"ck2yelxi40029m8tzfklqd1vz"},{"post_id":"ck2yelxi10023m8tz326yiyh1","category_id":"ck2yelxha000lm8tzagoiunz1","_id":"ck2yelxi6002cm8tzj0onjpib"},{"post_id":"ck2yelxhh0010m8tz2gxmt8sw","category_id":"ck2yelxi00020m8tz5q8pbsb6","_id":"ck2yelxi7002fm8tzxeovg8ek"},{"post_id":"ck2yelxi30028m8tz121dhpz1","category_id":"ck2yelxha000lm8tzagoiunz1","_id":"ck2yelxi8002im8tz6exbr554"},{"post_id":"ck2yelxhi0011m8tzbw62unnt","category_id":"ck2yelxi30027m8tzub9f32zi","_id":"ck2yelxi9002lm8tzhyalg13p"},{"post_id":"ck2yelxhk0014m8tzqxcxl1qh","category_id":"ck2yelxhp001fm8tza7cgnbct","_id":"ck2yelxia002pm8tzwll35po6"},{"post_id":"ck2yelxhl0018m8tz4cy2jmwh","category_id":"ck2yelxhp001fm8tza7cgnbct","_id":"ck2yelxib002tm8tzu4w1ji2c"},{"post_id":"ck2yelxhn001cm8tz9xdq8iyi","category_id":"ck2yelxia002om8tzqj563jiv","_id":"ck2yelxid002xm8tzi8ulystv"},{"post_id":"ck2yelxho001em8tz0360d14m","category_id":"ck2yelxhp001fm8tza7cgnbct","_id":"ck2yelxie0031m8tzssvkzc7q"},{"post_id":"ck2yelxhr001jm8tzmkpdkp2t","category_id":"ck2yelxid002wm8tzey2x9bjy","_id":"ck2yelxig0036m8tz7ovbhd99"},{"post_id":"ck2yelxht001nm8tzvg8aeqoi","category_id":"ck2yelxi30027m8tzub9f32zi","_id":"ck2yelxih0039m8tzi40uv7fi"},{"post_id":"ck2yelxhw001tm8tz5ap31aou","category_id":"ck2yelxia002om8tzqj563jiv","_id":"ck2yelxii003bm8tztoqip665"},{"post_id":"ck2yelxhx001vm8tz1noojzfk","category_id":"ck2yelxi30027m8tzub9f32zi","_id":"ck2yelxij003fm8tze54km9xt"},{"post_id":"ck2yelxi5002bm8tzr2fmg1eu","category_id":"ck2yelxih003am8tz3poqvixe","_id":"ck2yelxij003im8tz8d8f8rtw"},{"post_id":"ck2yelxjr005hm8tzd5i2lo20","category_id":"ck2yelxhw001sm8tz1aatnytb","_id":"ck2yelxju005km8tzbf4w75q1"}],"PostTag":[{"post_id":"ck2yelxgn0000m8tzj4bx8zls","tag_id":"ck2yelxgx0005m8tzf8m9odxk","_id":"ck2yelxh8000hm8tzet92jpg5"},{"post_id":"ck2yelxgn0000m8tzj4bx8zls","tag_id":"ck2yelxh1000am8tz2156bwpr","_id":"ck2yelxha000km8tzwdm209g1"},{"post_id":"ck2yelxgs0002m8tze8eh0xmf","tag_id":"ck2yelxh5000fm8tzjrn6lm90","_id":"ck2yelxhf000um8tz7xg1yri7"},{"post_id":"ck2yelxgs0002m8tze8eh0xmf","tag_id":"ck2yelxha000mm8tz9zuaphkl","_id":"ck2yelxhg000ym8tzsd2l80nf"},{"post_id":"ck2yelxgy0006m8tzvlupb8ja","tag_id":"ck2yelxh5000fm8tzjrn6lm90","_id":"ck2yelxhl0017m8tzs11tpapo"},{"post_id":"ck2yelxgy0006m8tzvlupb8ja","tag_id":"ck2yelxhh000zm8tzgjjw1t31","_id":"ck2yelxhn001bm8tz5aumz9vw"},{"post_id":"ck2yelxgz0007m8tzox9bcmlg","tag_id":"ck2yelxhl0016m8tzcf2ypsmk","_id":"ck2yelxhs001km8tzt8bofyea"},{"post_id":"ck2yelxgz0007m8tzox9bcmlg","tag_id":"ck2yelxho001dm8tzc64u3bg0","_id":"ck2yelxhu001om8tzdjcbe8dl"},{"post_id":"ck2yelxh00008m8tzixp8trq7","tag_id":"ck2yelxhr001im8tzd3sjv5u6","_id":"ck2yelxhz001ym8tz8m92riyy"},{"post_id":"ck2yelxh00008m8tzixp8trq7","tag_id":"ck2yelxhu001pm8tzll2vnfsj","_id":"ck2yelxi00022m8tzyx3vp41h"},{"post_id":"ck2yelxh2000bm8tz5xi33bp7","tag_id":"ck2yelxh5000fm8tzjrn6lm90","_id":"ck2yelxi6002dm8tzlwbdmcqw"},{"post_id":"ck2yelxh2000bm8tz5xi33bp7","tag_id":"ck2yelxi10024m8tzajmc9erh","_id":"ck2yelxi8002gm8tzvlf7os8l"},{"post_id":"ck2yelxi30028m8tz121dhpz1","tag_id":"ck2yelxho001dm8tzc64u3bg0","_id":"ck2yelxi8002jm8tzkluz8tzd"},{"post_id":"ck2yelxi30028m8tz121dhpz1","tag_id":"ck2yelxh5000fm8tzjrn6lm90","_id":"ck2yelxi9002mm8tza3rg4g13"},{"post_id":"ck2yelxh3000cm8tzyx62c0wo","tag_id":"ck2yelxi5002am8tzuwsynbwz","_id":"ck2yelxib002qm8tz6frtbu23"},{"post_id":"ck2yelxh3000cm8tzyx62c0wo","tag_id":"ck2yelxi8002hm8tzjz8zcj1a","_id":"ck2yelxib002rm8tzvw4k566s"},{"post_id":"ck2yelxh6000gm8tz0c5z2c5p","tag_id":"ck2yelxia002nm8tzat5xzkb3","_id":"ck2yelxid002ym8tziv1wmqo8"},{"post_id":"ck2yelxh6000gm8tz0c5z2c5p","tag_id":"ck2yelxib002sm8tz51tan1ih","_id":"ck2yelxie002zm8tzx243zx35"},{"post_id":"ck2yelxh9000im8tz8enkbqqv","tag_id":"ck2yelxho001dm8tzc64u3bg0","_id":"ck2yelxif0033m8tz8pjd2c9c"},{"post_id":"ck2yelxhb000nm8tz2poqxrdh","tag_id":"ck2yelxie0030m8tzfkdqpif1","_id":"ck2yelxii003dm8tzqx2thk5z"},{"post_id":"ck2yelxhb000nm8tz2poqxrdh","tag_id":"ck2yelxif0034m8tzrn3xdfzs","_id":"ck2yelxii003em8tzfak4wssi"},{"post_id":"ck2yelxhb000nm8tz2poqxrdh","tag_id":"ck2yelxig0037m8tz3fs7kru5","_id":"ck2yelxij003hm8tzhywzlf9c"},{"post_id":"ck2yelxhc000pm8tzr2pmpp8t","tag_id":"ck2yelxii003cm8tznh1nadvy","_id":"ck2yelxik003km8tznanj4tcf"},{"post_id":"ck2yelxhc000pm8tzr2pmpp8t","tag_id":"ck2yelxij003gm8tzb8zdmjcb","_id":"ck2yelxik003lm8tzxv949tyg"},{"post_id":"ck2yelxhe000tm8tzcimady2q","tag_id":"ck2yelxik003jm8tzze8kubif","_id":"ck2yelxil003om8tzvonmt41g"},{"post_id":"ck2yelxhe000tm8tzcimady2q","tag_id":"ck2yelxik003mm8tzp7zn19tl","_id":"ck2yelxim003pm8tzd2m4kbz3"},{"post_id":"ck2yelxhf000vm8tz89pkozz7","tag_id":"ck2yelxh5000fm8tzjrn6lm90","_id":"ck2yelxim003rm8tze9ri82qn"},{"post_id":"ck2yelxhf000vm8tz89pkozz7","tag_id":"ck2yelxil003nm8tzbemsqzpe","_id":"ck2yelxim003sm8tzrw6sdrr6"},{"post_id":"ck2yelxhh0010m8tz2gxmt8sw","tag_id":"ck2yelxim003qm8tzb2u8l67g","_id":"ck2yelxin003wm8tzuua4nyfe"},{"post_id":"ck2yelxhh0010m8tz2gxmt8sw","tag_id":"ck2yelxin003tm8tzk595l8yg","_id":"ck2yelxio003xm8tzredriiyd"},{"post_id":"ck2yelxhh0010m8tz2gxmt8sw","tag_id":"ck2yelxin003um8tznw0ow0vb","_id":"ck2yelxio003zm8tzpjww7kd7"},{"post_id":"ck2yelxhi0011m8tzbw62unnt","tag_id":"ck2yelxin003vm8tzihzt87v1","_id":"ck2yelxip0042m8tzer4rcebo"},{"post_id":"ck2yelxhi0011m8tzbw62unnt","tag_id":"ck2yelxio003ym8tz6nbc2e75","_id":"ck2yelxip0043m8tz3jmhm7k1"},{"post_id":"ck2yelxhi0011m8tzbw62unnt","tag_id":"ck2yelxio0040m8tzjqz70ccu","_id":"ck2yelxip0045m8tz74yucxzf"},{"post_id":"ck2yelxhk0014m8tzqxcxl1qh","tag_id":"ck2yelxio0041m8tzkcgbq0zh","_id":"ck2yelxiq0048m8tzbdw4p2q4"},{"post_id":"ck2yelxhk0014m8tzqxcxl1qh","tag_id":"ck2yelxip0044m8tzbfxjzsku","_id":"ck2yelxiq0049m8tz3az7c1tp"},{"post_id":"ck2yelxhk0014m8tzqxcxl1qh","tag_id":"ck2yelxip0046m8tz0horgnhv","_id":"ck2yelxir004bm8tz8rkfkxij"},{"post_id":"ck2yelxhl0018m8tz4cy2jmwh","tag_id":"ck2yelxiq0047m8tzhi0r3civ","_id":"ck2yelxis004dm8tzuh5zt0eh"},{"post_id":"ck2yelxhl0018m8tz4cy2jmwh","tag_id":"ck2yelxio0041m8tzkcgbq0zh","_id":"ck2yelxis004em8tzqykdvqmq"},{"post_id":"ck2yelxhn001cm8tz9xdq8iyi","tag_id":"ck2yelxir004cm8tz93x48i71","_id":"ck2yelxit004hm8tz07cwx1mo"},{"post_id":"ck2yelxhn001cm8tz9xdq8iyi","tag_id":"ck2yelxis004fm8tzhbhtdlat","_id":"ck2yelxit004im8tzhsv53czs"},{"post_id":"ck2yelxho001em8tz0360d14m","tag_id":"ck2yelxip0046m8tz0horgnhv","_id":"ck2yelxiu004nm8tzmsr4lrbg"},{"post_id":"ck2yelxho001em8tz0360d14m","tag_id":"ck2yelxit004jm8tzq2y9p016","_id":"ck2yelxiu004om8tz7o2b951v"},{"post_id":"ck2yelxho001em8tz0360d14m","tag_id":"ck2yelxit004km8tzuzfprmv7","_id":"ck2yelxiv004qm8tzx8fbf3pv"},{"post_id":"ck2yelxho001em8tz0360d14m","tag_id":"ck2yelxio0041m8tzkcgbq0zh","_id":"ck2yelxiw004rm8tzhvaofukz"},{"post_id":"ck2yelxhq001hm8tzf8c5porz","tag_id":"ck2yelxhl0016m8tzcf2ypsmk","_id":"ck2yelxiw004tm8tzgs2bwb2v"},{"post_id":"ck2yelxhq001hm8tzf8c5porz","tag_id":"ck2yelxiu004mm8tz93pf8u5r","_id":"ck2yelxiw004um8tzvvxyt0ko"},{"post_id":"ck2yelxhr001jm8tzmkpdkp2t","tag_id":"ck2yelxiu004pm8tzet8fiicm","_id":"ck2yelxix004wm8tz8gvgd8c5"},{"post_id":"ck2yelxht001nm8tzvg8aeqoi","tag_id":"ck2yelxiw004sm8tzjkjra9vq","_id":"ck2yelxix004xm8tzccyiine3"},{"post_id":"ck2yelxhv001qm8tzv52lln7y","tag_id":"ck2yelxhl0016m8tzcf2ypsmk","_id":"ck2yelxiy004zm8tz21sbwshk"},{"post_id":"ck2yelxhv001qm8tzv52lln7y","tag_id":"ck2yelxiw004vm8tzxpeiebvd","_id":"ck2yelxiz0050m8tzjl6hjymz"},{"post_id":"ck2yelxhw001tm8tz5ap31aou","tag_id":"ck2yelxik003mm8tzp7zn19tl","_id":"ck2yelxiz0052m8tzpn9xv1gs"},{"post_id":"ck2yelxhx001vm8tz1noojzfk","tag_id":"ck2yelxiz0051m8tz8l9oy3dt","_id":"ck2yelxj00054m8tzb12umbjq"},{"post_id":"ck2yelxhz001zm8tz8jjpyfv1","tag_id":"ck2yelxhl0016m8tzcf2ypsmk","_id":"ck2yelxj10057m8tzsslehj70"},{"post_id":"ck2yelxhz001zm8tz8jjpyfv1","tag_id":"ck2yelxiw004vm8tzxpeiebvd","_id":"ck2yelxj10058m8tzjbrb7swu"},{"post_id":"ck2yelxhz001zm8tz8jjpyfv1","tag_id":"ck2yelxj00055m8tzoeef7dou","_id":"ck2yelxj1005am8tzhlwniwxm"},{"post_id":"ck2yelxi10023m8tz326yiyh1","tag_id":"ck2yelxhl0016m8tzcf2ypsmk","_id":"ck2yelxj2005bm8tz9ift6afu"},{"post_id":"ck2yelxi10023m8tz326yiyh1","tag_id":"ck2yelxiu004mm8tz93pf8u5r","_id":"ck2yelxj2005dm8tzz8wdhify"},{"post_id":"ck2yelxi20025m8tzqyblu62c","tag_id":"ck2yelxh5000fm8tzjrn6lm90","_id":"ck2yelxj2005em8tz9s65lt6f"},{"post_id":"ck2yelxi20025m8tzqyblu62c","tag_id":"ck2yelxj10059m8tz5nbefn31","_id":"ck2yelxj2005fm8tzmjcntava"},{"post_id":"ck2yelxi5002bm8tzr2fmg1eu","tag_id":"ck2yelxj2005cm8tzxznxjd55","_id":"ck2yelxj3005gm8tzsfbkx39e"},{"post_id":"ck2yelxjr005hm8tzd5i2lo20","tag_id":"ck2yelxh5000fm8tzjrn6lm90","_id":"ck2yelxjt005im8tz1xibqkpu"},{"post_id":"ck2yelxjr005hm8tzd5i2lo20","tag_id":"ck2yelxha000mm8tz9zuaphkl","_id":"ck2yelxju005jm8tz9sy58f7a"}],"Tag":[{"name":"Hexo","_id":"ck2yelxgx0005m8tzf8m9odxk"},{"name":"Travis-CI","_id":"ck2yelxh1000am8tz2156bwpr"},{"name":"redis","_id":"ck2yelxh5000fm8tzjrn6lm90"},{"name":"源码阅读","_id":"ck2yelxha000mm8tz9zuaphkl"},{"name":"dict","_id":"ck2yelxhh000zm8tzgjjw1t31"},{"name":"Linux","_id":"ck2yelxhl0016m8tzcf2ypsmk"},{"name":"shell","_id":"ck2yelxho001dm8tzc64u3bg0"},{"name":"coding","_id":"ck2yelxhr001im8tzd3sjv5u6"},{"name":"c++","_id":"ck2yelxhu001pm8tzll2vnfsj"},{"name":"object","_id":"ck2yelxi10024m8tzajmc9erh"},{"name":"gdb","_id":"ck2yelxi5002am8tzuwsynbwz"},{"name":"工具","_id":"ck2yelxi8002hm8tzjz8zcj1a"},{"name":"docker","_id":"ck2yelxia002nm8tzat5xzkb3"},{"name":"容器","_id":"ck2yelxib002sm8tz51tan1ih"},{"name":"牛客","_id":"ck2yelxie0030m8tzfkdqpif1"},{"name":"斐波拉契数列","_id":"ck2yelxif0034m8tzrn3xdfzs"},{"name":"剑指offer","_id":"ck2yelxig0037m8tz3fs7kru5"},{"name":"OJ","_id":"ck2yelxii003cm8tznh1nadvy"},{"name":"编程","_id":"ck2yelxij003gm8tzb8zdmjcb"},{"name":"gcc","_id":"ck2yelxik003jm8tzze8kubif"},{"name":"make","_id":"ck2yelxik003mm8tzp7zn19tl"},{"name":"Makefile","_id":"ck2yelxil003nm8tzbemsqzpe"},{"name":"内存寻址","_id":"ck2yelxim003qm8tzb2u8l67g"},{"name":"寄存器","_id":"ck2yelxin003tm8tzk595l8yg"},{"name":"BIOS","_id":"ck2yelxin003um8tznw0ow0vb"},{"name":"shadowsocks","_id":"ck2yelxin003vm8tzihzt87v1"},{"name":"翻墙","_id":"ck2yelxio003ym8tz6nbc2e75"},{"name":"ipv6","_id":"ck2yelxio0040m8tzjqz70ccu"},{"name":"leetcode","_id":"ck2yelxio0041m8tzkcgbq0zh"},{"name":"归并排序","_id":"ck2yelxip0044m8tzbfxjzsku"},{"name":"分治","_id":"ck2yelxip0046m8tz0horgnhv"},{"name":"快排","_id":"ck2yelxiq0047m8tzhi0r3civ"},{"name":"汇编","_id":"ck2yelxir004cm8tz93x48i71"},{"name":"C语言","_id":"ck2yelxis004fm8tzhbhtdlat"},{"name":"哈希","_id":"ck2yelxit004jm8tzq2y9p016"},{"name":"摩尔投票","_id":"ck2yelxit004km8tzuzfprmv7"},{"name":"command","_id":"ck2yelxiu004mm8tz93pf8u5r"},{"name":"Clementine","_id":"ck2yelxiu004pm8tzet8fiicm"},{"name":"bigdatabench","_id":"ck2yelxiw004sm8tzjkjra9vq"},{"name":"运维","_id":"ck2yelxiw004vm8tzxpeiebvd"},{"name":"ceph","_id":"ck2yelxiz0051m8tz8l9oy3dt"},{"name":"网络问题","_id":"ck2yelxj00055m8tzoeef7dou"},{"name":"benchmark","_id":"ck2yelxj10059m8tz5nbefn31"},{"name":"graph","_id":"ck2yelxj2005cm8tzxznxjd55"}]}}