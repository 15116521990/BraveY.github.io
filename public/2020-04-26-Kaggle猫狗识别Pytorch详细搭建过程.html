<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon16x16.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon16x16.png">
  <link rel="mask-icon" href="/images/favicon16x16.png" color="#222">
  <meta name="google-site-verification" content="hDujO4MQUB7U9ir-4VXM5PW4fDFSq0-7G-LBX-Lh86M">
  <meta name="baidu-site-verification" content="8XIUcPkbzm">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"right","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: true,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="文章源码链接，包括Notebook和对应的Pycharm项目。求个Star！！ 需求Kaggle比赛链接 ,给出猫狗图片，然后预测图片中是狗的概率。 训练集有25,000张图片，测试集12,500 张图片。  自己最开始构思大致框架的时候的一个思维导图：  包的导入需要注意的是将tqdm 改为tqdm.notebook，从而在notebook环境下获得更好的体验。因为导入tqdm的话，会发生进度条">
<meta property="og:type" content="article">
<meta property="og:title" content="Kaggle猫狗识别Pytorch详细搭建过程">
<meta property="og:url" content="https://bravey.github.io/2020-04-26-Kaggle%E7%8C%AB%E7%8B%97%E8%AF%86%E5%88%ABPytorch%E8%AF%A6%E7%BB%86%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B.html">
<meta property="og:site_name" content="BraveY">
<meta property="og:description" content="文章源码链接，包括Notebook和对应的Pycharm项目。求个Star！！ 需求Kaggle比赛链接 ,给出猫狗图片，然后预测图片中是狗的概率。 训练集有25,000张图片，测试集12,500 张图片。  自己最开始构思大致框架的时候的一个思维导图：  包的导入需要注意的是将tqdm 改为tqdm.notebook，从而在notebook环境下获得更好的体验。因为导入tqdm的话，会发生进度条">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://res.cloudinary.com/bravey/image/upload/v1587879395/blog/deep-learning/CatAndDog.jpg">
<meta property="og:image" content="https://res.cloudinary.com/bravey/image/upload/v1587879936/blog/deep-learning/CatAndDog_xmid.jpg">
<meta property="og:image" content="https://res.cloudinary.com/bravey/image/upload/v1587879395/blog/deep-learning/output_16_0.png">
<meta property="og:image" content="https://res.cloudinary.com/bravey/image/upload/v1587879396/blog/deep-learning/tensorboard.jpg">
<meta property="og:image" content="https://res.cloudinary.com/bravey/image/upload/v1587879398/blog/deep-learning/Resnet50.jpg">
<meta property="article:published_time" content="2020-04-26T05:02:42.000Z">
<meta property="article:modified_time" content="2020-04-26T06:14:32.306Z">
<meta property="article:author" content="BraveY">
<meta property="article:tag" content="Pytorch">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://res.cloudinary.com/bravey/image/upload/v1587879395/blog/deep-learning/CatAndDog.jpg">

<link rel="canonical" href="https://bravey.github.io/2020-04-26-Kaggle%E7%8C%AB%E7%8B%97%E8%AF%86%E5%88%ABPytorch%E8%AF%A6%E7%BB%86%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Kaggle猫狗识别Pytorch详细搭建过程 | BraveY</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">BraveY</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://bravey.github.io/2020-04-26-Kaggle%E7%8C%AB%E7%8B%97%E8%AF%86%E5%88%ABPytorch%E8%AF%A6%E7%BB%86%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://imgsrc.baidu.com/forum/w%3D580/sign=9ef55a639e22720e7bcee2f24bcb0a3a/072032adcbef7609dc34669e28dda3cc7dd99ecc.jpg">
      <meta itemprop="name" content="BraveY">
      <meta itemprop="description" content="今日事，今日毕">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BraveY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          Kaggle猫狗识别Pytorch详细搭建过程
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-04-26 13:02:42 / 修改时间：14:14:32" itemprop="dateCreated datePublished" datetime="2020-04-26T13:02:42+08:00">2020-04-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index">
                    <span itemprop="name">深度学习</span>
                  </a>
                </span>
            </span>

          
            <span id="/2020-04-26-Kaggle%E7%8C%AB%E7%8B%97%E8%AF%86%E5%88%ABPytorch%E8%AF%A6%E7%BB%86%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B.html" class="post-meta-item leancloud_visitors" data-flag-title="Kaggle猫狗识别Pytorch详细搭建过程" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2020-04-26-Kaggle%E7%8C%AB%E7%8B%97%E8%AF%86%E5%88%ABPytorch%E8%AF%A6%E7%BB%86%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B.html#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020-04-26-Kaggle猫狗识别Pytorch详细搭建过程.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>13k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>12 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><a href="https://github.com/BraveY/AI-with-code/tree/master/dog-vs-cat" target="_blank" rel="noopener">文章源码链接</a>，包括Notebook和对应的Pycharm项目。求个Star！！</p>
<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p><a href="https://www.kaggle.com/c/dogs-vs-cats-redux-kernels-edition?rvi=1" target="_blank" rel="noopener">Kaggle比赛链接</a> ,给出猫狗图片，然后预测图片中是狗的概率。</p>
<p>训练集有25,000张图片，测试集12,500 张图片。</p>
<p><img src="https://res.cloudinary.com/bravey/image/upload/v1587879395/blog/deep-learning/CatAndDog.jpg" alt=""></p>
<p>自己最开始构思大致框架的时候的一个思维导图：</p>
<p><img src="https://res.cloudinary.com/bravey/image/upload/v1587879936/blog/deep-learning/CatAndDog_xmid.jpg" alt=""></p>
<h2 id="包的导入"><a href="#包的导入" class="headerlink" title="包的导入"></a>包的导入</h2><p>需要注意的是将tqdm 改为tqdm.notebook，从而在notebook环境下获得更好的体验。因为导入tqdm的话，会发生进度条打印多次的情况，体验很不好</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os </span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd </span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms,models,utils</span><br><span class="line"><span class="keyword">from</span> tqdm.notebook <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="comment"># from tqdm import tqdm_notebook as tqdm</span></span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter </span><br><span class="line"><span class="comment"># from torchvision import datasets, transforms,utils</span></span><br></pre></td></tr></table></figure>
<p>相关文件路径配置，在pycharm项目中将相关路径的配置都统一放在config.py中来管理</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">train_path = <span class="string">'D:/AIdata/dog vs cat/train'</span></span><br><span class="line">test_path = <span class="string">'D:/AIdata/dog vs cat/test1'</span></span><br><span class="line">data_root = <span class="string">'D:/AIdata/dog vs cat/'</span></span><br><span class="line">csv_path = <span class="string">'./submission_valnet.csv'</span></span><br><span class="line">tensorboard_path=<span class="string">'C:/Users/BraveY/Documents/BraveY/AI-with-code/dog-vs-cat/tensortboard'</span></span><br><span class="line">model_save_path = <span class="string">'C:/Users/BraveY/Documents/BraveY/AI-with-code/dog-vs-cat/modelDict/dogs-vs-cats-notebook.pth'</span></span><br></pre></td></tr></table></figure>
<h2 id="数据集的创建"><a href="#数据集的创建" class="headerlink" title="数据集的创建"></a>数据集的创建</h2><p>因为Kaggle官方提供的是<a href="https://www.kaggle.com/c/dogs-vs-cats-redux-kernels-edition/data" target="_blank" rel="noopener">原始数据</a>，不像之前的手写数字数据集可以从pytorch中直接下载已经处理过的数据集，可以直接将数据放入模型进行训练。因此需要我们自己实现数据集的生成。</p>
<p>数据集生成的总体思路是继承torch.utils.data.Dataset这个类，自己实现<strong>getitem</strong>和<strong>len</strong>这两个私有方法来完成对我们自己数据的读取操作。其中<strong>getitem</strong>这个函数的主要功能是根据样本的索引，返回索引对应的一张图片的图像数据X与对应的标签Y，也就是返回一个对应的训练样本。<strong>len</strong>这个函数的功能比较简单直接返回数据集中样本的个数即可。</p>
<p>具体而言，<strong>getitem</strong>的实现思路比较简单，将索引idx转换为图片的路径，然后用PIL的Image包来读取图片数据，然后将数据用torchvision的transforms转换成tensor并且进行Resize来统一大小（给出的图片尺寸不一致）与归一化，这样一来就可以得到图像数据了。因为训练集中图片的文件名上面带有猫狗的标签，所以标签可以通过对图片文件名split后得到然后转成0,1编码。</p>
<p>在获取标签的时候，因为官方提供的测试数据集中并没有猫狗的标签，所以测试集的标签逻辑稍有不同。我的做法是使用一个train标志来进行区分，对于测试的数据，直接将测试样本的标签变成图片自带的id，这样方便后面输出提交的csv文件。因为测试样本不用计算loss，所以将标签置为id是没问题的。</p>
<p>为了实现将idx索引转换成图片路径，需要在<strong>init</strong>()函数中将所有的图片路径放在一个list中，这可以用os.listdir()来实现，然后就可以根据索引去获得路径了。</p>
<p>需要注意的是，之所以<strong>getitem</strong>()需要根据索引来返回样本，是因为训练数据并不是一次性将所有样本数据加载到内存中，这样太耗内存。而是只用加载对应batch中的一部分数据，所以通过索引来加载送入模型中的一批数据。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDataset</span><span class="params">(Dataset)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, data_path:str, train=True, transform=None)</span>:</span></span><br><span class="line">        self.data_path = data_path</span><br><span class="line">        self.train_flag = train</span><br><span class="line">        <span class="keyword">if</span> transform <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.transform = transforms.Compose(</span><br><span class="line">            [</span><br><span class="line">                transforms.Resize(size = (<span class="number">224</span>,<span class="number">224</span>)),<span class="comment">#尺寸规范</span></span><br><span class="line">                transforms.ToTensor(),   <span class="comment">#转化为tensor</span></span><br><span class="line">                transforms.Normalize((<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>), (<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>)),</span><br><span class="line">            ])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.transform = transform</span><br><span class="line">        self.path_list = os.listdir(data_path)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, idx: int)</span>:</span></span><br><span class="line">        <span class="comment"># img to tensor and label to tensor</span></span><br><span class="line">        img_path = self.path_list[idx]</span><br><span class="line">        <span class="keyword">if</span> self.train_flag <span class="keyword">is</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> img_path.split(<span class="string">'.'</span>)[<span class="number">0</span>] == <span class="string">'dog'</span> : </span><br><span class="line">                label = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                label = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            label = int(img_path.split(<span class="string">'.'</span>)[<span class="number">0</span>]) <span class="comment"># split 的是str类型要转换为int</span></span><br><span class="line">        label = torch.as_tensor(label, dtype=torch.int64) <span class="comment"># 必须使用long 类型数据，否则后面训练会报错 expect long</span></span><br><span class="line">        img_path = os.path.join(self.data_path, img_path)</span><br><span class="line">        img = Image.open(img_path)</span><br><span class="line">        img = self.transform(img)</span><br><span class="line">        <span class="keyword">return</span> img, label</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.path_list)</span><br></pre></td></tr></table></figure>
<p>测试一下，确保Dataset可以正常迭代</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">train_ds = MyDataset(train_path)</span><br><span class="line">test_ds = MyDataset(test_path,train=<span class="literal">False</span>)</span><br><span class="line"><span class="keyword">for</span> i, item <span class="keyword">in</span> enumerate(tqdm(train_ds)):</span><br><span class="line"><span class="comment">#     pass</span></span><br><span class="line">    print(item)</span><br><span class="line">    <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<pre><code>(tensor([[[ 0.5922,  0.6078,  0.6392,  ...,  0.9216,  0.8902,  0.8745],
         [ 0.5922,  0.6078,  0.6392,  ...,  0.9216,  0.8980,  0.8824],
         [ 0.5922,  0.6078,  0.6392,  ...,  0.9216,  0.9059,  0.8902],
         ...,
         [ 0.2078,  0.2157,  0.2235,  ..., -0.9765, -0.9765, -0.9765],
         [ 0.2000,  0.2000,  0.2078,  ..., -0.9843, -0.9843, -0.9843],
         [ 0.1843,  0.1922,  0.2000,  ..., -0.9922, -0.9922, -0.9922]],

        [[ 0.2863,  0.3020,  0.3333,  ...,  0.6000,  0.5843,  0.5686],
         [ 0.2863,  0.3020,  0.3333,  ...,  0.6000,  0.5922,  0.5765],
         [ 0.2863,  0.3020,  0.3333,  ...,  0.6000,  0.6000,  0.5843],
         ...,
         [-0.0353, -0.0275, -0.0196,  ..., -0.9765, -0.9765, -0.9765],
         [-0.0431, -0.0431, -0.0353,  ..., -0.9843, -0.9843, -0.9843],
         [-0.0588, -0.0510, -0.0431,  ..., -0.9922, -0.9922, -0.9922]],

        [[-0.3176, -0.3020, -0.2706,  ..., -0.0588, -0.0431, -0.0510],
         [-0.3176, -0.3020, -0.2706,  ..., -0.0510, -0.0431, -0.0431],
         [-0.3176, -0.3020, -0.2706,  ..., -0.0431, -0.0275, -0.0353],
         ...,
         [-0.5608, -0.5529, -0.5451,  ..., -0.9922, -0.9922, -0.9922],
         [-0.5686, -0.5686, -0.5608,  ..., -1.0000, -1.0000, -1.0000],
         [-0.5843, -0.5765, -0.5686,  ..., -1.0000, -1.0000, -1.0000]]]), tensor(0))
</code></pre><h2 id="数据集划分"><a href="#数据集划分" class="headerlink" title="数据集划分"></a>数据集划分</h2><p>如前面所述，因为官方测试集没有标签，而且提交结果上去后只有一个log loos来作为分值，没有准确率的结果。所以为了得到准确率这个指标，需要新建个有标签的验证集来查看准确率。</p>
<p>实现思路是使用torch.utils.data.random_split(),来将官方提供训练数据集划分出一部分的验证集。我的比例是80%的训练集，20%的验证集</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">full_ds = train_ds</span><br><span class="line">train_size = int(<span class="number">0.8</span> * len(full_ds))</span><br><span class="line">validate_size = len(full_ds) - train_size</span><br><span class="line">new_train_ds, validate_ds = torch.utils.data.random_split(full_ds,[train_size, validate_size])<span class="comment">#数据集划分</span></span><br></pre></td></tr></table></figure>
<h2 id="数据加载"><a href="#数据加载" class="headerlink" title="数据加载"></a>数据加载</h2><p>我们制作的数据集并不能直接放入模型进行训练，还需要使用一个数据加载器，来加载数据集。使用torch.utils.data.DataLoader()来划分每个batch用来后面训练的时候向网络提供输入数据</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">train_loader = torch.utils.data.DataLoader(train_ds, batch_size=<span class="number">32</span>,</span><br><span class="line">                                            shuffle=<span class="literal">True</span>, pin_memory=<span class="literal">True</span>, num_workers=<span class="number">0</span>)</span><br><span class="line">test_loader = torch.utils.data.DataLoader(test_ds, batch_size=<span class="number">32</span>,</span><br><span class="line">                                            shuffle=<span class="literal">True</span>, pin_memory=<span class="literal">True</span>, num_workers=<span class="number">0</span>)</span><br><span class="line"><span class="comment">## numworkers设置不为0 会报错 Broken pipe Error 网上说是win10上的pytorch bug</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new_train_loader = torch.utils.data.DataLoader(train_ds, batch_size=<span class="number">32</span>,</span><br><span class="line">                                            shuffle=<span class="literal">True</span>, pin_memory=<span class="literal">True</span>, num_workers=<span class="number">0</span>)</span><br><span class="line">validate_loader = torch.utils.data.DataLoader(validate_ds, batch_size=<span class="number">32</span>,</span><br><span class="line">                                            shuffle=<span class="literal">True</span>, pin_memory=<span class="literal">True</span>, num_workers=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>加载过后数据形状从三维变成四维，多的维度是batch_size，这里是32个样本构成一个batch</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, item <span class="keyword">in</span> enumerate(train_loader):</span><br><span class="line"><span class="comment">#     pass</span></span><br><span class="line">    print(item[<span class="number">0</span>].shape)</span><br><span class="line">    <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<pre><code>torch.Size([32, 3, 224, 224])
</code></pre><h3 id="resize后的图像查看"><a href="#resize后的图像查看" class="headerlink" title="resize后的图像查看"></a>resize后的图像查看</h3><p>前面提到过对数据进行了resize和正则化的处理，下面是对处理后的图像的可视化</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">img_PIL_Tensor = train_ds[<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">new_img_PIL = transforms.ToPILImage()(img_PIL_Tensor).convert(<span class="string">'RGB'</span>)</span><br><span class="line">plt.imshow(new_img_PIL)</span><br><span class="line">plt.show()</span><br><span class="line"><span class="comment"># print(new_img_PIL.show())</span></span><br></pre></td></tr></table></figure>
<p><img src="https://res.cloudinary.com/bravey/image/upload/v1587879395/blog/deep-learning/output_16_0.png" alt="png"></p>
<p>​<br>​    </p>
<h2 id="网络搭建"><a href="#网络搭建" class="headerlink" title="网络搭建"></a>网络搭建</h2><p>网络搭建的框架与之前的<a href="https://zhuanlan.zhihu.com/p/112829371" target="_blank" rel="noopener">手写数字识别</a>的框架一致，两个卷积层后3个全连接层。需要注意的是参数不能套用之前的参数了，因为之前的手写数字的图片很小，而且数据量不大所以尽管参数比较大，也能在我的机子上跑起来(MX150,2GB显存)。猫狗的数据量显然比之前的大，所以需要将参数变小些，才能跑起来。 我实验了下，如果不将网络参数降低的话，只调整batch_size没有用，依然会报显存不足。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCNN</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(MyCNN,self).__init__()</span><br><span class="line">        self.conv1 = nn.Conv2d(<span class="number">3</span>,<span class="number">8</span>,kernel_size=<span class="number">3</span>,stride=<span class="number">1</span>,padding=<span class="number">1</span>) <span class="comment"># 按照公式计算后经过卷积层不改变尺寸</span></span><br><span class="line">        self.pool = nn.MaxPool2d(<span class="number">2</span>,<span class="number">2</span>) <span class="comment"># 2*2的池化 池化后size 减半</span></span><br><span class="line">        self.conv2 = nn.Conv2d(<span class="number">8</span>,<span class="number">16</span>,kernel_size=<span class="number">3</span>,stride=<span class="number">1</span>,padding=<span class="number">1</span>)</span><br><span class="line">        self.fc1 = nn.Linear(<span class="number">16</span>*<span class="number">56</span>*<span class="number">56</span>,<span class="number">256</span>)<span class="comment">#两个池化，所以是224/2/2=56</span></span><br><span class="line">        self.fc2 = nn.Linear(<span class="number">256</span>,<span class="number">64</span>)</span><br><span class="line">        self.fc3 = nn.Linear(<span class="number">64</span>,<span class="number">2</span>)</span><br><span class="line"><span class="comment">#         self.dp = nn.Dropout(p=0.5)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self,x)</span>:</span></span><br><span class="line"><span class="comment">#         print("input:", x)</span></span><br><span class="line">        x = self.pool(F.relu(self.conv1(x)))</span><br><span class="line"><span class="comment">#         print("first conv:", x)</span></span><br><span class="line">        x = self.pool(F.relu(self.conv2(x)))</span><br><span class="line"><span class="comment">#         print("second conv:", x)</span></span><br><span class="line">             </span><br><span class="line">        x = x.view(<span class="number">-1</span>, <span class="number">16</span> * <span class="number">56</span>* <span class="number">56</span>)<span class="comment">#将数据平整为一维的 </span></span><br><span class="line">        x = F.relu(self.fc1(x))</span><br><span class="line">        x = F.relu(self.fc2(x))  </span><br><span class="line">        x = self.fc3(x)  </span><br><span class="line"><span class="comment">#         x = F.log_softmax(x,dim=1) NLLLoss()才需要，交叉熵不需要</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure>
<h3 id="预训练模型"><a href="#预训练模型" class="headerlink" title="预训练模型"></a>预训练模型</h3><p>除了自己手动DIY一个网络，也可以使用Pytorch已经提供的一些性能很好的模型比如VGG16，ResNet50等等，然后微调下网络结构，来得到符合自己的任务的网络架构。还可以直接下载这些模型在ImageNet上的预训练参数，然后在自己的数据集上进行训练。</p>
<p>我在这儿选择了ResNet50网络以及预训练好的权重进行了下实验，我在实验室的机器上面用P100跑的，因为自己的笔记本显卡太垃圾了只有2GB显存。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 直接设置为True的话下载权重太慢了</span></span><br><span class="line"><span class="comment">## 所以手动用浏览器下载好了之后再重新加载</span></span><br><span class="line">resnet50 = models.resnet50(pretrained=<span class="literal">False</span>)  </span><br><span class="line">model_path = <span class="string">'D:/AIdata/dog vs cat/resnet50-19c8e357.pth'</span></span><br><span class="line">resnet50.load_state_dict(torch.load(model_path))</span><br><span class="line">resnet50.fc = nn.Linear(<span class="number">2048</span>, <span class="number">2</span>) <span class="comment">#修改最后一层网络将输出调整为两维</span></span><br></pre></td></tr></table></figure>
<h2 id="损失函数和优化函数"><a href="#损失函数和优化函数" class="headerlink" title="损失函数和优化函数"></a>损失函数和优化函数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net = MyCNN()</span><br><span class="line"><span class="comment"># net = resnet50</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">criterion = nn.CrossEntropyLoss()</span><br><span class="line"><span class="comment"># criterion = nn.BCELoss()  #二分类交叉熵损失函数</span></span><br><span class="line"><span class="comment"># criterion = nn.BCEWithLogitsLoss() #二分类交叉熵损失函数 带log loss</span></span><br><span class="line"><span class="comment"># criterion = nn.MSELoss()</span></span><br><span class="line"></span><br><span class="line">optimizer = optim.SGD(net.parameters(), lr=<span class="number">0.001</span>, momentum=<span class="number">0.9</span>)</span><br><span class="line"><span class="comment">#也可以选择Adam优化方法</span></span><br><span class="line"><span class="comment"># optimizer = torch.optim.Adam(net.parameters(),lr=1e-2)</span></span><br></pre></td></tr></table></figure>
<h2 id="训练日志的打印"><a href="#训练日志的打印" class="headerlink" title="训练日志的打印"></a>训练日志的打印</h2><p>在之前的手写数字识别的准确率的计算和画图以日志的打印比较简单，在这更新为topk准确率以及使用tensorboard来画曲线。并且使用tqdm进度条来实时的打印日志。</p>
<p>专门建立一个类来保存和更新准确率的结果，使用类来让代码更加的规范化</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AvgrageMeter</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.reset()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reset</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.avg = <span class="number">0</span></span><br><span class="line">        self.sum = <span class="number">0</span></span><br><span class="line">        self.cnt = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self, val, n=<span class="number">1</span>)</span>:</span></span><br><span class="line">        self.sum += val * n</span><br><span class="line">        self.cnt += n</span><br><span class="line">        self.avg = self.sum / self.cnt</span><br></pre></td></tr></table></figure>
<h2 id="准确率的计算"><a href="#准确率的计算" class="headerlink" title="准确率的计算"></a>准确率的计算</h2><p>torch.topk(input, k, dim=None, largest=True, sorted=True, out=None) -&gt; (Tensor, LongTensor) 返回某一维度前k个的索引<br>input：一个tensor数据<br>k：指明是得到前k个数据以及其index<br>dim： 指定在哪个维度上排序， 默认是最后一个维度<br>largest：如果为True，按照大到小排序； 如果为False，按照小到大排序<br>sorted：返回的结果按照顺序返回<br>out：可缺省，不要</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## topk的准确率计算</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">accuracy</span><span class="params">(output, label, topk=<span class="params">(<span class="number">1</span>,)</span>)</span>:</span></span><br><span class="line">    maxk = max(topk) </span><br><span class="line">    batch_size = label.size(<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 获取前K的索引</span></span><br><span class="line">    _, pred = output.topk(maxk, <span class="number">1</span>, <span class="literal">True</span>, <span class="literal">True</span>) <span class="comment">#使用topk来获得前k个的索引</span></span><br><span class="line">    pred = pred.t() <span class="comment"># 进行转置</span></span><br><span class="line">    <span class="comment"># eq按照对应元素进行比较 view(1,-1) 自动转换到行为1,的形状， expand_as(pred) 扩展到pred的shape</span></span><br><span class="line">    <span class="comment"># expand_as 执行按行复制来扩展，要保证列相等</span></span><br><span class="line">    correct = pred.eq(label.view(<span class="number">1</span>, <span class="number">-1</span>).expand_as(pred)) <span class="comment"># 与正确标签序列形成的矩阵相比，生成True/False矩阵</span></span><br><span class="line"><span class="comment">#     print(correct)</span></span><br><span class="line"></span><br><span class="line">    rtn = []</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> topk:</span><br><span class="line">        correct_k = correct[:k].view(<span class="number">-1</span>).float().sum(<span class="number">0</span>) <span class="comment"># 前k行的数据 然后平整到1维度，来计算true的总个数</span></span><br><span class="line">        rtn.append(correct_k.mul_(<span class="number">100.0</span> / batch_size)) <span class="comment"># mul_() ternsor 的乘法  正确的数目/总的数目 乘以100 变成百分比</span></span><br><span class="line">    <span class="keyword">return</span> rtn</span><br></pre></td></tr></table></figure>
<h3 id="tensorboard画图"><a href="#tensorboard画图" class="headerlink" title="tensorboard画图"></a>tensorboard画图</h3><p>详细的参数讲解参考：<a href="https://www.pytorchtutorial.com/pytorch-builtin-tensorboard/" target="_blank" rel="noopener">https://www.pytorchtutorial.com/pytorch-builtin-tensorboard/</a><br>在使用pip install安装tensorboard如果速度很慢经常断线的话可以换个国内的源：<br><code>pip config set global.index-url https://mirrors.ustc.edu.cn/pypi/web/simple</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter </span><br><span class="line">writer = SummaryWriter(<span class="string">'./tensortboard/'</span>)</span><br></pre></td></tr></table></figure>
<p>画图的结果是实时，还可以放大放小，曲线的平滑度设置等，比自己写的画图函数要方便很多：</p>
<p><img src="https://res.cloudinary.com/bravey/image/upload/v1587879396/blog/deep-learning/tensorboard.jpg" alt=""></p>
<h2 id="迭代训练"><a href="#迭代训练" class="headerlink" title="迭代训练"></a>迭代训练</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">( epoch, train_loader, device, model, criterion, optimizer,tensorboard_path)</span>:</span></span><br><span class="line">    model.train()</span><br><span class="line">    train_loss = <span class="number">0.0</span></span><br><span class="line">    top1 = AvgrageMeter()</span><br><span class="line">    train_loader = tqdm(train_loader)  <span class="comment">#转换成tqdm类型 以方便增加日志的输出</span></span><br><span class="line"></span><br><span class="line">    model = model.to(device)</span><br><span class="line">    <span class="keyword">for</span> e <span class="keyword">in</span> range(epoch):</span><br><span class="line">        running_loss = <span class="number">0.0</span></span><br><span class="line">        train_loader.set_description(<span class="string">'[%s%04d/%04d %s%f]'</span> % (<span class="string">'Epoch:'</span>, e + <span class="number">1</span>, epoch, <span class="string">'lr:'</span>, <span class="number">0.001</span>))</span><br><span class="line">        <span class="keyword">for</span> i, data <span class="keyword">in</span> enumerate(train_loader, <span class="number">0</span>):  <span class="comment"># 0是下标起始位置默认为0</span></span><br><span class="line">            inputs, labels = data[<span class="number">0</span>].to(device), data[<span class="number">1</span>].to(device)</span><br><span class="line">            <span class="comment"># 初始为0，清除上个batch的梯度信息</span></span><br><span class="line">            optimizer.zero_grad()</span><br><span class="line">            outputs = model(inputs)</span><br><span class="line">            loss = criterion(outputs,labels)</span><br><span class="line">            loss.backward()</span><br><span class="line">            optimizer.step()</span><br><span class="line">            <span class="comment"># topk 准确率计算</span></span><br><span class="line">            prec1, prec2 = accuracy(outputs, labels, topk=(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">            n = inputs.size(<span class="number">0</span>)</span><br><span class="line">            top1.update(prec1.item(), n)</span><br><span class="line">            train_loss += loss.item()</span><br><span class="line">            postfix = &#123;<span class="string">'train_loss'</span>: <span class="string">'%.6f'</span> % (train_loss / (i + <span class="number">1</span>)), <span class="string">'train_acc'</span>: <span class="string">'%.6f'</span> % top1.avg&#125;</span><br><span class="line">            train_loader.set_postfix(log=postfix)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># ternsorboard 曲线绘制</span></span><br><span class="line">            writer = SummaryWriter(tensorboard_path)</span><br><span class="line">            writer.add_scalar(<span class="string">'Train/Loss'</span>, loss.item(), epoch)</span><br><span class="line">            writer.add_scalar(<span class="string">'Train/Accuracy'</span>, top1.avg, epoch)</span><br><span class="line">            writer.flush()</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'Finished Training'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="模型评估"><a href="#模型评估" class="headerlink" title="模型评估"></a>模型评估</h2><p>准确率验证<br>在验证集上面的验证，求网络的的准确率指标</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">validate</span><span class="params">(validate_loader, device, model, criterion)</span>:</span></span><br><span class="line">    val_acc = <span class="number">0.0</span></span><br><span class="line">    model = model.to(device)</span><br><span class="line">    model.eval()</span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():  <span class="comment"># 进行评测的时候网络不更新梯度</span></span><br><span class="line">        val_top1 = AvgrageMeter()</span><br><span class="line">        validate_loader = tqdm(validate_loader)</span><br><span class="line">        validate_loss = <span class="number">0.0</span></span><br><span class="line">        <span class="keyword">for</span> i, data <span class="keyword">in</span> enumerate(validate_loader, <span class="number">0</span>):  <span class="comment"># 0是下标起始位置默认为0</span></span><br><span class="line">            inputs, labels = data[<span class="number">0</span>].to(device), data[<span class="number">1</span>].to(device)</span><br><span class="line">            <span class="comment">#         inputs,labels = data[0],data[1]</span></span><br><span class="line">            outputs = model(inputs)</span><br><span class="line">            loss = criterion(outputs, labels)</span><br><span class="line"></span><br><span class="line">            prec1, prec2 = accuracy(outputs, labels, topk=(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">            n = inputs.size(<span class="number">0</span>)</span><br><span class="line">            val_top1.update(prec1.item(), n)</span><br><span class="line">            validate_loss += loss.item()</span><br><span class="line">            postfix = &#123;<span class="string">'validate_loss'</span>: <span class="string">'%.6f'</span> % (validate_loss / (i + <span class="number">1</span>)), <span class="string">'validate_acc'</span>: <span class="string">'%.6f'</span> % val_top1.avg&#125;</span><br><span class="line">            validate_loader.set_postfix(log=postfix)</span><br><span class="line">        val_acc = val_top1.avg</span><br><span class="line">    <span class="keyword">return</span> val_acc</span><br></pre></td></tr></table></figure>
<h2 id="输出测试集的预测结果"><a href="#输出测试集的预测结果" class="headerlink" title="输出测试集的预测结果"></a>输出测试集的预测结果</h2><p>将测试集输入进网络，得到测试集的预测结果，并转换成csv文件，用来提交到Kaggle上进行评分。需要注意的是，因为官网要求给的是图片是狗的概率，需要将网络的输出转成概率值。</p>
<p>但实际上测试的时候网络的输出是一正一负的值，不是概率值。这是因为测试的时候没有计算loss ，而softmax这个过程是在计算交叉熵的时候自动计算的，所以在网络架构中最后一层全连接输出后没有softmax计算。因此需要我们手动增加上softmax的过程，这样经过softmax后就可以变成两个概率值了!将图片是狗的概率保存下来，并转成符合官方要求的提交格式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">submission</span><span class="params">(csv_path,test_loader, device, model)</span>:</span></span><br><span class="line">    result_list = []</span><br><span class="line">    model = model.to(device)</span><br><span class="line">    test_loader = tqdm(test_loader)</span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():  <span class="comment"># 进行评测的时候网络不更新梯度</span></span><br><span class="line">        <span class="keyword">for</span> i, data <span class="keyword">in</span> enumerate(test_loader, <span class="number">0</span>):</span><br><span class="line">            images, labels = data[<span class="number">0</span>].to(device), data[<span class="number">1</span>].to(device)</span><br><span class="line">            outputs = model(images)</span><br><span class="line">            softmax_func = nn.Softmax(dim=<span class="number">1</span>)  <span class="comment"># dim=1表示行的和为1</span></span><br><span class="line">            soft_output = softmax_func(outputs)</span><br><span class="line">            predicted = soft_output[:, <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(predicted)):</span><br><span class="line">                result_list.append(&#123;</span><br><span class="line">                    <span class="string">"id"</span>: labels[i].item(),</span><br><span class="line">                    <span class="string">"label"</span>: predicted[i].item()</span><br><span class="line">                &#125;)</span><br><span class="line">    <span class="comment"># 从list转成 dataframe 然后保存为csv文件</span></span><br><span class="line">    columns = result_list[<span class="number">0</span>].keys()</span><br><span class="line">    result_dict = &#123;col: [anno[col] <span class="keyword">for</span> anno <span class="keyword">in</span> result_list] <span class="keyword">for</span> col <span class="keyword">in</span> columns&#125;</span><br><span class="line">    result_df = pd.DataFrame(result_dict)</span><br><span class="line">    result_df = result_df.sort_values(<span class="string">"id"</span>)</span><br><span class="line">    result_df.to_csv(csv_path, index=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<h2 id="完整调用流程"><a href="#完整调用流程" class="headerlink" title="完整调用流程"></a>完整调用流程</h2><p> 损失函数和优化方法的确定</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">net = MyCNN()</span><br><span class="line">device = torch.device(<span class="string">"cuda:0"</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">"cpu"</span>)</span><br><span class="line">criterion = nn.CrossEntropyLoss()</span><br><span class="line"><span class="comment"># criterion = nn.BCELoss()  #二分类交叉熵损失函数</span></span><br><span class="line"><span class="comment"># criterion = nn.BCEWithLogitsLoss() #二分类交叉熵损失函数 带log loss</span></span><br><span class="line"><span class="comment"># criterion = nn.MSELoss()</span></span><br><span class="line"></span><br><span class="line">optimizer = optim.SGD(net.parameters(), lr=<span class="number">0.001</span>, momentum=<span class="number">0.9</span>)</span><br><span class="line"><span class="comment">#也可以选择Adam优化方法</span></span><br><span class="line"><span class="comment"># optimizer = torch.optim.Adam(net.parameters(),lr=1e-2)</span></span><br></pre></td></tr></table></figure>
<h3 id="训练过程"><a href="#训练过程" class="headerlink" title="训练过程"></a><strong>训练过程</strong></h3><p>需要传入epoch数目，训练数据加载器，设备，网络模型，损失函数，优化方法和tensorboard画图的路径等参数。<br>注意的是如果使用完整的官方训练数据集来训练网络后，用这个网络去在验证集上面验证是没有意义的，因为验证集的数据是从完整训练数据集上面划分出来，所以相当于在用训练数据验证性能。用划分过后的new_train_loader训练的网络在进行验证才有意义。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># train( 1, train_loader, device,net, criterion, optimizer,tensorboard_path) # 完整的训练数据集</span></span><br><span class="line">train( <span class="number">1</span>, new_train_loader, device,net, criterion, optimizer,tensorboard_path) <span class="comment"># 划分80%后的训练数据集</span></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<pre><code>Finished Training
</code></pre><p>在训练的时候会用tensorboard保存每个时刻的训练数据，需要新打开一个命令端口输入：<br><code>tensorboard --logdir=/path_to_log_dir/ --port 6006</code> 命令，然后通过在浏览器中输入网址<a href="http://localhost:6006/" target="_blank" rel="noopener">http://localhost:6006/</a> 来查看</p>
<p>模型的保存和加载</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">torch.save(net.state_dict(), model_save_path)</span><br><span class="line">val_net = MyCNN()</span><br><span class="line">val_net.load_state_dict(torch.load(<span class="string">'./dogs-vs-cats_12epoch_valnet.pth'</span>))</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<pre><code>&lt;All keys matched successfully&gt;
</code></pre><h3 id="验证过程"><a href="#验证过程" class="headerlink" title="验证过程"></a><strong>验证过程</strong></h3><p>输入的网络是上面训练过的网络，或者从模型权重保存路径加载的模型。输出模型在自己划分的验证集上面的准确率，结果是98.84%</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">validate(validate_loader,device,val_net,criterion)</span><br></pre></td></tr></table></figure>
<p>​    输出：</p>
<pre><code>98.92
</code></pre><h3 id="输出测试集预测结果"><a href="#输出测试集预测结果" class="headerlink" title="输出测试集预测结果"></a><strong>输出测试集预测结果</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">submission(<span class="string">'./test.csv'</span>,test_loader, device, val_net)</span><br></pre></td></tr></table></figure>
<p>最后在Kaggle上提交预测结果csv文件，得到打分。 需要先报名参赛这些操作，而且只有Dogs vs. Cats Redux: Kernels Edition这个才能够提交数据，最开始的那个6年前的提交通道已经关闭了。提交可以下载Kaggle的API在命令行提交，也可以直接在<a href="https://www.kaggle.com/c/dogs-vs-cats-redux-kernels-edition/submit" target="_blank" rel="noopener">提交链接</a>提交</p>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>文章基于Notebook的过程，也构建了对应的<a href="https://github.com/BraveY/AI-with-code/tree/master/dog-vs-cat/pycharm-project/src" target="_blank" rel="noopener">Pycharm项目</a>，将整个过程分模块来编码,架构更清晰。</p>
<p>我总共训练了三个网络，其中MyCNN_net_1使用全部的训练数据，MyCNN_net_2使用划分过的训练数据，RestNet50是预训练的模型，使用完整训练数据训练。</p>
<p>Kaggle上的评分是根据log loss来计算的，分数越低代表模型性能越好。然后其他两个网络使用的完整训练数据集是包含验证集的，所以没有计算验证集的准确率。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>网络</th>
<th>epochs</th>
<th>训练数据</th>
<th>得分</th>
<th>验证集准确率</th>
</tr>
</thead>
<tbody>
<tr>
<td>ResNet50</td>
<td>3</td>
<td>完整训练数据集</td>
<td>0.06691</td>
<td>-</td>
</tr>
<tr>
<td>MyCNN_net_1</td>
<td>12</td>
<td>划分的80%训练数据集</td>
<td>0.73358</td>
<td>98.92</td>
</tr>
<tr>
<td>MyCNN_net_2</td>
<td>12</td>
<td>完整训练数据集</td>
<td>0.94158</td>
<td>-</td>
</tr>
</tbody>
</table>
</div>
<p>实验结果并不严谨，只进行了一次，所以存在一些随机性。</p>
<p>其中使用预训练的ResNet50的效果非常好，在猫狗数据集上训练微调的时候loss就很低了，所以只训练了3轮。</p>
<p><img src="https://res.cloudinary.com/bravey/image/upload/v1587879398/blog/deep-learning/Resnet50.jpg" alt=""></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>自己在搭建网络的时候遇到一个问题就是随便设置的一个网络结构的时候，发现交叉熵的loss会一直维持在0.69，不下降。暂时还没有搞懂问题出在哪儿，后面有时间了研究下，</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://bravey.github.io/2020-03-13-%E4%BD%BF%E7%94%A8Pytorch%E6%A1%86%E6%9E%B6%E7%9A%84CNN%E7%BD%91%E7%BB%9C%E5%AE%9E%E7%8E%B0%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%EF%BC%88MNIST%EF%BC%89%E8%AF%86%E5%88%AB.html">之前的手写数字识别</a></p>
<p><a href="https://www.pytorchtutorial.com/pytorch-builtin-tensorboard/" target="_blank" rel="noopener">tensorboard画图</a><br><a href="https://www.zhihu.com/question/38341743" target="_blank" rel="noopener">pip源的更新</a><br><a href="https://www.cnblogs.com/marsggbo/p/10496696.html" target="_blank" rel="noopener">数据集的划分</a><br><a href="https://github.com/ShunLu91/Single-Path-One-Shot-NAS" target="_blank" rel="noopener">topk的计算</a></p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>BraveY
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://bravey.github.io/2020-04-26-Kaggle%E7%8C%AB%E7%8B%97%E8%AF%86%E5%88%ABPytorch%E8%AF%A6%E7%BB%86%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B.html" title="Kaggle猫狗识别Pytorch详细搭建过程">https://bravey.github.io/2020-04-26-Kaggle%E7%8C%AB%E7%8B%97%E8%AF%86%E5%88%ABPytorch%E8%AF%A6%E7%BB%86%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/null" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Pytorch/" rel="tag"># Pytorch</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
                <a href="/2020-04-25-leetcode-55-Jump-Game.html" rel="next" title="leetcode 55 Jump Game">
                  <i class="fa fa-chevron-left"></i> leetcode 55 Jump Game
                </a>
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
                <a href="/2020-04-29-leetcode-148-Sort-List.html" rel="prev" title="leetcode 148 Sort List">
                  leetcode 148 Sort List <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    
  <div class="comments" id="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#需求"><span class="nav-number">1.</span> <span class="nav-text">需求</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#包的导入"><span class="nav-number">2.</span> <span class="nav-text">包的导入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据集的创建"><span class="nav-number">3.</span> <span class="nav-text">数据集的创建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据集划分"><span class="nav-number">4.</span> <span class="nav-text">数据集划分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据加载"><span class="nav-number">5.</span> <span class="nav-text">数据加载</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#resize后的图像查看"><span class="nav-number">5.1.</span> <span class="nav-text">resize后的图像查看</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#网络搭建"><span class="nav-number">6.</span> <span class="nav-text">网络搭建</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#预训练模型"><span class="nav-number">6.1.</span> <span class="nav-text">预训练模型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#损失函数和优化函数"><span class="nav-number">7.</span> <span class="nav-text">损失函数和优化函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#训练日志的打印"><span class="nav-number">8.</span> <span class="nav-text">训练日志的打印</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#准确率的计算"><span class="nav-number">9.</span> <span class="nav-text">准确率的计算</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#tensorboard画图"><span class="nav-number">9.1.</span> <span class="nav-text">tensorboard画图</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#迭代训练"><span class="nav-number">10.</span> <span class="nav-text">迭代训练</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#模型评估"><span class="nav-number">11.</span> <span class="nav-text">模型评估</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#输出测试集的预测结果"><span class="nav-number">12.</span> <span class="nav-text">输出测试集的预测结果</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#完整调用流程"><span class="nav-number">13.</span> <span class="nav-text">完整调用流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#训练过程"><span class="nav-number">13.1.</span> <span class="nav-text">训练过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#验证过程"><span class="nav-number">13.2.</span> <span class="nav-text">验证过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#输出测试集预测结果"><span class="nav-number">13.3.</span> <span class="nav-text">输出测试集预测结果</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#结果"><span class="nav-number">14.</span> <span class="nav-text">结果</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#问题"><span class="nav-number">15.</span> <span class="nav-text">问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考"><span class="nav-number">16.</span> <span class="nav-text">参考</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="BraveY"
      src="http://imgsrc.baidu.com/forum/w%3D580/sign=9ef55a639e22720e7bcee2f24bcb0a3a/072032adcbef7609dc34669e28dda3cc7dd99ecc.jpg">
  <p class="site-author-name" itemprop="name">BraveY</p>
  <div class="site-description" itemprop="description">今日事，今日毕</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">65</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">95</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/BraveY" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;BraveY" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:kaiyongyang@gmail.com" title="E-Mail → mailto:kaiyongyang@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.zhihu.com/people/yang-shan-zhi-14" title="知乎 → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;yang-shan-zhi-14" rel="noopener" target="_blank"><i class="fa fa-fw fa-book"></i>知乎</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/qq_33620071" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_33620071" rel="noopener" target="_blank"><i class="fa fa-fw fa-copyright"></i>CSDN</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2018 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">BraveY</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">224k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">3:23</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>

<span id="sitetime"></span>
<script language=javascript>
  function siteTime(){
    window.setTimeout("siteTime()", 1000);
    var seconds = 1000;
    var minutes = seconds * 60;
    var hours = minutes * 60;
    var days = hours * 24;
    var years = days * 365;
    var today = new Date();
    var todayYear = today.getFullYear();
    var todayMonth = today.getMonth()+1;
    var todayDate = today.getDate();
    var todayHour = today.getHours();
    var todayMinute = today.getMinutes();
    var todaySecond = today.getSeconds();
    /* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
    year - 作为date对象的年份，为4位年份值
    month - 0-11之间的整数，做为date对象的月份
    day - 1-31之间的整数，做为date对象的天数
    hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
    minutes - 0-59之间的整数，做为date对象的分钟数
    seconds - 0-59之间的整数，做为date对象的秒数
    microseconds - 0-999之间的整数，做为date对象的毫秒数 */
    var t1 = Date.UTC(2018,04,17,17,36,03); //北京时间2018-4-17 17:36:03
    var t2 = Date.UTC(todayYear,todayMonth,todayDate,todayHour,todayMinute,todaySecond);
    var diff = t2-t1;
    var diffYears = Math.floor(diff/years);
    var diffDays = Math.floor((diff/days)-diffYears*365);
    var diffHours = Math.floor((diff-(diffYears*365+diffDays)*days)/hours);
    var diffMinutes = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours)/minutes);
    var diffSeconds = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours-diffMinutes*minutes)/seconds);
    document.getElementById("sitetime").innerHTML=" 已运行"+diffYears+" 年 "+diffDays+" 天 "+diffHours+" 小时 "+diffMinutes+" 分钟 "+diffSeconds+" 秒";
  }/*因为建站时间还没有一年，就将之注释掉了。需要的可以取消*/
  siteTime();
</script>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.5.0
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>






  <script>
  function leancloudSelector(url) {
    return document.getElementById(url).querySelector('.leancloud-visitors-count');
  }
  if (CONFIG.page.isPost) {
    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = visitors.getAttribute('id').trim();
      var title = visitors.getAttribute('data-flag-title').trim();

      Counter('get', `/classes/Counter?where=${JSON.stringify({ url })}`)
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .then(response => response.json())
              .then(() => {
                leancloudSelector(url).innerText = counter.time + 1;
              })
              .catch(error => {
                console.log('Failed to save visitor count', error);
              })
          } else {
              Counter('post', '/classes/Counter', { title: title, url: url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.log('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.log('LeanCloud Counter Error', error);
        });
    }
  } else {
    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return element.getAttribute('id').trim();
      });

      Counter('get', `/classes/Counter?where=${JSON.stringify({ url: { '$in': entries } })}`)
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length === 0) {
            document.querySelectorAll('.leancloud_visitors .leancloud-visitors-count').forEach(element => {
              element.innerText = 0;
            });
            return;
          }
          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.url;
            var time = item.time;
            leancloudSelector(url).innerText = time;
          }
          for (var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = leancloudSelector(url);
            if (element.innerText == '') {
              element.innerText = 0;
            }
          }
        })
        .catch(error => {
          console.log('LeanCloud Counter Error', error);
        });
    }
  }

  fetch('https://app-router.leancloud.cn/2/route?appId=W6nLzKg0cpOi9OkACkaXg3YB-gzGzoHsz')
    .then(response => response.json())
    .then(({ api_server }) => {
      var Counter = (method, url, data) => {
        return fetch(`https://${api_server}/1.1${url}`, {
          method: method,
          headers: {
            'X-LC-Id': 'W6nLzKg0cpOi9OkACkaXg3YB-gzGzoHsz',
            'X-LC-Key': '0M7O0e3b6oEuphDr3yhQLx3E',
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        const localhost = /http:\/\/(localhost|127.0.0.1|0.0.0.0)/;
        if (localhost.test(document.URL)) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    });
  </script>






        
      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  
<script src="/js/local-search.js"></script>














  

  
      
<script type="text/x-mathjax-config">

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });

  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') {
          next = next.nextSibling;
        }
        if (next && next.nodeName.toLowerCase() === 'br') {
          next.parentNode.removeChild(next);
        }
      }
    });
  });

  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      element = document.getElementById(all[i].inputID + '-Frame').parentNode;
      if (element.nodeName.toLowerCase() == 'li') {
        element = element.parentNode;
      }
      element.classList.add('has-jax');
    }
  });
</script>
<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML', () => {
    MathJax.Hub.Typeset();
  }, window.MathJax);
</script>

    

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://bravey.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  function loadComments() {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: {page: {
            url: "https://bravey.github.io/2020-04-26-Kaggle%E7%8C%AB%E7%8B%97%E8%AF%86%E5%88%ABPytorch%E8%AF%A6%E7%BB%86%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B.html",
            identifier: "2020-04-26-Kaggle猫狗识别Pytorch详细搭建过程.html",
            title: "Kaggle猫狗识别Pytorch详细搭建过程"
          }
        }
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://bravey.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  }
    window.addEventListener('load', loadComments, false);
</script>

</body>
</html>
